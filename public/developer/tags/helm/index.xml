<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>VMware Tanzu Developer Center â€“ Helm</title>
    <link>/tags/helm/</link>
    <description>Recent content in Helm on VMware Tanzu Developer Center</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 13 Jul 2021 00:00:00 +0000</lastBuildDate>
    
	  <atom:link href="/tags/helm/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      
      <title>Guides: Develop and Publish an ASP.NET Web Application using Bitnami Containers</title>
      
      <link>/guides/containers/develop-aspnet-application-bitnami-containers/</link>
      <pubDate>Thu, 03 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>/guides/containers/develop-aspnet-application-bitnami-containers/</guid>
      <description>

        
        &lt;p&gt;&lt;a href=&#34;https://www.docker.com&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker&lt;/a&gt; containers have become increasingly popular amongst developers on account of their ease of use, consistency and portability. For .NET developers looking to develop and publish applications using containers, Bitnami offers a number of options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-dotnet-sdk&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s .NET SDK container&lt;/a&gt; provides the complete .NET SDK for application development;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-dotnet&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s .NET container&lt;/a&gt; provides the .NET runtime environment for application execution;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-aspnet-core&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s ASP.NET Core container&lt;/a&gt; provides the ASP.NET runtime environment for application execution.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of these images are secure, optimized and up-to-date, enabling .NET developers to use them in daily development without being concerned about missing out on the latest language features and security fixes.&lt;/p&gt;
&lt;p&gt;This guide gets you started with Bitnami&amp;rsquo;s .NET containers, by using them to create a sample ASP.NET Web application and publish it as a container image to Docker Hub.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and Prerequisites&lt;/h2&gt;
&lt;p&gt;This guide focuses on creating a Docker image of a custom ASP.NET Web application using &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-aspnet-core&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s ASP.NET Core container image&lt;/a&gt;. In case you don&amp;rsquo;t have an ASP.NET Web application at hand, the first step of this guide shows you how to create one.&lt;/p&gt;
&lt;p&gt;This guide makes the following assumptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have a Docker environment installed and configured. &lt;a href=&#34;https://docs.docker.com/engine/installation/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about installing Docker&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a Docker Hub account. &lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Register for a free account&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a basic understanding of how containers work. Learn more about containers in &lt;a href=&#34;https://www.youtube.com/watch?v=Pb1bgI59dF0&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;our YouTube video&lt;/a&gt;, on &lt;a href=&#34;https://en.wikipedia.org/wiki/Operating-system-level_virtualization&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Wikipedia&lt;/a&gt; and on &lt;a href=&#34;http://www.zdnet.com/article/containers-fundamental-to-the-evolution-of-the-cloud/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;ZDNet&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-1-create-or-obtain-the-application-source-code&#34;&gt;Step 1: Create or obtain the application source code&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;If you already have an ASP.NET Web application of your own, you can use that instead and skip to &lt;a href=&#34;#step-2-build-a-docker-image-of-the-application&#34;&gt;Step 2&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The first step is to create a sample ASP.NET Web application which generates a welcome message. If you don&amp;rsquo;t have .NET installed, an easy way to do this is with the .NET CLI from &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-dotnet-sdk&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s .NET SDK container image&lt;/a&gt;. This allows you to execute .NET CLI commands using the Bitnami .NET SDK container on your host, exactly as though you had the complete .NET SDK already installed. If you already have a .NET development environment, you can use that instead and skip the Docker commands below.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Create a working directory for the application on your local host and make it the current directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;mkdir myapp
&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; myapp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use the following Docker commands to create and start a &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-dotnet-sdk&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami .NET SDK container&lt;/a&gt; on your host:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker create --rm -v &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;:/app --net&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;host&amp;#34;&lt;/span&gt; -t --name dotnetsdk bitnami/dotnet-sdk:latest
docker start dotnetsdk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;em&gt;-v&lt;/em&gt; argument to the first command tells Docker to mount the host&amp;rsquo;s current directory into the container&amp;rsquo;s &lt;em&gt;/app&lt;/em&gt; path, so that the effects of commands run in the container are seen on the host. The &lt;em&gt;&amp;ndash;net=&amp;ldquo;host&amp;rdquo;&lt;/em&gt; argument tells Docker to use the host&amp;rsquo;s network stack for the container, and the &lt;em&gt;&amp;ndash;rm&lt;/em&gt; argument removes the container once it exits. The container is named &lt;em&gt;dotnetsdk&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Once the container is running, connect to the container console with the command below. This will give you a command shell and allow you to use the .NET SDK tools available in the image for subsequent tasks.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; -it dotnetsdk bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Install the ASP.NET Web application templates and then use the .NET CLI to create a skeleton ASP.NET Web application:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;dotnet new -i /opt/bitnami/dotnet-sdk/templates/3.1.3/microsoft.dotnet.web.projecttemplates.3.1.3.1.2.nupkg
&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; /app
dotnet new webapp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Modify the application&amp;rsquo;s default welcome page:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sed -i &lt;span class=&#34;s1&#34;&gt;&amp;#39;s/Welcome/Hello from Bitnami/g&amp;#39;&lt;/span&gt; Pages/Index.cshtml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the application:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;dotnet run --urls&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;http://0.0.0.0:5000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will run the ASP.NET Web application on port 5000 and allow it to accept incoming connections from other hosts. To test it, browse to http://DOCKER-HOST-ADDRESS:5000/, where DOCKER-HOST-ADDRESS is the IP address of your host, and confirm that you see the modified welcome page shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/develop-aspnet-application-bitnami-containers/welcome.png&#34; alt=&#34;Default page&#34;  /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If the Docker host is a different machine, ensure that the host firewall is configured to allow access on port 5000.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Once you have confirmed that the application works, proceed to publish it:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;dotnet publish
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The published application will be stored in the &lt;em&gt;/app/bin/Debug/netcoreapp3.1/publish/&lt;/em&gt; directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exit and stop the container.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker stop dotnetsdk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-2-build-a-docker-image-of-the-application&#34;&gt;Step 2: Build a Docker image of the application&lt;/h2&gt;
&lt;p&gt;Once you have a published, tested version of your application, you can proceed to build a Docker image for it.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Create a file named &lt;em&gt;Dockerfile&lt;/em&gt; in the application&amp;rsquo;s working directory and fill it with the following content:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM bitnami/aspnet-core:latest
COPY ./bin/Debug/netcoreapp3.1/publish/ /app/
RUN useradd -r -u 1001 -g root nonroot
RUN chown -R nonroot /app
USER nonroot
WORKDIR /app
CMD [ &amp;quot;./app&amp;quot;, &amp;quot;--urls=http://0.0.0.0:5000&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This &lt;em&gt;Dockerfile&lt;/em&gt; uses the &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-aspnet-core&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami ASP.NET Core image&lt;/a&gt; as its starting point, because this image contains the ASP.NET framework and files needed to run an ASP.NET Web application.&lt;/p&gt;
&lt;p&gt;This &lt;em&gt;Dockerfile&lt;/em&gt; begins by copying the published application files from the current directory to the container&amp;rsquo;s &lt;em&gt;/app&lt;/em&gt; directory. It also creates a non-root user account that the application will run under. For security reasons, it&amp;rsquo;s recommended to always run your application using a non-root user account. Finally, it starts the application on port 5000.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;By default, the Bitnami .NET SDK container runs as the &lt;em&gt;root&lt;/em&gt; user, and the files generated will be owned by &lt;em&gt;root&lt;/em&gt;. Change the ownership of the files to the current user so that Docker is able to read and process them.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ..
sudo chown -R &lt;span class=&#34;nv&#34;&gt;$USER&lt;/span&gt;.&lt;span class=&#34;nv&#34;&gt;$USER&lt;/span&gt; myapp
&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; myapp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Build the image using the command below. Replace the DOCKER-USERNAME placeholder in the command below with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker build -t DOCKER-USERNAME/myapp:1.0 .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The result of this command is an image containing the application, the ASP.NET framework and all the related dependencies.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;step-3-test-and-publish-the-docker-image&#34;&gt;Step 3: Test and publish the Docker image&lt;/h1&gt;
&lt;p&gt;Once you have the application image, you can test it and publish it as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Run the new Docker image in a container to test it with the &lt;em&gt;docker run&lt;/em&gt; command. Replace the DOCKER_USERNAME placeholder in the command with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker run -p 5000:5000 DOCKER_USERNAME/myapp:1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This command runs the application in a container and maps port 5000 of the container to port 5000 on the Docker host. With this, a user can access the application by browsing to port 5000 of the host. To test it, browse to http://DOCKER-HOST-ADDRESS:5000/, where DOCKER-HOST-ADDRESS is the IP address of your host, and confirm that you see the application welcome page shown previously.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If the Docker host is a different machine, ensure that the host firewall is configured to allow access on port 5000.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Log in to Docker Hub and publish the image. Replace the DOCKER-USERNAME placeholder in the command below with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker login
docker push DOCKER-USERNAME/myapp:1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Once published on Docker Hub, your image is publicly available by default.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-dotnet-sdk&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami .NET SDK container image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-aspnet-core&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami ASP.NET Core container image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;ASP.NET documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: What Is Helm?</title>
      
      <link>/guides/kubernetes/helm-what-is/</link>
      <pubDate>Thu, 16 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/guides/kubernetes/helm-what-is/</guid>
      <description>

        
        &lt;p&gt;&lt;a href=&#34;https://helm.sh&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm&lt;/a&gt; is a tool to help you define, install, and upgrade applications running on Kubernetes. At its most basic, Helm is a templating engine that creates Kubernetes manifests. What makes Helm more than that is it can upgrade and scale applications as well.&lt;/p&gt;
&lt;h2 id=&#34;why-is-it-important&#34;&gt;Why Is It Important?&lt;/h2&gt;
&lt;p&gt;Helm reduces the amount of work you need to do to deploy, upgrade, and manage an application to Kubernetes. This helps limit human error and also creates a more declarative configuration to enable workflows like &lt;a href=&#34;https://www.weave.works/blog/what-is-gitops-really&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;GitOps&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This capability really stands out when you have a large, complex application; your app may contain dozens of Kubernetes objects that need to be configured and changed during upgrades.
It also applies if you&amp;rsquo;re deploying the same app multiple times. Using find-and-replace in multiple manifests is a recipe for disaster. Helm can make the process easy and repeatable.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s why an instance of a chart running on a Kubernetes cluster is called a &lt;em&gt;release&lt;/em&gt;. If you need three different installs of a web server, each one is its own release. The Helm docs includes releases as one of &lt;a href=&#34;https://helm.sh/docs/intro/using_helm/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;em&gt;three important concepts&lt;/em&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Helm installs &lt;em&gt;charts&lt;/em&gt; into Kubernetes, creating a new &lt;em&gt;release&lt;/em&gt; for each installation. And to find new charts, you can search Helm chart &lt;em&gt;repositories&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;You can read more about the &lt;a href=&#34;https://helm.sh/docs/topics/architecture/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm architecture here.&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;how-does-helm-work&#34;&gt;How Does Helm Work?&lt;/h2&gt;
&lt;p&gt;Helm combines the templates and default values in a chart with values you&amp;rsquo;ve supplied, along with information from your cluster to deploy and update applications. You can use charts directly from repos, charts you&amp;rsquo;ve downloaded, or charts you&amp;rsquo;ve created yourself. Helm uses the &lt;a href=&#34;https://golang.org/pkg/text/template/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Go templating engine&lt;/a&gt;, so if you&amp;rsquo;re familiar with that, you&amp;rsquo;ll understand how the charts work.&lt;/p&gt;
&lt;p&gt;As of Helm 3, all of the necessary data is stored locally in your Helm client config or in the cluster where the releases are installed. In previous versions of Helm, it required a component called &lt;code&gt;tiller&lt;/code&gt; installed on the cluster. That component is no longer needed so Helm is now easier to install and use.&lt;/p&gt;
&lt;h2 id=&#34;how-can-i-use-it&#34;&gt;How Can I Use It?&lt;/h2&gt;
&lt;p&gt;If you&amp;rsquo;re ready to start using Helm, check out our guide on &lt;a href=&#34;../helm-gs&#34;&gt;Getting Started With Helm&lt;/a&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Deploy a Custom Node.js Application using Bitnami Containers</title>
      
      <link>/guides/containers/deploy-custom-nodejs-app-bitnami-containers/</link>
      <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/guides/containers/deploy-custom-nodejs-app-bitnami-containers/</guid>
      <description>

        
        &lt;p&gt;Developers like using containers for development because they are easy to use, portable, and require less maintenance overhead compared to bare metal or virtual machines. &lt;a href=&#34;https://www.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker&lt;/a&gt; is a popular choice, because it provides tools that make it simple for developers to build, run and publish applications in containers.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;ve seen Docker in action and then wondered &amp;ldquo;can I use this with my own application&amp;rdquo;, then you&amp;rsquo;re in the right place.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://bitnami.com&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&lt;/a&gt; makes it easy to create a Docker image of your own application using its production-ready &lt;a href=&#34;https://bitnami.com/containers&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;container images&lt;/a&gt;. Once created, you can run and test your application with Docker, or publish it online so that others can find and use it. And, because Bitnami container images are always secure, optimized and up-to-date, you can rest assured that your application always has access to the latest language features and security fixes.&lt;/p&gt;
&lt;p&gt;This guide walks you through the process of creating an optimized, secure Docker image of a custom application using a Bitnami base container, then testing it and publishing it online. It also guides you through the steps to follow when you update your application and need to rebuild and republish it for your users.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and Prerequisites&lt;/h2&gt;
&lt;p&gt;This guide focuses on creating a secure and optimized Docker image of a custom Node.js application using Bitnami&amp;rsquo;s Node.js production image. In case you don&amp;rsquo;t have a Node.js application at hand, you can use &lt;a href=&#34;https://github.com/bitnami/tutorials/tree/master/simple-node-app&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;this simple &amp;ldquo;Hello world&amp;rdquo; application&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This guide makes the following assumptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have a Docker environment installed and configured. &lt;a href=&#34;https://docs.docker.com/engine/installation/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about installing Docker&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a Docker Hub account. &lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Register for a free account&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have Git installed and configured.&lt;/li&gt;
&lt;li&gt;You have a basic understanding of how containers work. Learn more about containers in &lt;a href=&#34;https://www.youtube.com/watch?v=Pb1bgI59dF0&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;our YouTube video&lt;/a&gt;, on &lt;a href=&#34;https://en.wikipedia.org/wiki/Operating-system-level_virtualization&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Wikipedia&lt;/a&gt; and on &lt;a href=&#34;http://www.zdnet.com/article/containers-fundamental-to-the-evolution-of-the-cloud/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;ZDNet&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-1-create-or-obtain-the-application-source-code&#34;&gt;Step 1: Create or obtain the application source code&lt;/h2&gt;
&lt;p&gt;To begin the process, ensure that you have access to the application source code. If you don&amp;rsquo;t have an existing Node.js application, follow the steps below to create one:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Create a working directory for the application on your local host:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;mkdir myproject
&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; myproject
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;package.json&lt;/em&gt; file listing the dependencies for the project:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;simple-node-app&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;1.0.0&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Node.js on Docker&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;main&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;server.js&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;scripts&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;node server.js&amp;#34;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;dependencies&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;express&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;^4.13&amp;#34;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;server.js&lt;/em&gt; file for the Express application which returns a &amp;ldquo;Hello world&amp;rdquo; message on access:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;use strict&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;express&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;require&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;express&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Constants
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// App
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;express&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Hello world\n&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;console&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Running on http://localhost:&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-2-create-a-dockerfile&#34;&gt;Step 2: Create a Dockerfile&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;Dockerfile&lt;/em&gt; is similar to a recipe: it contains all the ingredients needed to create a Docker image. Typically, each line represents a separate step and begins with an instruction keyword followed by a series of arguments. &lt;a href=&#34;https://docs.docker.com/engine/reference/builder&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about the &lt;em&gt;Dockerfile&lt;/em&gt; format&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the project directory, create a file named &lt;em&gt;Dockerfile&lt;/em&gt; and fill it with the following content:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;# First build stage
FROM bitnami/node:12 as builder
ENV NODE_ENV=&amp;#34;production&amp;#34;

# Copy app&amp;#39;s source code to the /app directory
COPY . /app

# The application&amp;#39;s directory will be the working directory
WORKDIR /app

# Install Node.js dependencies defined in &amp;#39;/app/packages.json&amp;#39;
RUN npm install

# Second build stage
FROM bitnami/node:12-prod
ENV NODE_ENV=&amp;#34;production&amp;#34;

# Copy the application code
COPY --from=builder /app /app

# Create a non-root user
RUN useradd -r -u 1001 -g root nonroot
RUN chown -R nonroot /app
USER nonroot

WORKDIR /app
EXPOSE 3000

# Start the application
CMD [&amp;#34;npm&amp;#34;, &amp;#34;start&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This &lt;em&gt;Dockerfile&lt;/em&gt; consists of two build stages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first stage uses the Bitnami Node.js 12.x development image to copy the application source and install the required application modules using &lt;em&gt;npm install&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The second stage uses the Bitnami Node.js 12.x production image and creates a minimal Docker image that only consists of the application source, modules and Node.js runtime.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Bitnami&amp;rsquo;s Node.js production image is different from its Node.js development image, because the production image (tagged with the suffix &lt;em&gt;prod&lt;/em&gt;) is based on &lt;a href=&#34;https://github.com/bitnami/minideb&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;minideb&lt;/a&gt; and does not include additional development dependencies. It is therefore lighter and smaller in size than the development image and is commonly used in multi-stage builds as the final target image.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;first-build-stage&#34;&gt;First build stage&lt;/h3&gt;
&lt;p&gt;Let&amp;rsquo;s take a closer look at the steps in the first build stage:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;FROM&lt;/em&gt; instruction kicks off the &lt;em&gt;Dockerfile&lt;/em&gt; and specifies the base image to use. Bitnami offers a number of container images for Docker which can be used as base images. Since the example application used in this guide is a Node.js application, &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Node.js development container&lt;/a&gt; is the best choice for the base image.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;NODE_ENV&lt;/em&gt; environment variable is defined so that &lt;em&gt;npm install&lt;/em&gt; only installs the application modules that are required in production environments.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;COPY&lt;/em&gt; instruction copies the source code from the current directory on the host to the &lt;em&gt;/app&lt;/em&gt; directory in the image.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;RUN&lt;/em&gt; instruction executes a shell command. It&amp;rsquo;s used to run &lt;em&gt;npm install&lt;/em&gt; to install the application dependencies.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;WORKDIR&lt;/em&gt; instructions set the working directory for the image.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;second-build-stage&#34;&gt;Second build stage&lt;/h3&gt;
&lt;p&gt;Here is what happens in the second build stage:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Since the target here is a minimal, secure image, the &lt;em&gt;FROM&lt;/em&gt; instruction specifies &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Node.js production container&lt;/a&gt; as the base image. Bitnami production images can be identified by the suffix &lt;em&gt;prod&lt;/em&gt; in the image tag.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;COPY&lt;/em&gt; instruction copies the source code and installed dependencies from the first stage to the &lt;em&gt;/app&lt;/em&gt; directory in the image.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;RUN&lt;/em&gt; commands create a non-root user account that the application will run under. For security reasons, it&amp;rsquo;s recommended to always run your application using a non-root user account.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;CMD&lt;/em&gt; instruction specifies the command to run when the image starts. In this case, &lt;em&gt;npm start&lt;/em&gt; will start the application.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-3-build-the-docker-image&#34;&gt;Step 3: Build the Docker image&lt;/h2&gt;
&lt;p&gt;Once the &lt;em&gt;Dockerfile&lt;/em&gt; is created, building a Docker image is as simple as calling the &lt;em&gt;docker build&lt;/em&gt; command. Execute the command below in the directory containing the &lt;em&gt;Dockerfile&lt;/em&gt;. Replace the DOCKER_USERNAME placeholder in the command below with your Docker account username. This Docker account username is necessary to avoid namespace errors when later pushing the image to your Docker Hub account.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker build -t DOCKER_USERNAME/my-node-app:0.1.0 .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;For successful execution of this and subsequent &lt;em&gt;docker&lt;/em&gt; commands, ensure that the user account you&amp;rsquo;re using belongs to the &lt;em&gt;docker&lt;/em&gt; group.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This will create an image named &lt;em&gt;my-node-app&lt;/em&gt;, tagged as version &lt;em&gt;0.1.0&lt;/em&gt;. This tag uniquely identifies a Docker image, allowing you to deploy a specific version of the application if needed.&lt;/p&gt;
&lt;p&gt;Here&amp;rsquo;s an example of what you should see during the build process:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-custom-nodejs-app-bitnami-containers/deploy-custom-nodejs-app-bitnami-containers-1.png&#34; alt=&#34;Image build process&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Once the build process is complete, use the &lt;em&gt;docker images&lt;/em&gt; command to verify that the image has been added to your local repository.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker images | grep my-node-app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The version tag added during the &lt;em&gt;docker build&lt;/em&gt; command also appears in the output of &lt;em&gt;docker images&lt;/em&gt;.  Here&amp;rsquo;s an example of what you should see:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-custom-nodejs-app-bitnami-containers/deploy-custom-nodejs-app-bitnami-containers-2.png&#34; alt=&#34;Image in local Docker registry&#34;  /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tagging image releases is a recommended practice. &lt;a href=&#34;https://docs.docker.com/engine/reference/commandline/tag/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about tags&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;step-4-test-the-docker-image&#34;&gt;Step 4: Test the Docker image&lt;/h2&gt;
&lt;p&gt;Run your new Docker image in a container to test it with the &lt;em&gt;docker run&lt;/em&gt; command. Replace the DOCKER_USERNAME placeholder in the command with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker run -it -p 3000:3000 DOCKER_USERNAME/my-node-app:0.1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This command runs the application in a container and makes port 3000 of the container accessible by binding it to port 3000 on the Docker host. With this, a user can access the application by browsing to port 3000 of the host.&lt;/p&gt;
&lt;p&gt;Here is what you should see as the container starts:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-custom-nodejs-app-bitnami-containers/deploy-custom-nodejs-app-bitnami-containers-3.png&#34; alt=&#34;Container startup&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;To test the application, browse to &lt;em&gt;http://localhost:3000&lt;/em&gt; (if the Docker host is the same machine) or &lt;em&gt;http://SERVER-IP:3000&lt;/em&gt; (if the Docker host is a different machine) and you should see this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-custom-nodejs-app-bitnami-containers/deploy-custom-nodejs-app-bitnami-containers-4.png&#34; alt=&#34;Application output&#34;  /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If the Docker host is a different machine, ensure that the host firewall is configured to allow access on port 3000.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &lt;em&gt;-i&lt;/em&gt; and &lt;em&gt;-t&lt;/em&gt; options to &lt;em&gt;docker run&lt;/em&gt; allocate a terminal for the container process, while the &lt;em&gt;-p&lt;/em&gt; option specifies the container-host port binding. &lt;a href=&#34;https://docs.docker.com/engine/reference/run/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about the &lt;em&gt;docker run&lt;/em&gt; command and its options&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;step-5-publish-the-docker-image&#34;&gt;Step 5: Publish the Docker image&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;This step requires a Docker Hub account. In case you don&amp;rsquo;t already have one, &lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;sign up on the Docker website&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;At this point, you have built, tagged and tested a Docker image containing your application code. To share it with others, you can upload the image to a public registry. A number of such registries are available, including &lt;a href=&#34;https://cloud.google.com/container-registry/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Google Container Registry&lt;/a&gt;, &lt;a href=&#34;https://quay.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Quay&lt;/a&gt; and others, but this guide will use &lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker Hub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To upload an image to Docker Hub, follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Use the &lt;em&gt;docker login&lt;/em&gt; command to log in:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker login
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use the &lt;em&gt;docker push&lt;/em&gt; command to push the image to your Docker Hub account, as shown below. Replace the DOCKER_USERNAME placeholder in the tag name with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker push DOCKER_USERNAME/my-node-app:0.1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here&amp;rsquo;s what you should see:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-custom-nodejs-app-bitnami-containers/deploy-custom-nodejs-app-bitnami-containers-5.png&#34; alt=&#34;Image publishing process&#34;  /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Once published on Docker Hub, your image is publicly available by default.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Check that the image has been successfully uploaded to Docker Hub by searching for it using the &lt;em&gt;docker search&lt;/em&gt; command, as shown below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker search DOCKER_USERNAME/my-node-app:0.1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once published on Docker Hub, other users can download your application and try it for themselves.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You can also delete images from Docker Hub using the Docker website.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;handling-updates&#34;&gt;Handling Updates&lt;/h2&gt;
&lt;p&gt;As you continue developing your application, you will inevitably want to release fresh Docker images. This might be to include new application features or bug fixes, or to use a new version of the base container that has the latest fixes. Doing this involves regenerating the application image and republishing it to the registry.&lt;/p&gt;
&lt;p&gt;To illustrate the process, let&amp;rsquo;s perform a code change in the example application and then release a fresh Docker image with the updated code. Follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Change to the directory containing the application source code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Edit the &lt;em&gt;server.js&lt;/em&gt; file and substitute the string &amp;ldquo;Hello world&amp;rdquo; with &amp;ldquo;Hello Mom&amp;rdquo;. Save the file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rebuild the image, tagging it as version 0.2.0. Replace the DOCKER_USERNAME placeholder in this and subsequent commands with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker build -t DOCKER_USERNAME/my-node-app:0.2.0  .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Confirm that the image was successfully built and added to the local registry:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker images | grep my-node-app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-custom-nodejs-app-bitnami-containers/deploy-custom-nodejs-app-bitnami-containers-6.png&#34; alt=&#34;Revised image in local Docker registry&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Test the new image:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker run -it -p 3000:3000 DOCKER_USERNAME/my-node-app:0.2.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here&amp;rsquo;s what you should see when you access the application through your Web browser:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-custom-nodejs-app-bitnami-containers/deploy-custom-nodejs-app-bitnami-containers-7.png&#34; alt=&#34;Application output&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Publish the new image to Docker Hub:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt; docker push DOCKER_USERNAME/my-node-app:0.2.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Follow these steps every time you want to update and republish your Docker image. If you are deploying the new image to a Kubernetes cluster, &lt;a href=&#34;https://docs.bitnami.com/tutorials/deploy-application-kubernetes-helm/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;read about rolling updates in our Kubernetes tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Node.js container image for Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bitnami.com/containers&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Other Bitnami container images for Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hub.docker.com&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker Hub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Getting Started with Using Helm to Deploy Apps on Kubernetes</title>
      
      <link>/guides/kubernetes/helm-gs/</link>
      <pubDate>Thu, 16 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/guides/kubernetes/helm-gs/</guid>
      <description>

        
        &lt;p&gt;&lt;a href=&#34;https://helm.sh&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm&lt;/a&gt; is a tool to help you define, install, and upgrade applications running on Kubernetes. For more information, be sure to check out &lt;a href=&#34;../helm-what-is/&#34;&gt;Helm: What Is It?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In this guide you&amp;rsquo;ll deploy a simple application using Helm to a Kubernetes cluster.&lt;/p&gt;
&lt;h2 id=&#34;before-you-begin&#34;&gt;Before You Begin&lt;/h2&gt;
&lt;p&gt;There are a few things you need to do before getting started with Helm:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Have access to a Kubernetes cluster. If you don&amp;rsquo;t, you can use local options like &lt;a href=&#34;https://hub.docker.com/search?type=edition&amp;amp;offering=community&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker Desktop&lt;/a&gt; or &lt;a href=&#34;https://github.com/kubernetes/minikube&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Minikube&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Check out &lt;a href=&#34;https://kube.academy/courses/getting-started&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Getting Started with Kubernetes&lt;/a&gt; on KubeAcademy, particularly if you&amp;rsquo;ve never worked with Kubernetes before.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Follow the documentation for &lt;a href=&#34;https://helm.sh/docs/intro/install/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;installing Helm&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Helm leverages your local Kubernetes context to operate, so it will have whatever permissions the account you&amp;rsquo;re using for &lt;code&gt;kubectl&lt;/code&gt; does.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;If you read about Helm and come across references to &lt;code&gt;tiller&lt;/code&gt;, previous versions (before version 3) required an extra component installed on the Kubernetes cluster.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;initial-helm-setup&#34;&gt;Initial Helm Setup&lt;/h2&gt;
&lt;p&gt;You&amp;rsquo;re going to need a chart to deploy with Helm, so the easiest thing is to connect to a chart repository with the &lt;code&gt;helm repo&lt;/code&gt; command.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ helm repo add bitnami https://charts.bitnami.com/bitnami
&amp;quot;bitnami&amp;quot; has been added to your repositories
$ helm repo update
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the &amp;quot;bitnami&amp;quot; chart repository
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now that you have a repo connected, you need to see which charts you have available to deploy.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ helm search repo bitnami
NAME                            	CHART VERSION	APP VERSION            	DESCRIPTION
bitnami/bitnami-common          	0.0.8        	0.0.8                  	Chart with custom templates used in Bitnami cha...
bitnami/airflow                 	5.0.3        	1.10.9                 	Apache Airflow is a platform to programmaticall...
bitnami/apache                  	7.3.9        	2.4.41                 	Chart for Apache HTTP Server
---- Truncated ----
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can see a whole list of charts, but the output above shows the first three. It shows the name of the chart, the versions, and the descriptions. As you&amp;rsquo;ll see, there&amp;rsquo;s both a chart version and an app version. That&amp;rsquo;s because a chart may be updated and changed separately from the underlying application it is deploying.&lt;/p&gt;
&lt;h2 id=&#34;time-to-deploy-a-chart-create-a-release&#34;&gt;Time to Deploy a Chart (Create a Release)&lt;/h2&gt;
&lt;p&gt;Now that you have Helm configured with a repo, you can deploy a chart. In Helm lingo that&amp;rsquo;s called &lt;em&gt;creating a release&lt;/em&gt;. In this example, you&amp;rsquo;ll deploy a pretty simple one, like nginx. You can supply a name for your app like you&amp;rsquo;re going to do here (my app) or you can use the &lt;code&gt;--generate-name&lt;/code&gt; CLI option to have Helm generate one for you.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;l&#34;&gt;$ helm install my-app bitnami/nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;NAME&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-app&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;LAST DEPLOYED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Mon Mar 9 07:37:28 2020&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;NAMESPACE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;STATUS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;deployed&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;REVISION&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;TEST SUITE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;NOTES&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;Get the NGINX URL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;NOTE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;It may take a few minutes for the LoadBalancer IP to be available.&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;Watch the status with&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;kubectl get svc --namespace default -w my-app-nginx&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;export SERVICE_IP=$(kubectl get svc --namespace default my-app-nginx --template &amp;#34;{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}&amp;#34;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;echo &amp;#34;NGINX URL: http://$SERVICE_IP/&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After your release is successfully created, you&amp;rsquo;ll see an output like this with the name, namespace, status, etc. The &lt;code&gt;NOTES&lt;/code&gt; section has specific information about your install; that&amp;rsquo;s because it&amp;rsquo;s generated by Helm using a template, too.&lt;/p&gt;
&lt;p&gt;You can see what was deployed by using &lt;code&gt;kubectl&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl get all
NAME                                READY   STATUS    RESTARTS   AGE
pod/my-app-nginx-655b5cfc8c-mfhcb   1/1     Running   0          2m38s

NAME                   TYPE           CLUSTER-IP   EXTERNAL-IP     PORT(S)                      AGE
service/my-app-nginx   LoadBalancer   10.0.2.51    104.197.x.x   80:30291/TCP,443:31827/TCP   2m38s

NAME                           READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/my-app-nginx   1/1     1            1           2m38s

NAME                                      DESIRED   CURRENT   READY   AGE
replicaset.apps/my-app-nginx-655b5cfc8c   1         1         1       2m38s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can see the external IP of your application listed, but if you follow the instructions in the notes, you should see the same as well.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ export SERVICE_IP=$(kubectl get svc --namespace default my-app-nginx --template &amp;quot;{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}&amp;quot;)

$ echo &amp;quot;NGINX URL: http://$SERVICE_IP/&amp;quot;
NGINX URL: http://104.197.x.x/

$ curl $SERVICE_IP
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Welcome to nginx!&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can see which releases are deployed using &lt;code&gt;helm list&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NAME  	NAMESPACE	REVISION	UPDATED                            	STATUS  	CHART      	APP VERSION
my-app	default     	1       	2020-03-09 08:07:53.54657 -0400 EDT	deployed	nginx-5.1.9	1.16.1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It shows all the relevant information. Anytime you update a release, the revision number will increment.&lt;/p&gt;
&lt;p&gt;You can clean up by removing the app with uninstall.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ helm uninstall my-app
release &amp;quot;my-app&amp;quot; uninstalled
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;changing-the-values&#34;&gt;Changing the Values&lt;/h2&gt;
&lt;p&gt;Now you have a working nginx app, but maybe you don&amp;rsquo;t want it exposed externally via a load balancer. You can delete this app and redeploy it with &lt;code&gt;ClusterIP&lt;/code&gt; instead of &lt;code&gt;LoadBalancer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Helm charts have a set of default values; the ones for this chart can be seen in &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/nginx&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;its GitHub repository&lt;/a&gt;. If you look there, you&amp;rsquo;ll see the value you want to change is &lt;code&gt;service.type&lt;/code&gt;. You can now install that same chart using the &lt;code&gt;--set&lt;/code&gt; flag to configure it.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ helm install my-app bitnami/nginx --set service.type=ClusterIP
NAME: my-app
LAST DEPLOYED: Mon Mar 9 08:07:53 2020
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
Get the NGINX URL:

  echo &amp;quot;NGINX URL: http://127.0.0.1:8080/&amp;quot;
  kubectl port-forward --namespace blog svc/my-app-nginx 8080:80
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Notice how the &lt;code&gt;NOTES&lt;/code&gt; section changed? It&amp;rsquo;s a template, too. You can see &lt;a href=&#34;https://github.com/bitnami/charts/blob/master/bitnami/nginx/templates/NOTES.txt#L25&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;here&lt;/a&gt; that changing the service type changed the output.&lt;/p&gt;
&lt;p&gt;In this instance you supplied the value via the CLI, but you could have also put it into a &lt;code&gt;values.yaml&lt;/code&gt; file and used the &lt;code&gt;--values&lt;/code&gt; CLI option. This is a common practice for when you want to supply numerous values to the chart, and/or you want to keep track of what you&amp;rsquo;re deploying by checking the file into a version control system. The easiest way to get started with your values file is to download the default one from the chart repository, &lt;a href=&#34;https://github.com/bitnami/charts/blob/master/bitnami/nginx/values.yaml&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;like this one&lt;/a&gt; for the nginx chart you deployed. Any value you aren&amp;rsquo;t changing can be deleted from the file as it will be supplied by the default values.
If you wanted to do that to get the same results as above you&amp;rsquo;d create a &lt;code&gt;my-app-values.yaml&lt;/code&gt; file with these contents:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;## NGINX Service properties&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;##&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;## Service type&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;##&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ClusterIP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The command to create the release would then be:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ helm install my-app bitnami/nginx --values my-app-values.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;upgrading-a-release&#34;&gt;Upgrading a Release&lt;/h2&gt;
&lt;p&gt;Anytime you want to change anything about a releaseâ€”be it a configuration value for the chart, an upgrade to the chart itself, or the application versionâ€”you&amp;rsquo;ll run &lt;code&gt;helm upgrade&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For your nginx chart, you can try this by changing a configuration value. Currently the default image &lt;code&gt;pullPolicy&lt;/code&gt; for this chart is &lt;code&gt;IfNotPresent&lt;/code&gt;. You can change that to &lt;code&gt;Always&lt;/code&gt; via an upgrade.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;l&#34;&gt;$ helm upgrade my-app bitnami/nginx --set service.type=ClusterIP,image.pullPolicy=Always&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Release &amp;#34;my-app&amp;#34; has been upgraded. Happy Helming!&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;NAME&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-app&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;LAST DEPLOYED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Wed Mar 11 13:50:05 2020&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;NAMESPACE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;blog&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;STATUS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;deployed&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;REVISION&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;TEST SUITE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;NOTES&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;Get the NGINX URL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;echo &amp;#34;NGINX URL: http://127.0.0.1:8080/&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubectl port-forward --namespace blog svc/my-app-nginx 8080:80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can see the revision has been incremented. If you get the nginx pod you can see the change of configuration:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;l&#34;&gt;$ kubectl get pod my-app-nginx-5bd7878597-pc8jp -o yaml&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker.io/bitnami/nginx:1.16.1-debian-10-r46&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;imagePullPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Always&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Why did you have to supply both &lt;code&gt;service.type&lt;/code&gt; and &lt;code&gt;image.pullPolicy&lt;/code&gt;? Because if you hadn&amp;rsquo;t supplied both, the service type would have tried to revert to the default.&lt;/p&gt;
&lt;h2 id=&#34;rollback&#34;&gt;Rollback&lt;/h2&gt;
&lt;p&gt;What happens if you didn&amp;rsquo;t want that change or it didn&amp;rsquo;t work the way you expected? Remember the revision of the releases? You can rollback to a previous revision with &lt;code&gt;helm rollback&lt;/code&gt;. If you want, you can do a &lt;code&gt;--dry-run&lt;/code&gt; first to see if the rollback would even work.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ helm rollback my-app 1 --dry-run
Rollback was a success! Happy Helming!
$ helm rollback my-app 1
Rollback was a success! Happy Helming!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you check the pod again, you&amp;rsquo;ll see &lt;code&gt;pullPolicy&lt;/code&gt; is set back to &lt;code&gt;IfNotPreset&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;get-helming&#34;&gt;Get Helming&lt;/h2&gt;
&lt;p&gt;If you&amp;rsquo;re ready to start trying to deploy more charts, there are a whole bunch of charts available in a number of different repositories. A current list of repositories in a Helm install might look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NAME    	URL
stable  	https://kubernetes-charts.storage.googleapis.com
jetstack	https://charts.jetstack.io
elastic 	https://helm.elastic.co
bitnami 	https://charts.bitnami.com/bitnami
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Happy Helming!&lt;/p&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Deploy Locally a Spring Boot Application Using Bitnami Containers</title>
      
      <link>/guides/containers/deploy-locally-spring-boot-application-docker/</link>
      <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/guides/containers/deploy-locally-spring-boot-application-docker/</guid>
      <description>

        
        &lt;p&gt;&lt;a href=&#34;https://bitnami.com/stacks/containers&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami containers&lt;/a&gt; provide you with a ready-to-go environment for the development framework of your choice backed by Bitnami. By selecting a Bitnami container for local development, you can save a lot of time in coding as well as you benefit from having always the latest and more secure application image.&lt;/p&gt;
&lt;p&gt;You can use Bitnami container images for directly deploying applications or as a base for creating your own customized images. The Bitnami Tomcat container image includes all dependencies and libraries you need to deploy an application. That way, you can get productive immediately and focus only on what you love: coding.&lt;/p&gt;
&lt;p&gt;In this tutorial, you will learn how to use a &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-tomcat&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Tomcat container image&lt;/a&gt; as a framework for deploying locally a sample &lt;a href=&#34;https://spring.io/projects/spring-boot&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Spring Boot application&lt;/a&gt; that uses the &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-mariadb&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami MariaDB container image&lt;/a&gt; as a database.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and Prerequisites&lt;/h2&gt;
&lt;p&gt;This guide makes the following assumptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have basic knowledge of &lt;a href=&#34;https://www.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker&lt;/a&gt; containers.&lt;/li&gt;
&lt;li&gt;You have a Docker environment installed and configured. &lt;a href=&#34;https://docs.docker.com/install/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about installing Docker&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a Docker Hub account. &lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Register for a free account&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have Apache Maven already installed. &lt;a href=&#34;https://maven.apache.org/install.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Refer to the official Apache Maven Project documentation&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have Curl already installed. &lt;a href=&#34;https://curl.haxx.se/dlwiz/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Download and install the latest version of Curl for your operating system&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following are the steps you will complete in this guide:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Step 1: Obtain the application source code&lt;/li&gt;
&lt;li&gt;Step 2: Create a Dockerfile&lt;/li&gt;
&lt;li&gt;Step 3: Build the Docker image&lt;/li&gt;
&lt;li&gt;Step 4: Create a &lt;em&gt;docker-compose.yml&lt;/em&gt; file to configure application services&lt;/li&gt;
&lt;li&gt;Step 5: Test the Docker image and your custom application&lt;/li&gt;
&lt;li&gt;Step 6: Publish the Docker image&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-1-obtain-the-application-source-code&#34;&gt;Step 1: Obtain the application source code&lt;/h2&gt;
&lt;p&gt;To begin the process, ensure that you have access to the application source code. This tutorial uses a sample &lt;a href=&#34;https://github.com/spring-guides/gs-accessing-data-mysql&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Spring Boot application&lt;/a&gt; which has been modified to replace its database with the Bitnami MariaDB container image and to be packaged as a WAR file. To get the resulting package:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Clone the sample repository as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;git clone https://github.com/bitnami/tutorials.git
cd tutorials/spring-boot-app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will clone the sample repository. The &lt;em&gt;gs-mysql-data-0.1.0.war&lt;/em&gt; file is located in the &lt;em&gt;spring-boot-app&lt;/em&gt; subdirectory.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Learn more about the changes done in the application source code by checking check the &lt;a href=&#34;https://github.com/bitnami/tutorials/tree/master/spring-boot-app/README.md&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;repository README file&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-2-create-a-dockerfile&#34;&gt;Step 2: Create a Dockerfile&lt;/h2&gt;
&lt;p&gt;A &lt;a href=&#34;https://docs.docker.com/engine/reference/builder/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;em&gt;Dockerfile&lt;/em&gt;&lt;/a&gt; is similar to a recipe: it contains all the ingredients needed to create a Docker image. Each line of the file represents a separate step and contains the instructions for the container to build the application.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;Dockerfile&lt;/em&gt; in the sample &lt;em&gt;spring-boot-app&lt;/em&gt; repository to build your application with the Bitnami Tomcat container image providing the Tomcat infrastructure for the resulting application image. It should include the following content:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;FROM bitnami/tomcat:9.0
COPY gs-mysql-data-0.1.0.war /opt/bitnami/tomcat/webapps_default/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This &lt;em&gt;Dockerfile&lt;/em&gt; consists of one stage with two instructions for using the infrastructure &lt;em&gt;bitnami/tomcat:9.0&lt;/em&gt; image and to copy the application source at build time:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The FROM instruction kicks off the Dockerfile and specifies the base image to use. In this case, &lt;em&gt;bitnami/tomcat:9.0&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The COPY instruction copies the source code from the current directory on the host to the &lt;em&gt;/webapps_default&lt;/em&gt; directory in the image. Any WAR file copied into that directory will be automatically deployed by Tomcat at bootup time.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-3-build-the-docker-image&#34;&gt;Step 3: Build the Docker image&lt;/h2&gt;
&lt;p&gt;Once the &lt;em&gt;Dockerfile&lt;/em&gt; is created, it is time to build the docker image only by executing the &lt;em&gt;docker build&lt;/em&gt; command. Execute the command below in the same directory where the &lt;em&gt;Dockerfile&lt;/em&gt; is located, in this case, in the &lt;em&gt;spring-boot-app&lt;/em&gt; directory of the cloned repository. Remember to replace the DOCKER_USERNAME placeholder with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker build -t DOCKER_USERNAME/spring-java-app .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will create an image named &lt;em&gt;spring-java-app&lt;/em&gt;. Here is an example of the output you should see during the build process:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-locally-spring-boot-application-docker/spring-java-app.png&#34; alt=&#34;Build the Docker image&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Once the build process is complete, use the &lt;em&gt;docker image&lt;/em&gt; command to verify that the image has been added to your local repository.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker image ls DOCKER_USERNAME/spring-java-app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;step-4-create-a-docker-composeyml-file-to-configure-application-services&#34;&gt;Step 4: Create a &lt;em&gt;docker-compose.yml&lt;/em&gt; file to configure application services&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/compose/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Compose&lt;/a&gt; is a tool for defining and running applications with multiple containers in Docker. The &lt;em&gt;docker-compose.yml&lt;/em&gt; file is used to define the configuration of your application&amp;rsquo;s services. It includes the specification of the application&amp;rsquo;s service dependencies such as databases, queues, caches, etc. After defining them in the &lt;em&gt;docker-compose.yml&lt;/em&gt; file you are able to create and start one or more containers with a single command: &lt;em&gt;docker-compose up&lt;/em&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create a &lt;em&gt;docker-compose.yml&lt;/em&gt; file that contains the following content. Remember to replace the DOCKER_USERNAME placeholder with your Docker account username:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;version: &amp;#39;2&amp;#39;

services:
  mariadb:
    image: &amp;#39;bitnami/mariadb:10.3&amp;#39;
    environment:
      - ALLOW_EMPTY_PASSWORD=yes
      - MARIADB_DATABASE=db_example
      - MARIADB_USER=springuser
      - MARIADB_PASSWORD=ThePassword
    myapp:
    image: &amp;#39;DOCKER_USERNAME/spring-java-app&amp;#39;
    environment:
      - &amp;#39;SPRING_APPLICATION_JSON={&amp;#34;spring&amp;#34;: {&amp;#34;datasource&amp;#34;:{&amp;#34;url&amp;#34;: &amp;#34;jdbc:mysql://mariadb:3306/db_example&amp;#34;, &amp;#34;username&amp;#34;: &amp;#34;springuser&amp;#34;, &amp;#34;password&amp;#34;: &amp;#34;ThePassword&amp;#34;}}}&amp;#39;
    depends_on:
      - mariadb
    ports:
     - &amp;#39;8080:8080&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;The application environment variable set in this file allows you to use any MySQL database with any credentials at deployment time. This, makes your image secure for production environments.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;The ALLOW_EMPTY_PASSWORD parameter is set as &amp;ldquo;yes&amp;rdquo; in this &lt;em&gt;docker-compose.yml&lt;/em&gt; file since the application is built for development purposes. That value is highly discouraged for production. Remember to secure your deployments by setting a password in production environments.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;step-5-test-the-docker-image-and-your-custom-application&#34;&gt;Step 5: Test the Docker image and your custom application&lt;/h2&gt;
&lt;p&gt;Run your new Docker image in a container to test it with the &lt;em&gt;docker-compose up&lt;/em&gt; command.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker-compose up
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will create all the containers and volumes both for your application and the database. Now, it is time to test if the application works fine by calling the API endpoint using &lt;em&gt;Curl&lt;/em&gt;. Follow these instructions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Open a new terminal in your local system and execute the following command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;curl &amp;#39;localhost:8080/gs-mysql-data-0.1.0/demo/all&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The output should be an empty array &amp;ldquo;[]&amp;rdquo; that means that there is no data present in the database.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Let&amp;rsquo;s insert some data in the database by executing:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;curl &amp;#39;localhost:8080/gs-mysql-data-0.1.0/demo/add?name=First&amp;amp;email=someemail@someemailprovider.com&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Query the application again to check if the data is present in the database:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;curl &amp;#39;localhost:8080/gs-mysql-data-0.1.0/demo/all&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now, you should get an output similar to this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;[{&amp;#34;id&amp;#34;:1, &amp;#34;name&amp;#34;:&amp;#34;First&amp;#34;, &amp;#34;email&amp;#34;:&amp;#34;someemail@someemailprovider.com&amp;#34;}]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Congratulations! You have your Spring Boot application running locally and ready to use!&lt;/p&gt;
&lt;h2 id=&#34;step-6-publish-the-docker-image&#34;&gt;Step 6: Publish the Docker image&lt;/h2&gt;
&lt;p&gt;Now that your Docker image is built and contains your application code, you can upload it into a public registry. This tutorial uses &lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker Hub&lt;/a&gt;, but you can select one of your own choice such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/container-registry/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Google Container Registry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/ecr/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Amazon EC2 Container Registry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://azure.microsoft.com/en-us/services/container-registry/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Azure container Registry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://quay.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Quay&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To upload the image to Docker Hub, follow the steps below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Log in to Docker Hub:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker login
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Push the image to your Docker Hub account. Replace the DOCKER_USERNAME placeholder with the username of your Docker Hub account and &lt;em&gt;my-custom-app:latest&lt;/em&gt; with the name and the version of your Docker image:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker push DOCKER_USERNAME/my-custom-app:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Confirm that you see the image in your Docker Hub repositories dashboard.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://spring.io/projects/spring-boot&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Spring Boot official site&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/tutorials&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami tutorials repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-tomcat&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Tomcat container image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker Hub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bitnami.com/containers&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami containers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/tutorials/deploy-java-application-kubernetes-helm&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Deploy a Java application on Kubernetes with Helm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Creating Your First Helm Chart</title>
      
      <link>/guides/kubernetes/create-helm-chart/</link>
      <pubDate>Fri, 05 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/guides/kubernetes/create-helm-chart/</guid>
      <description>

        
        &lt;p&gt;So, you&amp;rsquo;ve got your &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubernetes cluster up and running&lt;/a&gt; and &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes/#step-4-install-helm&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;set up Helm v3.x&lt;/a&gt;, but how do you run your applications on it? This guide walks you through the process of creating your first ever chart, explaining what goes inside these packages and the tools you use to develop them. By the end of it you should have an understanding of the advantages of using Helm to deliver your own applications to your cluster.&lt;/p&gt;
&lt;p&gt;For a typical cloud-native application with a 3-tier architecture, the diagram below illustrates how it might be described in terms of &lt;a href=&#34;http://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubernetes objects&lt;/a&gt;. In this example, each tier consists of a &lt;a href=&#34;http://kubernetes.io/docs/user-guide/deployments/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Deployment&lt;/a&gt; and &lt;a href=&#34;http://kubernetes.io/docs/user-guide/services/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Service&lt;/a&gt; object, and may additionally define &lt;a href=&#34;http://kubernetes.io/docs/user-guide/configmap/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;ConfigMap&lt;/a&gt; or &lt;a href=&#34;http://kubernetes.io/docs/user-guide/secrets/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Secret&lt;/a&gt; objects. Each of these objects are typically defined in separate YAML files, and are fed into the &lt;em&gt;kubectl&lt;/em&gt; command line tool.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/create-helm-chart/diagrams/three-tier-kubernetes-architecture.png&#34; alt=&#34;3-tier application architecture on Kubernetes&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;A Helm chart encapsulates each of these YAML definitions, provides a mechanism for configuration at deploy-time and allows you to define metadata and documentation that might be useful when sharing the package. Helm can be useful in different scenarios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Find and use popular software packaged as Kubernetes charts&lt;/li&gt;
&lt;li&gt;Share your own applications as Kubernetes charts&lt;/li&gt;
&lt;li&gt;Create reproducible builds of your Kubernetes applications&lt;/li&gt;
&lt;li&gt;Intelligently manage your Kubernetes object definitions&lt;/li&gt;
&lt;li&gt;Manage releases of Helm packages&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&amp;rsquo;s explore the second and third scenarios by creating our first chart.&lt;/p&gt;
&lt;h2 id=&#34;step-1-generate-your-first-chart&#34;&gt;Step 1: Generate your first chart&lt;/h2&gt;
&lt;p&gt;The best way to get started with a new chart is to use the &lt;em&gt;helm create&lt;/em&gt; command to scaffold out an example we can build on. Use this command to create a new chart named &lt;em&gt;mychart&lt;/em&gt; in a new directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm create mychart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Helm will create a new directory in your project called &lt;em&gt;mychart&lt;/em&gt; with the structure shown below. Let&amp;rsquo;s navigate our new chart (pun intended) to find out how it works.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mychart
|-- Chart.yaml
|-- charts
|-- templates
|   |-- NOTES.txt
|   |-- _helpers.tpl
|   |-- deployment.yaml
|   |-- ingress.yaml
|   `-- service.yaml
`-- values.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;templates&#34;&gt;Templates&lt;/h3&gt;
&lt;p&gt;The most important piece of the puzzle is the &lt;em&gt;templates/&lt;/em&gt; directory. This is where Helm finds the YAML definitions for your Services, Deployments and other Kubernetes objects. If you already have definitions for your application, all you need to do is replace the generated YAML files for your own. What you end up with is a working chart that can be deployed using the &lt;em&gt;helm install&lt;/em&gt; command.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s worth noting however, that the directory is named &lt;em&gt;templates&lt;/em&gt;, and Helm runs each file in this directory through a &lt;a href=&#34;https://golang.org/pkg/text/template/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Go template&lt;/a&gt; rendering engine. Helm extends the template language, adding a number of utility functions for writing charts. Open the &lt;em&gt;service.yaml&lt;/em&gt; file to see what this looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
name: {{ template &amp;quot;fullname&amp;quot; . }}
labels:
    chart: &amp;quot;{{ .Chart.Name }}-{{ .Chart.Version | replace &amp;quot;+&amp;quot; &amp;quot;_&amp;quot; }}&amp;quot;
spec:
type: {{ .Values.service.type }}
ports:
- port: {{ .Values.service.externalPort }}
    targetPort: {{ .Values.service.internalPort }}
    protocol: TCP
    name: {{ .Values.service.name }}
selector:
    app: {{ template &amp;quot;fullname&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a basic Service definition using templating. When deploying the chart, Helm will generate a definition that will look a lot more like a valid Service. We can do a dry-run of a &lt;em&gt;helm install&lt;/em&gt; and enable debug to inspect the generated definitions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm install --dry-run --debug ./mychart
...
# Source: mychart/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
name: pouring-puma-mychart
labels:
    chart: &amp;quot;mychart-0.1.0&amp;quot;
spec:
type: ClusterIP
ports:
- port: 80
    targetPort: 80
    protocol: TCP
    name: nginx
selector:
    app: pouring-puma-mychart
...
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;values&#34;&gt;Values&lt;/h4&gt;
&lt;p&gt;The template in &lt;em&gt;service.yaml&lt;/em&gt; makes use of the Helm-specific objects &lt;em&gt;.Chart&lt;/em&gt; and &lt;em&gt;.Values.&lt;/em&gt;. The former provides metadata about the chart to your definitions such as the name, or version. The latter &lt;em&gt;.Values&lt;/em&gt; object is a key element of Helm charts, used to expose configuration that can be set at the time of deployment. The defaults for this object are defined in the &lt;em&gt;values.yaml&lt;/em&gt; file. Try changing the default value for &lt;em&gt;service.internalPort&lt;/em&gt; and execute another dry-run, you should find that the &lt;em&gt;targetPort&lt;/em&gt; in the Service and the &lt;em&gt;containerPort&lt;/em&gt; in the Deployment changes. The &lt;em&gt;service.internalPort&lt;/em&gt; value is used here to ensure that the Service and Deployment objects work together correctly. The use of templating can greatly reduce boilerplate and simplify your definitions.&lt;/p&gt;
&lt;p&gt;If a user of your chart wanted to change the default configuration, they could provide overrides directly on the command-line:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install --dry-run --debug ./mychart --set service.internalPort&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For more advanced configuration, a user can specify a YAML file containing overrides with the &lt;em&gt;--values&lt;/em&gt; option.&lt;/p&gt;
&lt;h4 id=&#34;helpers-and-other-functions&#34;&gt;Helpers and other functions&lt;/h4&gt;
&lt;p&gt;The &lt;em&gt;service.yaml&lt;/em&gt; template also makes use of partials defined in &lt;em&gt;_helpers.tpl&lt;/em&gt;, as well as functions like &lt;em&gt;replace&lt;/em&gt;. The &lt;a href=&#34;https://helm.sh/docs/chart_template_guide/getting_started/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm documentation&lt;/a&gt; has a deeper walkthrough of the templating language, explaining how functions, partials and flow control can be used when developing your chart.&lt;/p&gt;
&lt;h3 id=&#34;documentation&#34;&gt;Documentation&lt;/h3&gt;
&lt;p&gt;Another useful file in the &lt;em&gt;templates/&lt;/em&gt; directory is the &lt;em&gt;NOTES.txt&lt;/em&gt; file. This is a templated, plaintext file that gets printed out after the chart is successfully deployed. As we&amp;rsquo;ll see when we deploy our first chart, this is a useful place to briefly describe the next steps for using a chart. Since &lt;em&gt;NOTES.txt&lt;/em&gt; is run through the template engine, you can use templating to print out working commands for obtaining an IP address, or getting a password from a Secret object.&lt;/p&gt;
&lt;h3 id=&#34;metadata&#34;&gt;Metadata&lt;/h3&gt;
&lt;p&gt;As mentioned earlier, a Helm chart consists of metadata that is used to help describe what the application is, define constraints on the minimum required Kubernetes and/or Helm version and manage the version of your chart. All of this metadata lives in the &lt;em&gt;Chart.yaml&lt;/em&gt; file. The &lt;a href=&#34;https://helm.sh/docs/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm documentation&lt;/a&gt; describes the different fields for this file.&lt;/p&gt;
&lt;h2 id=&#34;step-2-deploy-your-first-chart&#34;&gt;Step 2: Deploy your first chart&lt;/h2&gt;
&lt;p&gt;The chart you generated in the previous step is set up to run an NGINX server exposed via a Kubernetes Service. By default, the chart will create a &lt;em&gt;ClusterIP&lt;/em&gt; type Service, so NGINX will only be exposed internally in the cluster. To access it externally, we&amp;rsquo;ll use the &lt;em&gt;NodePort&lt;/em&gt; type instead. We can also set the name of the Helm release so we can easily refer back to it. Let&amp;rsquo;s go ahead and deploy our NGINX chart using the &lt;em&gt;helm install&lt;/em&gt; command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install example ./mychart --set service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;NodePort
NAME:   example
LAST DEPLOYED: Tue May  &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; 20:03:27 &lt;span class=&#34;m&#34;&gt;2017&lt;/span&gt;
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; v1/Service
NAME             CLUSTER-IP  EXTERNAL-IP  PORT&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;       AGE
example-mychart  10.0.0.24   &amp;lt;nodes&amp;gt;      80:30630/TCP  &lt;span class=&#34;nv&#34;&gt;0s&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; v1beta1/Deployment
NAME             DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE
example-mychart  &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;           &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          0s

NOTES:
1. Get the application URL by running these commands:
&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_PORT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl get --namespace default -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.spec.ports[0].nodePort}&amp;#34;&lt;/span&gt; services example-mychart&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_IP&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl get nodes --namespace default -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.items[0].status.addresses[0].address}&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; http://&lt;span class=&#34;nv&#34;&gt;$NODE_IP&lt;/span&gt;:&lt;span class=&#34;nv&#34;&gt;$NODE_PORT&lt;/span&gt;/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The output of &lt;em&gt;helm install&lt;/em&gt; displays a handy summary of the state of the release, what objects were created, and the rendered &lt;em&gt;NOTES.txt&lt;/em&gt; file to explain what to do next. Run the commands in the output to get a URL to access the NGINX service and pull it up in your browser.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/create-helm-chart/nginx-server.png&#34; alt=&#34;nginx server default page&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;If all went well, you should see the NGINX welcome page as shown above. Congratulations! You&amp;rsquo;ve just deployed your very first service packaged as a Helm chart!&lt;/p&gt;
&lt;h2 id=&#34;step-3-modify-chart-to-deploy-a-custom-service&#34;&gt;Step 3: Modify chart to deploy a custom service&lt;/h2&gt;
&lt;p&gt;The generated chart creates a Deployment object designed to run an image provided by the default values. This means all we need to do to run a different service is to change the referenced image in &lt;em&gt;values.yaml&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We are going to update the chart to run a &lt;a href=&#34;https://github.com/prydonius/todomvc/tree/master/examples/react&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;todo list application&lt;/a&gt; available on &lt;a href=&#34;https://hub.docker.com/r/prydonius/todo/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker Hub&lt;/a&gt;. In &lt;em&gt;values.yaml&lt;/em&gt;, update the image keys to reference the todo list image:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;image:
repository: prydonius/todo
tag: 1.0.0
pullPolicy: IfNotPresent
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you develop your chart, it&amp;rsquo;s a good idea to run it through the linter to ensure you&amp;rsquo;re following best practices and that your templates are well-formed. Run the &lt;em&gt;helm lint&lt;/em&gt; command to see the linter in action:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm lint ./mychart
&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; Linting ./mychart
&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;INFO&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Chart.yaml: icon is recommended

&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; chart&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;s&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; linted, no failures
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The linter didn&amp;rsquo;t complain about any major issues with the chart, so we&amp;rsquo;re good to go. However, as an example, here is what the linter might output if you managed to get something wrong:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;malformed&amp;#34;&lt;/span&gt; &amp;gt; mychart/values.yaml
helm lint ./mychart
&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; Linting mychart
&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;INFO&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Chart.yaml: icon is recommended
&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;ERROR&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; values.yaml: unable to parse YAML
    error converting YAML to JSON: yaml: line 34: could not find expected &lt;span class=&#34;s1&#34;&gt;&amp;#39;:&amp;#39;&lt;/span&gt;

Error: &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; chart&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;s&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; linted, &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; chart&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;s&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; failed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This time, the linter tells us that it was unable to parse my &lt;em&gt;values.yaml&lt;/em&gt; file correctly. With the line number hint, we can easily find the fix the bug we introduced.&lt;/p&gt;
&lt;p&gt;Now that the chart is once again valid, run &lt;em&gt;helm install&lt;/em&gt; again to deploy the todo list application:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install example2 ./mychart --set service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;NodePort
NAME:   example2
LAST DEPLOYED: Wed May  &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; 12:10:03 &lt;span class=&#34;m&#34;&gt;2017&lt;/span&gt;
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; v1/Service
NAME              CLUSTER-IP  EXTERNAL-IP  PORT&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;       AGE
example2-mychart  10.0.0.78   &amp;lt;nodes&amp;gt;      80:31381/TCP  &lt;span class=&#34;nv&#34;&gt;0s&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; apps/v1/Deployment
NAME              DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE
example2-mychart  &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;           &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          0s


NOTES:
1. Get the application URL by running these commands:
&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_PORT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl get --namespace default -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.spec.ports[0].nodePort}&amp;#34;&lt;/span&gt; services example2-mychart&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_IP&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl get nodes --namespace default -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.items[0].status.addresses[0].address}&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; http://&lt;span class=&#34;nv&#34;&gt;$NODE_IP&lt;/span&gt;:&lt;span class=&#34;nv&#34;&gt;$NODE_PORT&lt;/span&gt;/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Once again, we can run the commands in the NOTES to get a URL to access our application.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/create-helm-chart/todo-list-app.png&#34; alt=&#34;Todo List Application&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;If you have already built containers for your applications, you can run them with your chart by updating the default values or the &lt;em&gt;Deployment&lt;/em&gt; template. Check out the Bitnami Docs for an &lt;a href=&#34;https://docs.bitnami.com/tutorials/deploy-custom-nodejs-app-bitnami-containers/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;introduction to containerizing your applications&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;step-4-package-it-all-up-to-share&#34;&gt;Step 4: Package it all up to share&lt;/h2&gt;
&lt;p&gt;So far in this tutorial, we&amp;rsquo;ve been using the &lt;em&gt;helm install&lt;/em&gt; command to install a local, unpacked chart. However, if you are looking to share your charts with your team or the community, your consumers will typically install the charts from a tar package. We can use &lt;em&gt;helm package&lt;/em&gt; to create the tar package:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm package ./mychart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Helm will create a &lt;em&gt;mychart-0.1.0.tgz&lt;/em&gt; package in our working directory, using the name and version from the metadata defined in the &lt;em&gt;Chart.yaml&lt;/em&gt; file. A user can install from this package instead of a local directory by passing the package as the parameter to &lt;em&gt;helm install&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install example3 mychart-0.1.0.tgz --set service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;NodePort
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;repositories&#34;&gt;Repositories&lt;/h3&gt;
&lt;p&gt;In order to make it much easier to share packages, Helm has built-in support for installing packages from an HTTP server. Helm reads a repository index hosted on the server which describes what chart packages are available and where they are located.&lt;/p&gt;
&lt;p&gt;We can use the &lt;em&gt;helm serve&lt;/em&gt; command to run a local repository to serve our chart.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm serve
Regenerating index. This may take a moment.
Now serving you on 127.0.0.1:8879
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now, in a separate terminal window, you should be able to see your chart in the local repository and install it from there:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm search &lt;span class=&#34;nb&#34;&gt;local&lt;/span&gt;
NAME         	VERSION	DESCRIPTION
local/mychart	0.1.0  	A Helm chart &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; Kubernetes

helm install example4 local/mychart --set service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;NodePort
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To set up a remote repository you can follow the guide in the &lt;a href=&#34;https://github.com/kubernetes/helm/blob/master/docs/chart_repository.md&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm documentation&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h2&gt;
&lt;p&gt;As the applications your packaging as charts increase in complexity, you might find you need to pull in a dependency such as a database. Helm allows you to specify sub-charts that will be created as part of the same release. To define a dependency, create a &lt;em&gt;requirements.yaml&lt;/em&gt; file in the chart root directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;cat &amp;gt; ./mychart/requirements.yaml &lt;span class=&#34;s&#34;&gt;&amp;lt;&amp;lt;EOF
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;dependencies:
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;- name: mariadb
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;version: 0.6.0
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;repository: https://charts.helm.sh/stable
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;EOF&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Much like a runtime language dependency file (such as Python&amp;rsquo;s &lt;em&gt;requirements.txt&lt;/em&gt;), the &lt;em&gt;requirements.yaml&lt;/em&gt; file allows you to manage your chart&amp;rsquo;s dependencies and their versions. When updating dependencies, a lockfile is generated so that subsequent fetching of dependencies use a known, working version. Run the following command to pull in the MariaDB dependency we defined:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm dep update ./mychart
Hang tight &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; we grab the latest from your chart repositories...
...Unable to get an update from the &lt;span class=&#34;s2&#34;&gt;&amp;#34;local&amp;#34;&lt;/span&gt; chart repository &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;http://127.0.0.1:8879/charts&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;:
    Get http://127.0.0.1:8879/charts/index.yaml: dial tcp 127.0.0.1:8879: getsockopt: connection refused
...Successfully got an update from the &lt;span class=&#34;s2&#34;&gt;&amp;#34;bitnami&amp;#34;&lt;/span&gt; chart repository
...Successfully got an update from the &lt;span class=&#34;s2&#34;&gt;&amp;#34;incubator&amp;#34;&lt;/span&gt; chart repository
Update Complete. *Happy Helming!*
Saving &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; charts
Downloading mariadb from repo
$ ls ./mychart/charts
mariadb-0.6.0.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Helm has found a matching version in the &lt;em&gt;bitnami&lt;/em&gt; repository and has fetched it into my chart&amp;rsquo;s sub-chart directory. Now when we go and install the chart, we&amp;rsquo;ll see that MariaDB&amp;rsquo;s objects are created too:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install example5 ./mychart --set service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;NodePort
NAME:   example5
LAST DEPLOYED: Wed May  &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; 16:28:18 &lt;span class=&#34;m&#34;&gt;2017&lt;/span&gt;
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; v1/Secret
NAME              TYPE    DATA  AGE
example5-mariadb  Opaque  &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;     &lt;span class=&#34;nv&#34;&gt;1s&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; v1/ConfigMap
NAME              DATA  AGE
example5-mariadb  &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;     &lt;span class=&#34;nv&#34;&gt;1s&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; v1/PersistentVolumeClaim
NAME              STATUS  VOLUME                                    CAPACITY  ACCESSMODES  AGE
example5-mariadb  Bound   pvc-229f9ed6-3015-11e7-945a-66fc987ccf32  8Gi       RWO          &lt;span class=&#34;nv&#34;&gt;1s&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; v1/Service
NAME              CLUSTER-IP  EXTERNAL-IP  PORT&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;       AGE
example5-mychart  10.0.0.144  &amp;lt;nodes&amp;gt;      80:30896/TCP  1s
example5-mariadb  10.0.0.108  &amp;lt;none&amp;gt;       3306/TCP      &lt;span class=&#34;nv&#34;&gt;1s&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; apps/v1/Deployment
NAME              DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE
example5-mariadb  &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;           &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          1s
example5-mychart  &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;           &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          1s


NOTES:
1. Get the application URL by running these commands:
&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_PORT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl get --namespace default -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.spec.ports[0].nodePort}&amp;#34;&lt;/span&gt; services example5-mychart&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_IP&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl get nodes --namespace default -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.items[0].status.addresses[0].address}&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; http://&lt;span class=&#34;nv&#34;&gt;$NODE_IP&lt;/span&gt;:&lt;span class=&#34;nv&#34;&gt;$NODE_PORT&lt;/span&gt;/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;contribute-to-the-bitnami-repository&#34;&gt;Contribute to the Bitnami repository!&lt;/h2&gt;
&lt;p&gt;As a chart author, you can help to build out Bitnami&amp;rsquo;s chart repository by improving existing charts or submitting new ones. Checkout &lt;a href=&#34;https://kubeapps.com&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;https://kubeapps.com&lt;/a&gt; to see what&amp;rsquo;s currently available and head to &lt;a href=&#34;https://github.com/bitnami/charts&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;https://github.com/bitnami/charts&lt;/a&gt; to get involved.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;p&gt;We&amp;rsquo;ve walked through some of the ways Helm supercharges the delivery of applications on Kubernetes. From an empty directory, you were able to get a working Helm chart out of a single command, deploy it to your cluster and access an NGINX server. Then, by simply changing a few lines and re-deploying, you had a much more useful todo list application running on your cluster! Beyond templating, linting, sharing and managing dependencies, here are some other useful tools available to chart authors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/helm/blob/master/docs/charts_hooks.md&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Define hooks to run &lt;em&gt;Jobs&lt;/em&gt; before or after installing and upgrading releases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/helm/blob/master/docs/provenance.md&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Sign chart packages to help users verify its integrity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/helm/blob/master/docs/chart_tests.md&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Write integration/validation tests for your charts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/helm/blob/master/docs/charts_tips_and_tricks.md&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Employ a handful of tricks in your chart templates&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: What is Helmfile?</title>
      
      <link>/guides/kubernetes/helmfile-what-is/</link>
      <pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/guides/kubernetes/helmfile-what-is/</guid>
      <description>

        
        &lt;p&gt;&lt;a href=&#34;https://github.com/roboll/helmfile&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helmfile&lt;/a&gt; adds additional functionality to &lt;a href=&#34;https://helm.sh&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm&lt;/a&gt; by wrapping it in a declarative spec that allows you to compose several charts together to create a comprehensive deployment artifact for anything from a single application to your entire infrastructure stack.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: If you&amp;rsquo;re not familiar with Helm, start with our &lt;a href=&#34;../helm-what-is&#34;&gt;Getting Started with Helm&lt;/a&gt; guide.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In addition to the Templating and Packaging Helm gives you for your Kubernetes manifests, Helmfile provides a way to apply GitOps style CI/CD methodologies over your Helm charts by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Separating out your Environment specific information from your Chart&lt;/li&gt;
&lt;li&gt;Performing a diff of your existing deployment and only applying the changes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Helmfile uses the same templating system as Helm and in a way lets you template your templates (&lt;em&gt;&lt;insert yo dawg meme here&gt;&lt;/em&gt;). This can be a bit difficult to wrap your mind around at first, but adds a ton of powerful features as it allows you to put basic programming logic like &lt;em&gt;if/then/else&lt;/em&gt; into just about any component including your actual Helm Chart Values.&lt;/p&gt;
&lt;h2 id=&#34;why-is-it-important&#34;&gt;Why Is It Important?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://helm.sh&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm&lt;/a&gt; is a great tool for templating and sharing Kubernetes manifests for your applications. However it can become quite cumbersome to install larger multi-tier applications or groups of applications across multiple Kubernetes clusters.&lt;/p&gt;
&lt;p&gt;Helmfile addresses this issue and more by providing a fairly simple but very powerful declarative specification for deploying Helm charts across many environments.&lt;/p&gt;
&lt;p&gt;First and foremost Helm is a &lt;strong&gt;declarative&lt;/strong&gt; specification. Like Kubernetes manifests you can store them in version control, and perform declarative style actions. Much like Kubernetes has &lt;code&gt;kubectl apply&lt;/code&gt; for Kubernetes manifests, Helmfile has &lt;code&gt;helmfile apply&lt;/code&gt; for Helm charts.&lt;/p&gt;
&lt;p&gt;Helmfile is very &lt;strong&gt;modular&lt;/strong&gt;, you can have one large &lt;code&gt;helmfile.yaml&lt;/code&gt; that does everything or you can break it down to suit your way of working. This modularity allows you to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Give each Helm chart its own &lt;code&gt;helmfile.yaml&lt;/code&gt; and include them recursively in a centralized &lt;code&gt;helmfile.yaml&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Separate out &lt;a href=&#34;https://github.com/roboll/helmfile/blob/master/docs/writing-helmfile.md#layering-state-files&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;environment specific&lt;/a&gt; values from general values. Often you&amp;rsquo;ll find while a Helm chart can take 50 different values, only a few actually differ between your environments.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;As well as providing a set of values, either Environment specific or otherwise, you can also read Environment Variables, Execute scripts and read their output.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Store &lt;a href=&#34;https://github.com/roboll/helmfile/pull/648&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;remote state&lt;/a&gt; in git/s3/fileshare/etc in much the same way as Terraform does.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Helmfile is &lt;strong&gt;versatile&lt;/strong&gt; enough to allow you to also include raw Kubernetes manifests, &lt;a href=&#34;https://github.com/kubernetes-sigs/kustomize&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kustomizations&lt;/a&gt;, or even execute scripts via hooks, turning all of these into &lt;a href=&#34;https://github.com/roboll/helmfile/pull/673&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm releases&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Need to modify the resources generated by a specific Helm chart? Helmfile allows you to &lt;a href=&#34;https://github.com/roboll/helmfile/pull/673&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;JSON/Strategic-Merge&lt;/a&gt; &lt;strong&gt;patch&lt;/strong&gt; resources before actually installing them.&lt;/p&gt;
&lt;h2 id=&#34;how-does-it-work&#34;&gt;How Does It Work?&lt;/h2&gt;
&lt;p&gt;Helmfile works by reading in your Helmfile manifest (usually &lt;code&gt;helmfile.yaml&lt;/code&gt;) which declares the Helm Charts you want to install and the values you wish to install them with, these are compared against the actual state of what is running in your cluster and any differences are then acted upon by calling out to Helm itself.&lt;/p&gt;
&lt;p&gt;A basic &lt;code&gt;helmfile.yaml&lt;/code&gt; to install nginx would look something like this:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;./apps/nginx/helmfile.yaml&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;repositories&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;stable&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;https://kubernetes-charts.storage.googleapis.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;releases&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-nginx-server&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;chart&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;stable/nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;~1.24.1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;values&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;./nginx/vault.yaml.gotmpl&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my.registry.com/nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Values are a list that can be passed in as a file or a list of key/values. These are the helm style values that will be rendered into your chart. Helmfile will treat any file with the &lt;code&gt;.gotmpl&lt;/code&gt; extension as a template and will render it &lt;strong&gt;before&lt;/strong&gt; passing it onto Helm.&lt;/p&gt;
&lt;p&gt;If you wanted to load the above into a parent &lt;code&gt;helmfile.yaml&lt;/code&gt; you could do the following:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;./helmfile.yaml&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;helmfiles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;apps/*/helmfile.yaml&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can even make all of your included &lt;code&gt;helmfile.yaml&lt;/code&gt; files templates and render stuff right into the helmfiles. It really is templates all the way down.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;./helmfile.yaml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helmfiles:
  - apps/*/helmfile.yaml.gotmpl
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Thankfully the Helmfile GitHub repository has some really good &lt;a href=&#34;https://github.com/roboll/helmfile#configuration&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;documentation&lt;/a&gt; and &lt;a href=&#34;https://github.com/roboll/helmfile/blob/master/docs/writing-helmfile.md&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;best practices&lt;/a&gt; showing different ways to construct your &lt;code&gt;helmfile.yaml&lt;/code&gt; files.&lt;/p&gt;
&lt;h2 id=&#34;how-can-i-use-it&#34;&gt;How Can I Use It?&lt;/h2&gt;
&lt;p&gt;It&amp;rsquo;s pretty easy to get started with Helmfile. The documentation in the repository is quite good.&lt;/p&gt;
&lt;p&gt;For an interesting perspective showing how to completely decouple your Code and Environment data have a look at Paul Czarkowski&amp;rsquo;s &lt;a href=&#34;https://github.com/paulczar/helmfile-starter-kit&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helmfile Starter Kit&lt;/a&gt; and the &lt;a href=&#34;https://github.com/paulczar/platform-operations-on-kubernetes&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Platform Operations on Kubernetes&lt;/a&gt; project built on top of it. The latter of which is used to deploy a whole kitchen sink worth of platform tooling across dozens of Kubernetes clusters.&lt;/p&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;/css/faq.css&#34;&gt;
&lt;div class=&#34;faqs&#34; id=&#34;faqs&#34;&gt;
    &lt;div class=&#34;flex-container jc-between&#34;&gt;&lt;/div&gt;
        &lt;h2 class=&#34;h2 mb-md&#34;&gt;Frequently Asked Questions&lt;/h2&gt;
        &lt;div class=&#34;faq&#34;&gt;
            
  &lt;div class=&#34;faq-item&#34; id=&#34;faq-item&#34;&gt;
    &lt;div class=&#34;flex jc-between ai-center&#34;&gt;
        &lt;h4 class=&#34;faq-question&#34;&gt;What is a Helmfile?&lt;/h4&gt;
        &lt;i class=&#34;fa fa-angle-down&#34; id=&#34;arrow&#34;&gt;&lt;/i&gt;
    &lt;/div&gt;
    &lt;div class=&#34;faq-answer&#34;&gt;
        &lt;div&gt;Helmfile is a declarative specification wrapping for deploying distributions of Helm charts. They add additional functionality to Helm by allowing you to compose several charts together to create a comprehensive deployment artifact.&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
  &lt;div class=&#34;faq-item&#34; id=&#34;faq-item&#34;&gt;
    &lt;div class=&#34;flex jc-between ai-center&#34;&gt;
        &lt;h4 class=&#34;faq-question&#34;&gt;What is a Helm chart?&lt;/h4&gt;
        &lt;i class=&#34;fa fa-angle-down&#34; id=&#34;arrow&#34;&gt;&lt;/i&gt;
    &lt;/div&gt;
    &lt;div class=&#34;faq-answer&#34;&gt;
        &lt;div&gt;Helm charts are Kubernetes manifests or a collection of files that correspond to a directly related set of Kubernetes resources.&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
  &lt;div class=&#34;faq-item&#34; id=&#34;faq-item&#34;&gt;
    &lt;div class=&#34;flex jc-between ai-center&#34;&gt;
        &lt;h4 class=&#34;faq-question&#34;&gt;How do Helmfiles work?&lt;/h4&gt;
        &lt;i class=&#34;fa fa-angle-down&#34; id=&#34;arrow&#34;&gt;&lt;/i&gt;
    &lt;/div&gt;
    &lt;div class=&#34;faq-answer&#34;&gt;
        &lt;div&gt;Helmfiles work by reading your Helmfile manifests and comparing them against the actual state of what is running in your cluster. Any differences are then acted upon by calling out to Helm itself.&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
  &lt;div class=&#34;faq-item&#34; id=&#34;faq-item&#34;&gt;
    &lt;div class=&#34;flex jc-between ai-center&#34;&gt;
        &lt;h4 class=&#34;faq-question&#34;&gt;What is the difference between Helm and Helmfile?&lt;/h4&gt;
        &lt;i class=&#34;fa fa-angle-down&#34; id=&#34;arrow&#34;&gt;&lt;/i&gt;
    &lt;/div&gt;
    &lt;div class=&#34;faq-answer&#34;&gt;
        &lt;div&gt;Helm is a tool for templating and sharing Kubernetes manifests for your applications, while a Helmfile is a declarative specification for deploying Helm charts that adds functionality to Helm.&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
  &lt;div class=&#34;faq-item&#34; id=&#34;faq-item&#34;&gt;
    &lt;div class=&#34;flex jc-between ai-center&#34;&gt;
        &lt;h4 class=&#34;faq-question&#34;&gt;How do you modify the resources generated by a specific Helm chart?&lt;/h4&gt;
        &lt;i class=&#34;fa fa-angle-down&#34; id=&#34;arrow&#34;&gt;&lt;/i&gt;
    &lt;/div&gt;
    &lt;div class=&#34;faq-answer&#34;&gt;
        &lt;div&gt;Resources generated by a specific Helm chart can be modified before installation by allowing you to JSON/Strategic-Merge patch resources.&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
  &lt;div class=&#34;faq-item&#34; id=&#34;faq-item&#34;&gt;
    &lt;div class=&#34;flex jc-between ai-center&#34;&gt;
        &lt;h4 class=&#34;faq-question&#34;&gt;What are the benefits of Helmfiles?&lt;/h4&gt;
        &lt;i class=&#34;fa fa-angle-down&#34; id=&#34;arrow&#34;&gt;&lt;/i&gt;
    &lt;/div&gt;
    &lt;div class=&#34;faq-answer&#34;&gt;
        &lt;div&gt;Helmfiles are beneficial because they provide powerful declarative specification for deploying Helm charts across many environments.&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

        &lt;/div&gt;
    &lt;/div&gt;
    
&lt;/div&gt;

&lt;script type=&#34;text/javascript&#34;&gt;
    $(&#34;.faq-item&#34;).each( function() {
        $(this).click(function () {
            $(this).find(&#34;#arrow&#34;).toggleClass(&#34;flip&#34;); 
            $(this).find(&#34;.faq-answer&#34;).slideToggle(200); 
        });
    });
&lt;/script&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Move a Custom Spring Boot Application to Production Using Bitnami Helm Charts</title>
      
      <link>/guides/containers/deploy-spring-boot-application-production-helm/</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/guides/containers/deploy-spring-boot-application-production-helm/</guid>
      <description>

        
        &lt;p&gt;Bitnami provides ready-to-run &lt;a href=&#34;https://github.com/bitnami/charts&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm charts&lt;/a&gt; that can be directly deployed on &lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubernetes&lt;/a&gt; and also infrastructure charts that can help you deploy your custom applications. That is the case of the &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/tomcat&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Tomcat Helm chart&lt;/a&gt; that with some tweaks can be used to run Java applications in production easily.&lt;/p&gt;
&lt;p&gt;This tutorial walks you through the process of deploying a Spring Boot container image on Kubernetes using the Bitnami Apache Tomcat Helm chart. It uses the resulting image created in the &lt;a href=&#34;../deploy-locally-spring-boot-application-docker&#34;&gt;Deploy locally a Spring Boot application using Bitnami containers&lt;/a&gt; guide as an example. While the Bitnami Tomcat Helm chart will be modified to get the application container from the DockerHub registry, create a secret to secure the application pod and connect it to a MariaDB pod.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and prerequisites&lt;/h2&gt;
&lt;p&gt;This guide makes the following assumptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have basic knowledge of &lt;a href=&#34;https://www.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker&lt;/a&gt; containers.&lt;/li&gt;
&lt;li&gt;You have a Docker environment installed and configured. &lt;a href=&#34;https://docs.docker.com/install/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about installing Docker&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a Docker Hub account. &lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Register for a free account&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a &lt;a href=&#34;https://docs.bitnami.com/tutorials/deploy-locally-spring-boot-application-docker/#step-6-publish-the-docker-image&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Spring Boot container published&lt;/a&gt; in a container registry (this tutorial assumes that you are using &lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker Hub&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;You have a &lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubernetes cluster running&lt;/a&gt; in the platform of your choice. This tutorial uses &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Minikube&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have the &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes/#step-3-install-kubectl-command-line&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;em&gt;kubectl&lt;/em&gt; command line (&lt;em&gt;kubectl&lt;/em&gt; CLI)&lt;/a&gt; installed.&lt;/li&gt;
&lt;li&gt;You have &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes/#step-4-install-helm&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm v3.x&lt;/a&gt; installed.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following are the steps you will complete in this guide:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Step 1: Create the Helm chart&lt;/li&gt;
&lt;li&gt;Step 2: Adapt the Helm chart to include the source code and database&lt;/li&gt;
&lt;li&gt;Step 3: Create a secret to secure the deployment&lt;/li&gt;
&lt;li&gt;Step 4: Deploy the example application in Kubernetes&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Learn how to create a Spring Boot Docker container image in the &lt;a href=&#34;../deploy-locally-spring-boot-application-docker&#34;&gt;Deploy locally a Spring Boot application using Bitnami containers&lt;/a&gt; guide.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;step-1-create-the-helm-chart&#34;&gt;Step 1: Create the Helm chart&lt;/h2&gt;
&lt;p&gt;Begin by creating the Helm chart for our application. In this case, the Bitnami Tomcat Helm chart will serve you as a starting point which you can modify to build your custom chart. To do so, execute the following command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;helm fetch bitnami/tomcat --untar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will create a folder in your local system that contains all the files required for deploying Tomcat in a Kubernetes cluster.&lt;/p&gt;
&lt;h2 id=&#34;step-2-adapt-the-helm-chart-to-include-the-source-code-and-database&#34;&gt;Step 2: Adapt the Helm chart to include the source code and database&lt;/h2&gt;
&lt;p&gt;The first step consists of adapting the current Bitnami Tomcat Helm chart to include the sample Spring Boot container image and MariaDB as a database. Then, connect both pods when deploying the resulting chart. Follow the instructions below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Change to the &lt;em&gt;tomcat&lt;/em&gt; directory and create a file named &lt;em&gt;requirements.yaml&lt;/em&gt; with the content below to include MariaDB as a dependency:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;dependencies:
- name: mariadb
  version: 5.x.x
  repository: https://charts.helm.sh/stable/
  condition: mariadb.enabled
  tags:
    - spring-java-app-database
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Edit the &lt;em&gt;values.yaml&lt;/em&gt; file and replace the default values with the following to include your image. Remember to replace the DOCKER_USERNAME placeholder with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;[...]
image:
   registry: docker.io
   repository: DOCKER_USERNAME/spring-java-app
   tag: latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Add the following lines at the end of the &lt;em&gt;values.yaml&lt;/em&gt; file to specify the database:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;[...]
mariadb:
   Whether to deploy a mariadb server to satisfy the applications database requirements. To use an external database set this to false and configure the externalDatabase parameters
  enabled: true
   Disable MariaDB replication
  replication:
    enabled: false
   Create a database and a database user
   ref: https://github.com/bitnami/bitnami-docker-mariadb/blob/master/README.mdcreating-a-database-user-on-first-run

  db:
    name: db_example
    user: springuser
   If the password is not specified, mariadb will generates a random password

  password: ThePassword
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Edit the &lt;em&gt;templates/_helpers.tpl&lt;/em&gt; and add the lines below to generate the name of the MariaDB service so the application will be able to connect to it:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;{{/*
Create a default fully qualified app name.
We truncate at 63 chars because some Kubernetes name fields are limited to this (by the DNS naming spec).
*/}}
{{- define &amp;#34;mariadb.fullname&amp;#34; -}}
{{- printf &amp;#34;%s-%s&amp;#34; .Release.Name &amp;#34;mariadb&amp;#34; | trunc 63 | trimSuffix &amp;#34;-&amp;#34; -}}
{{- end -}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-3-create-a-secret-to-secure-the-deployment&#34;&gt;Step 3: Create a secret to secure the deployment&lt;/h2&gt;
&lt;p&gt;The next step is to create a secret for the Spring Boot application that secures the connection between the application and the database. Follow these instructions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In the &lt;em&gt;templates&lt;/em&gt; directory, create a file named &lt;em&gt;spring-secret.yaml&lt;/em&gt; that includes the following content:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;apiVersion: v1
kind: Secret
metadata:
  name: {{ template &amp;#34;tomcat.fullname&amp;#34; . }}-spring
  labels:
    app: {{ template &amp;#34;tomcat.fullname&amp;#34; . }}
    chart: &amp;#34;{{ .Chart.Name }}-{{ .Chart.Version }}&amp;#34;
    release: &amp;#34;{{ .Release.Name }}&amp;#34;
    heritage: &amp;#34;{{ .Release.Service }}&amp;#34;
type: Opaque
data:
  spring-db: {{ printf &amp;#34;{\&amp;#34;spring\&amp;#34;: {\&amp;#34;datasource\&amp;#34;:{\&amp;#34;url\&amp;#34;: \&amp;#34;jdbc:mysql://%s:3306/%s\&amp;#34;, \&amp;#34;username\&amp;#34;: \&amp;#34;%s\&amp;#34;, \&amp;#34;password\&amp;#34;: \&amp;#34;%s\&amp;#34;}}}&amp;#34; (include &amp;#34;mariadb.fullname&amp;#34; .) .Values.mariadb.db.name .Values.mariadb.db.user .Values.mariadb.db.password | b64enc }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Edit the &lt;em&gt;templates/deployment.yaml&lt;/em&gt; file to add the lines below. These refer to the secret created in the step above:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;[...]
- name: TOMCAT_PASSWORD
  valueFrom:
    secretKeyRef:
      name: {{ template &amp;#34;tomcat.fullname&amp;#34; . }}
      key: tomcat-password
- name: SPRING_APPLICATION_JSON
  valueFrom:
    secretKeyRef:
      name: {{ template &amp;#34;tomcat.fullname&amp;#34; . }}-spring
      key: spring-db
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-4-deploy-the-example-application-in-kubernetes&#34;&gt;Step 4: Deploy the example application in Kubernetes&lt;/h2&gt;
&lt;p&gt;Before deploying the resulting Helm chart, make sure that you can connect to your Kubernetes cluster by running this command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;kubectl cluster-info
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Execute the command below to install missing dependencies. In this case, it will install the database that we have indicated in the &lt;em&gt;requirements.yaml&lt;/em&gt; file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;helm dependency update .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Deploy the chart by executing the &lt;em&gt;helm install&lt;/em&gt; command. It is recommended to install it by passing a name using the &lt;em&gt;/&amp;ndash;n&lt;/em&gt; flag.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;helm install spring-java .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Check that all pods are ready by executing the &lt;em&gt;kubectl get pods&lt;/em&gt; command. Take into account that the database pod takes more time to be deployed than the Tomcat pod, is possible that the &lt;em&gt;kubectl logs&lt;/em&gt; command show errors during that time.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;kubectl get pods -w
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You should see an output similar to this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-spring-boot-application-production-helm/get-pods.png&#34; alt=&#34;Pod status&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To test that the Spring Boot application has been successfully deployed it is necessary to make it accessible from your local system. To do so, port forward the Tomcat pod as shown below. Replace &lt;em&gt;svc/spring-java-tomcat&lt;/em&gt; with the name of the service that appears in your deployment:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;kubectl port-forward svc/spring-java-tomcat 8080:80
Forwarding from 127.0.0.1:8080 -&amp;gt; 8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To test if the application works fine, open a new terminal and insert some data in the database by executing:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;curl &amp;#39;localhost:8080/gs-mysql-data-0.1.0/demo/add?name=First&amp;amp;email=someemail@someemailprovider.com&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Query the application again to check if the data is present in the database:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;curl &amp;#39;localhost:8080/gs-mysql-data-0.1.0/demo/all&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You should get an output similar to this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;[{&amp;#34;id&amp;#34;:1, &amp;#34;name&amp;#34;:&amp;#34;First&amp;#34;, &amp;#34;email&amp;#34;:&amp;#34;someemail@someemailprovider.com&amp;#34;}]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Congratulations! You have your Spring Boot application running in a Kubernetes production cluster and ready to use!&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bitnami.com/kubernetes&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Kubernetes projects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../deploy-locally-spring-boot-application-docker&#34;&gt;Deploy locally a Spring Boot application using Bitnami containers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com//kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Get started with Kubernetes guides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/tutorials/deploy-application-kubernetes-helm/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Deploy, Scale And Upgrade An Application On Kubernetes With Helm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/tomcat&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Tomcat Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Helm charts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker Hub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://spring.io/projects/spring-boot&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Spring Boot official site&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/tutorials&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami tutorials repository&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Best Practices for Creating Production-Ready Helm Charts</title>
      
      <link>/guides/kubernetes/production-ready-helm/</link>
      <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/guides/kubernetes/production-ready-helm/</guid>
      <description>

        
        &lt;p&gt;Three years have passed since &lt;a href=&#34;https://github.com/helm/helm/releases?after=v1.1&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;the first release of Helm&lt;/a&gt;, and it has indeed made a name for itself. Both avowed fans and fervent haters agree that the Kubernetes &amp;ldquo;apt-get equivalent&amp;rdquo; is the standard way of deploying to production (at least for now, let&amp;rsquo;s see what Operators end up bringing to the table). During this time, Bitnami has contributed to the project in many ways. You can find us in PRs in Helm&amp;rsquo;s code, in solutions like &lt;a href=&#34;https://hub.kubeapps.com/charts/bitnami&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubeapps&lt;/a&gt;, and especially in what we are mostly known for: &lt;a href=&#34;https://bitnami.com/stacks/helm&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;our huge application library&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As maintainers of a collection of more than &lt;a href=&#34;https://github.com/bitnami/charts/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;45 Helm charts&lt;/a&gt;, we know that creating a maintainable, secure and production-ready chart is far from trivial. In this sense, this blog post shows essential features that any chart developer should know.&lt;/p&gt;
&lt;h2 id=&#34;use-non-root-containers&#34;&gt;Use non-root containers&lt;/h2&gt;
&lt;p&gt;Ensuring that a container is able to perform only a very limited set of operations is vital for production deployments. This is possible thanks to the &lt;strong&gt;use of non-root containers, which are executed by a user different from &lt;em&gt;root&lt;/em&gt;.&lt;/strong&gt; Although creating a non-root container is a bit more complex than a root container (especially regarding filesystem permissions), it is absolutely worth it. Also, in environments like OpenShift, &lt;a href=&#34;https://engineering.bitnami.com/articles/running-non-root-containers-on-openshift.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;using non-root containers is mandatory&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In order to make your Helm chart work with non-root containers, add the &lt;a href=&#34;https://kubernetes.io/docs/tasks/configure-pod-container/security-context/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;em&gt;securityContext&lt;/em&gt;&lt;/a&gt; section to your &lt;em&gt;yaml&lt;/em&gt; files.&lt;/p&gt;
&lt;p&gt;This is what we do, for instance, in the Bitnami Elasticsearch Helm chart. This chart deploys several Elasticsearch &lt;em&gt;StatefulSets&lt;/em&gt; and &lt;em&gt;Deployments&lt;/em&gt; (data, ingestion, coordinating and master nodes), all of them with non-root containers. If we check the master node &lt;em&gt;StatefulSet&lt;/em&gt;, we see the following:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.securityContext.enabled }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;securityContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fsGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.securityContext.fsGroup }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The snippet above changes the permissions of the mounted volumes, so the container user can access them for read/write operations. In addition to this, inside the container definition, we see another &lt;em&gt;securityContext&lt;/em&gt; block:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.securityContext.enabled }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;securityContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;runAsUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.securityContext.runAsUser }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this part we specify the user running the container. In the &lt;em&gt;values.yaml&lt;/em&gt; file, we set the default values for these parameters:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;## Pod Security Context&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;##&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;securityContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;enabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fsGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1001&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;runAsUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1001&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With these changes, the chart will work as non-root in platforms like GKE, Minikube or OpenShift.&lt;/p&gt;
&lt;h2 id=&#34;do-not-persist-the-configuration&#34;&gt;Do not persist the configuration&lt;/h2&gt;
&lt;p&gt;Adding persistence is an essential part of deploying stateful applications. In our experience, deciding what or what not to persist can be tricky. After several iterations in our charts, we found that &lt;strong&gt;persisting the application configuration is not a recommended practice&lt;/strong&gt;. One advantage of Kubernetes is that you can change the deployment parameters very easily by just doing &lt;code&gt;kubectl edit deployment&lt;/code&gt; or &lt;code&gt;helm upgrade&lt;/code&gt;. If the configuration is persisted, none of the changes would be applied. So, when developing a production-ready Helm chart, make sure that the configuration can be easily changed with &lt;code&gt;kubectl&lt;/code&gt; or &lt;code&gt;helm upgrade&lt;/code&gt;. One common practice is to create a &lt;em&gt;ConfigMap&lt;/em&gt; with the configuration and have it mounted in the container. Let&amp;rsquo;s use the &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/rabbitmq&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami RabbitMQ chart&lt;/a&gt; as an example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ConfigMap&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;rabbitmq.fullname&amp;#34; . }}-config&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;rabbitmq.name&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;chart&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;rabbitmq.chart&amp;#34; .  }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{{ .Release.Name }}&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;heritage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{{ .Release.Service }}&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;enabled_plugins&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;|-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;rabbitmq.plugins&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rabbitmq.conf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|-&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    ##username and password
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    default_user={{.Values.rabbitmq.username}}
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    default_pass=CHANGEME&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.rabbitmq.configuration | indent 4 }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.rabbitmq.extraConfiguration | indent 4 }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that there is a section in the &lt;em&gt;values.yaml&lt;/em&gt; file that allows you to include any custom configuration:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;## Configuration file content: required cluster configuration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;## Do not override unless you know what you are doing. To add more configuration, use `extraConfiguration` instead&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;configuration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|-&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    ## Clustering
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    cluster_formation.peer_discovery_backend  = rabbit_peer_discovery_k8s
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    cluster_formation.k8s.host = kubernetes.default.svc.cluster.local
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    cluster_formation.node_cleanup.interval = 10
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    cluster_formation.node_cleanup.only_log_warning = true
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    cluster_partition_handling = autoheal
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    # queue master locator
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    queue_master_locator=min-masters
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    # enable guest user
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    loopback_users.guest = false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;## Configuration file content: extra configuration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;## Use this instead of  `configuration` to add more configuration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;extraConfiguration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|-&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    #disk_free_limit.absolute = 50MB
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    #management.load_definitions = /app/load_definition.json&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This &lt;em&gt;ConfigMap&lt;/em&gt; then gets mounted in the container filesystem, as shown in this extract of the &lt;em&gt;StatefulSet&lt;/em&gt; spec:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;config-volume&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;configMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;rabbitmq.fullname&amp;#34; . }}-config&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If the application needs to write in the configuration file, then you&amp;rsquo;ll need to create a copy inside the container, as &lt;em&gt;ConfigMaps&lt;/em&gt; are mounted as read-only. This is done in the same spec:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rabbitmq&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;rabbitmq.image&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;imagePullPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.image.pullPolicy | quote }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# ...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;#copy the mounted configuration to both places&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;cp  /opt/bitnami/rabbitmq/conf/* /opt/bitnami/rabbitmq/etc/rabbitmq&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# ...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will make your chart not only easy to upgrade, but also more adaptable to user needs, as they can provide their custom configuration file.&lt;/p&gt;
&lt;h2 id=&#34;integrate-charts-with-logging-and-monitoring-tools&#34;&gt;Integrate charts with logging and monitoring tools&lt;/h2&gt;
&lt;p&gt;If we are talking about production environments, we are talking about observability. It is essential having our deployments properly monitored so we can early detect potential issues. It also essential to have application usage, cost and resource consumption metrics. In order to gather this information, you would commonly deploy logging stacks like EFK (&lt;a href=&#34;https://www.elastic.co/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;ElasticSearch&lt;/a&gt;, &lt;a href=&#34;https://www.fluentd.org/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Fluentd&lt;/a&gt;, and &lt;a href=&#34;https://www.elastic.co/products/kibana&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kibana&lt;/a&gt; and monitoring tools like &lt;a href=&#34;https://prometheus.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Prometheus&lt;/a&gt;. Bitnami offers the &lt;a href=&#34;https://kubeprod.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Kubernetes Production Runtime (BKPR)&lt;/a&gt; that easily installs these tools (along with others) so your cluster is ready to handle production workloads.&lt;/p&gt;
&lt;p&gt;When writing your chart, make sure that your deployment is able to work with the above tools seamlessly. To do so, ensure the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All the containers log to stdout/stderr (so the EFK stack can easily ingest all the logging information)&lt;/li&gt;
&lt;li&gt;Prometheus exporters are included (either using sidecar containers or having a separate deployment)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All Bitnami charts work with BKPR (which includes EFK and Prometheus) out of the box. Let&amp;rsquo;s take a look at the &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/postgresql&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami PostgreSQL chart&lt;/a&gt; and &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-postgresql&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami PostgreSQL container&lt;/a&gt; to see how we did it.&lt;/p&gt;
&lt;p&gt;To begin with, the process inside the container runs at the foreground, so all the logging information is written to stdout/stderr, as shown below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;info &lt;span class=&#34;s2&#34;&gt;&amp;#34;** Starting PostgreSQL **&amp;#34;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; am_i_root&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;then&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; gosu &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$POSTGRESQL_DAEMON_USER&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[@]&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[@]&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With this, we ensured that it works with EFK. Then, in the chart we added a sidecar container for the Prometheus metrics:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.metrics.enabled }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;postgresql.metrics.image&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;imagePullPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.image.pullPolicy | quote }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.metrics.securityContext.enabled }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;securityContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;runAsUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.securityContext.runAsUser }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;$database := required &amp;#34;In order to enable metrics you need to specify a database (.Values.postgresqlDatabase or .Values.global.postgresql.postgresqlDatabase)&amp;#34; (include &amp;#34;postgresql.database&amp;#34; .) }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DATA_SOURCE_URI&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;printf &amp;#34;127.0.0.1:%d/%s?sslmode=disable&amp;#34; (int (include &amp;#34;postgresql.port&amp;#34; .)) $database | quote }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.usePasswordFile }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DATA_SOURCE_PASS_FILE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/bitnami/postgresql/secrets/postgresql-password&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;else }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DATA_SOURCE_PASS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;valueFrom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;secretKeyRef&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;postgresql.secretName&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;postgresql-password&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DATA_SOURCE_USER&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;postgresql.username&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.livenessProbe.enabled }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;livenessProbe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;httpGet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http-metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;initialDelaySeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.livenessProbe.initialDelaySeconds }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;periodSeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.livenessProbe.periodSeconds }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timeoutSeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.livenessProbe.timeoutSeconds }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;successThreshold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.livenessProbe.successThreshold }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;failureThreshold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.livenessProbe.failureThreshold }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.readinessProbe.enabled }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readinessProbe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;httpGet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http-metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;initialDelaySeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.readinessProbe.initialDelaySeconds }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;periodSeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.readinessProbe.periodSeconds }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timeoutSeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.readinessProbe.timeoutSeconds }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;successThreshold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.readinessProbe.successThreshold }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;failureThreshold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.readinessProbe.failureThreshold }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeMounts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.usePasswordFile }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;postgresql-password&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/opt/bitnami/postgresql/secrets/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.metrics.customMetrics }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;custom-metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/conf&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;--extend.query-path&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/conf/custom-metrics.yaml&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http-metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;9187&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.metrics.resources }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;toYaml .Values.metrics.resources | nindent 12 }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We also made sure that the pods or services contain the proper annotations that Prometheus uses to detect exporters. In this case, we defined them in the chart&amp;rsquo;s &lt;em&gt;values.yaml&lt;/em&gt; file, as shown below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;metrics&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;enabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ClusterIP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prometheus.io/scrape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prometheus.io/port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;9187&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;#...  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the case of the PostgreSQL chart, these annotations go to a metrics service, separate from the PostgreSQL service, which is defined as below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.metrics.enabled }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;postgresql.fullname&amp;#34; . }}-metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;postgresql.name&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;chart&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;postgresql.chart&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Release.Name | quote }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;heritage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Release.Service | quote }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;toYaml .Values.metrics.service.annotations | indent 4 }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.service.type }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if and (eq .Values.metrics.service.type &amp;#34;LoadBalancer&amp;#34;) .Values.metrics.service.loadBalancerIP }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;loadBalancerIP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.service.loadBalancerIP }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http-metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;9187&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http-metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;postgresql.name&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Release.Name }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;role&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;master&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With these modifications, your chart will seamlessly integrate with your monitoring platform. All the obtained metrics will be crucial for maintaining the deployment in good shape.&lt;/p&gt;
&lt;h2 id=&#34;production-workloads-in-kubernetes-are-possible&#34;&gt;Production workloads in Kubernetes are possible&lt;/h2&gt;
&lt;p&gt;Now you know some essential guidelines for creating secured (with non-root containers), adaptable (with proper configuration management), and observable (with proper monitoring) charts. With these features, you have covered the basics to ensure that your application can be deployed to production. However, this is just another step in your journey to mastering Helm. You should also take into account other features like upgradability, usability, stability and testing.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful Links&lt;/h2&gt;
&lt;p&gt;To learn more, check the following links:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://helm.sh/docs/chart_best_practices/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Official Helm chart good practice guidelines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codefresh.io/docs/docs/new-helm/helm-best-practices/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm best practices by CodeFresh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubeprod.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Kubernetes Production Runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Helm charts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hub.kubeapps.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubeapps Hub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Deploy from a Private Helm Repository Using Kubeapps</title>
      
      <link>/guides/kubernetes/kubeapps-private-repo/</link>
      <pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>/guides/kubernetes/kubeapps-private-repo/</guid>
      <description>

        
        &lt;p&gt;&lt;a href=&#34;https://github.com/kubeapps/kubeapps/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubeapps&lt;/a&gt; is a web-based UI for
deploying and managing applications in Kubernetes clusters. Kubeapps includes a
built-in catalog of Helm charts and operators continuously maintained and up to
date. Now Kubeapps also provides support for private Helm repositories with
private Docker images. There is an option of associating Docker credentials to
an application repository so that Kubeapps can ensure they are used to pull any
matching private images within a chart. This option is really useful for
enterprise development team since it allows them to have more granular access
control as well as a known good source of images.&lt;/p&gt;
&lt;p&gt;Kubeapps officially supports the following Helm repositories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubeapps/kubeapps/blob/master/docs/user/private-app-repository.md#chartmuseum&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;ChartMuseum&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubeapps/kubeapps/blob/master/docs/user/private-app-repository.md#harbor&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Harbor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubeapps/kubeapps/blob/master/docs/user/private-app-repository.md#artifactory&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Artifactory Pro&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This tutorial shows you how to create a private project in Harbor, push a
customized Helm chart to your registry and create an application repository to
have your chart ready from the Kubeapps UI to be deployed.&lt;/p&gt;
&lt;p&gt;Watch the following video or keep reading this tutorial to learn more:&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;360&#34; src=&#34;https://www.youtube.com/embed/LLw1Ib8IQQk&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and prerequisites&lt;/h2&gt;
&lt;p&gt;This guide assumes that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have a Docker environment installed and configured. Learn more about
&lt;a href=&#34;https://docs.docker.com/engine/install/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;installing Docker&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a Docker Hub account.
&lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Register for a free account&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a Kubernetes cluster. Check out our
&lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Getting Started with Kubernetes guides&lt;/a&gt;
for an easy way to get started with one.&lt;/li&gt;
&lt;li&gt;You have administrator access to a preexisting installation of
&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/harbor&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Harbor&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have
&lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes/#step-4-install-helm&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm installed in your cluster&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have
&lt;a href=&#34;https://github.com/kubeapps/kubeapps/blob/master/docs/user/getting-started.md&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubeapps installed in your cluster&lt;/a&gt;
and are logged into the Kubeapps UI with admin credentials.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-1-create-a-private-project-in-harbor&#34;&gt;Step 1: Create a private project in Harbor&lt;/h2&gt;
&lt;p&gt;The first step is to create a project in Harbor. To do so:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Log in to Harbor.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the &amp;ldquo;Projects&amp;rdquo; section, click &amp;ldquo;+ New Project&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the resulting screen, give a name to your project. This should be private
so don&amp;rsquo;t activate the &amp;ldquo;Public&amp;rdquo; check. To get an unlimited storage quota, set
that value as -1. Click &amp;ldquo;OK&amp;rdquo; to proceed.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/kubeapps-private-repo/harbor-create-new-project.png&#34; alt=&#34;Create a private project in Harbor&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-2-pull-the-docker-image-and-push-it-to-your-private-harbor-registry&#34;&gt;Step 2: Pull the Docker image and push it to your private Harbor Registry&lt;/h2&gt;
&lt;p&gt;Next, pull the Docker image of the chart you want to add to your private
repository. Then, you need to push it to Harbor to make it available in your
project. Follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Execute the following command to obtain the latest Bitnami Ghost image:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker pull bitnami/ghost:3.13.2-debian-10-r0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tag the image by executing the command below. Remember to replace the
&lt;code&gt;HARBOR_DOMAIN_NAME&lt;/code&gt; placeholder with the domain name where Harbor is installed.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker tag docker.io/bitnami/ghost:3.13.2-debian-10-r0 HARBOR_DOMAIN_NAME/project-private/ghost:3.13.2-debian-10-r0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Login in to Harbor.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker login HARBOR_DOMAIN_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Push the image to your registry by executing this command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker push HARBOR_DOMAIN_NAME/project-private/ghost:3.13.2-debian-10-r0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You should see an output message similar to this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;The push refers to repository &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;harbor.bkpr-kubeapps-gke.nami.run/project-private/ghost&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
325a01bfb407: Preparing
17d308e7f8c1: Preparing
0a621af6678f: Preparing
2e366bd4c478: Preparing
315ad5c0230e: Preparing
1cfb963e6dd2: Waiting
4e78eb629a01: Waiting
f2e5c6cb0141: Waiting
8bce1f8ba802: Waiting
7d1d696c2212: Waiting
9f729ba7c732: Waiting
e048dd4e8543: Waiting
3.13.2-debian-10-r0: digest: sha256:9121f532fbe28f8e6d4cb11bf542374689c4595378ef83adeda5bff46731d972 size: &lt;span class=&#34;m&#34;&gt;2839&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Navigate to the Harbor UI and in your project, select the tab &amp;ldquo;Repositories&amp;rdquo;.
You should see the repository that contains the image you just pushed. Click
on it to check image details:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/kubeapps-private-repo/harbor-images-pushed.png&#34; alt=&#34;Harbor repositories&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;step-3-enable-a-robot-account-in-your-project&#34;&gt;Step 3: Enable a Robot Account in your project&lt;/h2&gt;
&lt;p&gt;Next step is to enable a Robot Account in your project with access to pull both
Helm charts from the private repositories as well as Docker images in the
private project. To do so:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;From the Harbor UI, navigate to the &amp;ldquo;Robot Account&amp;rdquo; tab in your project and
click &amp;ldquo;+ New Robot Account&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the resulting window, give it a name, a description (optional) and in the
&amp;ldquo;Permissions&amp;rdquo; section, activate the &amp;ldquo;Pull&amp;rdquo; check in the Helm Chart line. Click
&amp;ldquo;Save&amp;rdquo; to proceed.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/kubeapps-private-repo/create-robot-account.png&#34; alt=&#34;Create a Robot Account in your project&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once it is created, remember to copy the token in a safe place or export it to file.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/kubeapps-private-repo/robot-account-created.png&#34; alt=&#34;Copy or export to file the token&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;step-4-customize-your-helm-chart-and-push-it-to-your-private-harbor-registry&#34;&gt;Step 4: Customize your Helm chart and push it to your private Harbor Registry&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Get the Bitnami Ghost Helm chart and change to the chart&amp;rsquo;s directory by
executing the following command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm fetch bitnami/ghost --untar &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ghost
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Edit the &lt;em&gt;values.yaml&lt;/em&gt; file of the chart of the chart so that the
image.registry and image.repository value point to your registry and
repository path respectively:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/kubeapps-private-repo/chart-values-yaml.png&#34; alt=&#34;Modify the chart values.yaml file&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Once you have edited those values, package you chart by running:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ../ &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; helm package ./ghost
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You will see an output message similar to this: &amp;ldquo;Successfully packaged chart&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From the Harbor UI, navigate to the &amp;ldquo;Helm Charts&amp;rdquo; tab and click &amp;ldquo;Upload&amp;rdquo;.
Browse the resultant &lt;em&gt;tgz&lt;/em&gt; file of your packaged chart and click &amp;ldquo;Upload&amp;rdquo;. You
will see your Helm Chart uploaded in a few minutes:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/kubeapps-private-repo/harbor-helm-chart.png&#34; alt=&#34;Harbor Helm chart uploaded&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;You can click on it to check more information about the chart:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/kubeapps-private-repo/harbor-chart-details.png&#34; alt=&#34;Harbor Helm chart details&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now that you have both the Ghost image and its Helm chart available in your
Harbor private repository, it is time to create an application repository in
Kubeapps to start deploying your charts on Kubernetes from its dashboard.&lt;/p&gt;
&lt;h2 id=&#34;step-5-create-an-application-repository-to-enable-your-harbors-private-repository-in-kubeapps&#34;&gt;Step 5: Create an application repository to enable your Harbor&amp;rsquo;s private repository in Kubeapps&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Log in to Kubeapps.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Select the namespace where the repository (and the secret) are to be created.
This should be different from the &lt;em&gt;kubeapps&lt;/em&gt; namespace.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From the menu button in the top right corner, select the &amp;ldquo;App Repositories&amp;rdquo;
option, then click the &amp;ldquo;Add App Repository&amp;rdquo; button.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the resulting screen enter the following information:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Application repository name&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;URL: private repository URL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Repository Authorization: select the &amp;ldquo;Basic Auth&amp;rdquo; option and enter as
&amp;ldquo;Username&amp;rdquo; the name you gave to the Robot Account created in Harbor, and as
&amp;ldquo;Password&amp;rdquo;, the token you obtain at the time of the creation. This way,
Kubeapps will be able to see the charts you have pulled into your Harbor
repository.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Associate Docker Registry Credentials: click &amp;ldquo;Add New Credentials&amp;rdquo; to add
the credentials that will allow Kubernetes to pull images from your private
repository. Add the values below, then click &amp;ldquo;Submit&amp;rdquo;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Secret name&lt;/li&gt;
&lt;li&gt;Server: Harbor&amp;rsquo;s server domain&lt;/li&gt;
&lt;li&gt;Username: in this case, as you created a Robot Account, use its name as username&lt;/li&gt;
&lt;li&gt;Password: use the Robot Account token as password&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/kubeapps-private-repo/app-repo-pull-secret.png&#34; alt=&#34;Add an application repository with the Harbor credentials&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click the &amp;ldquo;Install Repo&amp;rdquo; button to finish the process. You will see your new
application repository in the list of existing application repositories in
your namespace.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/kubeapps-private-repo/app-repositories.png&#34; alt=&#34;List of application repositories&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;If you click the repository link, you will be redirected to its catalog. You
should see your Ghost chart there ready to be deployed:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/kubeapps-private-repo/private-repo-catalog.png&#34; alt=&#34;Private repository application catalog&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-6-deploy-your-custom-ghost-from-the-kubeapps-ui&#34;&gt;Step 6: Deploy your custom Ghost from the Kubeapps UI&lt;/h2&gt;
&lt;p&gt;Finally, you are able to install your custom application from your private
registry on Kubernetes using the Kubeapps UI.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In the application repository catalog you just created, click the Ghost entry
to go to the chart page.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;On the resulting screen, you can learn about the Ghost chart, the repository
where it is located, review older versions, and any related links. Click
&amp;ldquo;Deploy&amp;rdquo; to deploy the chart:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/kubeapps-private-repo/deploy-ghost.png&#34; alt=&#34;Deploy Ghost from your private repository&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This will take you to a page where you can configure your Ghost deployment.
You can use either the &amp;ldquo;Form&amp;rdquo; or the &amp;ldquo;YAML&amp;rdquo; tab to customize your deployment
as you want: give your chart a name, change the version you want to deploy,
add an admin password (if not, a random 10-character alphanumeric string will
be set), or configure Helm values.&lt;/p&gt;


&lt;div class=&#34;aside aside-info&#34;&gt;
    &lt;div class=&#34;aside aside-title&#34;&gt;
        &lt;i class=&#34;fas fa-exclamation-circle&#34;&gt;&lt;/i&gt;
        &lt;div&gt;Important&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&#34;aside aside-content&#34;&gt;
    &lt;p&gt;The Ghost chart requires a resolvable host. Specify it in the &amp;ldquo;Hostname&amp;rdquo; section.&lt;/p&gt;

    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/kubeapps-private-repo/ghost-values-kubeapps.png&#34; alt=&#34;Ghost values&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click &amp;ldquo;Submit&amp;rdquo; to start the application deployment. Once submitted, you will
be redirected to a page that describes the state of your deployment. The
status will be &amp;ldquo;Deploying&amp;rdquo; until Ghost is up and running.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/kubeapps-private-repo/ghost-deployment.png&#34; alt=&#34;Ghost deployment&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Once the chart is deployed, you can see all the deployment details, including
the URLs to access the application.&lt;/p&gt;
&lt;p&gt;By default, Ghost creates a Service with LoadBalancer type to provide an
externally accessible URL for its web interface. Depending on your cloud
provider of choice, the load balancer can take some time to provision and will
stay in a &amp;ldquo;Pending&amp;rdquo; state until it is available. If using Minikube, you will
need to run minikube tunnel in a new terminal window in order for an IP
address to be assigned.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After some time, the URL should be visible in the Access URL table. Once it is
visible, click one of the URLs shown to access your freshly deployed Ghost
blog.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/kubeapps-private-repo/ghost.png&#34; alt=&#34;Ghost home page&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubeapps/kubeapps&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubeapps Github repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubeapps/kubeapps/blob/master/docs/user/private-app-repository.md#harbor&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Using a Private Repository with Kubeapps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://goharbor.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Harbor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Create a Multi-Cluster Monitoring Dashboard with Thanos, Grafana and Prometheus</title>
      
      <link>/guides/kubernetes/prometheus-multicluster-monitoring/</link>
      <pubDate>Wed, 11 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/guides/kubernetes/prometheus-multicluster-monitoring/</guid>
      <description>

        
        &lt;p&gt;&lt;a href=&#34;https://prometheus.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Prometheus&lt;/a&gt;, coupled with
&lt;a href=&#34;https://grafana.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Grafana&lt;/a&gt;, is a popular monitoring solution for Kubernetes
clusters. It allows SRE teams and developers to capture metrics and telemetry
data for applications running in a cluster, allowing deeper insights into
application performance and reliability.&lt;/p&gt;
&lt;p&gt;The Prometheus/Grafana combination works well for individual clusters, but as
teams scale out and start working with multiple clusters, monitoring
requirements become correspondingly more complex. For effective multi-cluster
monitoring, a &amp;ldquo;single pane of glass&amp;rdquo; with centralized real-time monitoring, time
series comparisons across and within clusters and high availability is essential
for teams operating with multiple clusters and multiple providers.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://thanos.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Thanos&lt;/a&gt; is a monitoring system that aggregates data from
multiple Prometheus deployments. This data can then be inspected and analyzed
using Grafana, just as with regular Prometheus metrics. Although this setup
sounds complex, it&amp;rsquo;s actually very easy to achieve with the following Bitnami
Helm charts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/prometheus-operator&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Prometheus Operator Helm chart&lt;/a&gt;
lets you deploy Prometheus in your Kubernetes cluster with an additional
Thanos sidecar container.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/thanos&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Thanos Helm chart&lt;/a&gt;
lets you deploy all the Thanos components together with MinIO and Alertmanager
so you can quickly bootstrap a Thanos deployment.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/grafana&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Grafana Helm chart&lt;/a&gt;
lets you deploy Grafana in your Kubernetes cluster.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This guide walks you through the process of using these charts to create a
Thanos deployment that aggregates data from Prometheus Operators in multiple
clusters and allows further monitoring and analysis using Grafana.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and prerequisites&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;You have three separate multi-node Kubernetes clusters running on the same
cloud provider:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Two &amp;ldquo;data producer&amp;rdquo; clusters which will host Prometheus deployments and
applications that expose metrics via Prometheus.&lt;/li&gt;
&lt;li&gt;One &amp;ldquo;data aggregator&amp;rdquo; cluster which will host Thanos and aggregate the data
from the data producers. This cluster will also host Grafana for data
visualization and reporting.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You have the &lt;em&gt;kubectl&lt;/em&gt; CLI and the Helm v3.x package manager installed and configured to work with your Kubernetes clusters. &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes#step-3-install-kubectl-command-line&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn how to install &lt;em&gt;kubectl&lt;/em&gt; and Helm v3.x&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This guide uses clusters hosted on the Google Kubernetes Engine (GKE) service
but you can use any Kubernetes provider. Learn about
&lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;deploying a Kubernetes cluster on different cloud platforms&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;step-1-install-the-prometheus-operator-on-each-cluster&#34;&gt;Step 1: Install the Prometheus Operator on each cluster&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/prometheus-operator&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Prometheus Operator chart&lt;/a&gt;
provides easy monitoring definitions for Kubernetes services and management of
Prometheus instances. It also includes an optional Thanos sidecar container,
which can be used by your Thanos deployment to access cluster metrics.&lt;/p&gt;
&lt;p&gt;Only one instance of the Prometheus Operator component should be running in a
cluster.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Add the Bitnami charts repository to Helm:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm repo add bitnami https://charts.bitnami.com/bitnami
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Install the Prometheus Operator in the first &amp;ldquo;data producer&amp;rdquo; cluster using the command below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install prometheus-operator &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set prometheus.thanos.create&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set operator.service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ClusterIP &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set prometheus.service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ClusterIP &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set alertmanager.service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ClusterIP &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set prometheus.thanos.service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;LoadBalancer &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set prometheus.externalLabels.cluster&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;data-producer-0&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  bitnami/prometheus-operator
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;em&gt;prometheus.thanos.create&lt;/em&gt; parameter creates a Thanos sidecar container,
while the &lt;em&gt;prometheus.thanos.service.type&lt;/em&gt; parameter makes the sidecar service
available at a public load balancer IP address. Note the
&lt;em&gt;prometheus.externalLabels&lt;/em&gt; parameter which lets you define one or more unique
labels per Prometheus instance - these labels are useful to differentiate
different stores or data sources in Thanos.&lt;/p&gt;
&lt;p&gt;The command above exposes the Thanos sidecar container in each cluster at a
public IP address using a &lt;em&gt;LoadBalancer&lt;/em&gt; service. This makes it easy for
Thanos to access Prometheus metrics in different clusters without needing any
special firewall or routing configuration. However, this approach is highly
insecure and should be used only for demonstration or testing purposes. In
production environments, it is preferable to deploy an NGINX Ingress
Controller to control access from outside the cluster and further limit access
using whitelisting and other security-related configuration.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use the command below to obtain the public IP address of the sidecar service.
You will use this IP address in the next step.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get svc | grep prometheus-operator-prometheus-thanos
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Repeat the steps shown above for the second &amp;ldquo;data producer&amp;rdquo; cluster. Use a
different value for the &lt;em&gt;prometheus.externalLabels.cluster&lt;/em&gt; parameter, such as
&lt;em&gt;data-producer-1&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;step-2-install-and-configure-thanos&#34;&gt;Step 2: Install and configure Thanos&lt;/h2&gt;
&lt;p&gt;The next step is to install Thanos in the &amp;ldquo;data aggregator&amp;rdquo; cluster and
integrate it with Alertmanager and MinIO as the object store.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Modify your Kubernetes context to reflect the cluster on which you wish to install Thanos.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;values.yaml&lt;/em&gt; file as shown below. Replace the KEY placeholder with a
hard-to-guess value and the SIDECAR-SERVICE-IP-ADDRESS-X placeholders with the
public IP addresses of the Thanos sidecar containers in the &amp;ldquo;data producer&amp;rdquo;
clusters.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;objstoreConfig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|-&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;  type: s3
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;  config:
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    bucket: thanos
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    endpoint: {{ include &amp;#34;thanos.minio.fullname&amp;#34; . }}.monitoring.svc.cluster.local:9000
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    access_key: minio
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    secret_key: KEY
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    insecure: true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;querier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;stores&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;SIDECAR-SERVICE-IP-ADDRESS-1:10901&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;SIDECAR-SERVICE-IP-ADDRESS-2:10901&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;bucketweb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;enabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;compactor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;enabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;storegateway&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;enabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ruler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;enabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;alertmanagers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;http://prometheus-operator-alertmanager.monitoring.svc.cluster.local:9093&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|-&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    groups:
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;      - name: &amp;#34;metamonitoring&amp;#34;
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;        rules:
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;          - alert: &amp;#34;PrometheusDown&amp;#34;
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;            expr: absent(up{prometheus=&amp;#34;monitoring/prometheus-operator&amp;#34;})&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;minio&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;enabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;accessKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;minio&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;secretKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;KEY&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;defaultBuckets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;thanos&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Install Thanos using the command below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install thanos bitnami/thanos &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --values values.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wait for the deployment to complete and note the DNS name and port number for
the Thanos Querier service in the deployment output, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/querier-service.png&#34; alt=&#34;Thanos Querier service&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Follow the instructions shown in the chart output to connect to the Thanos
Querier Web interface and navigate to the &amp;ldquo;Stores&amp;rdquo; tab. Confirm that both
sidecar services are running and registered with Thanos, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/querier-stores.png&#34; alt=&#34;Thanos Querier stores&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Confirm also that each service displays a unique &lt;em&gt;cluster&lt;/em&gt; labelset, as configured in &lt;a href=&#34;#step-1-install-the-prometheus-operator-on-each-cluster&#34;&gt;Step 1&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-3-install-grafana&#34;&gt;Step 3: Install Grafana&lt;/h2&gt;
&lt;p&gt;The next step is to install Grafana, also on the same &amp;ldquo;data aggregator&amp;rdquo; cluster
as Thanos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Use the command below, replacing GRAFANA-PASSWORD with a password for the
Grafana application:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install grafana bitnami/grafana &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;LoadBalancer &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set admin.password&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;GRAFANA-PASSWORD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wait for the deployment to complete and obtain the public IP address for the
Grafana load balancer service:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl get svc &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep grafana
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Confirm that you are able to access Grafana by browsing to the load balancer
IP address on port 3000 and logging in with the username &lt;em&gt;admin&lt;/em&gt; and the
configured password. Here is what you should see:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/grafana-dashboard.png&#34; alt=&#34;Grafana dashboard&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-4-configure-grafana-to-use-thanos-as-a-data-source&#34;&gt;Step 4: Configure Grafana to use Thanos as a data source&lt;/h2&gt;
&lt;p&gt;Follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;From the Grafana dashboard, click the &amp;ldquo;Add data source&amp;rdquo; button.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;On the &amp;ldquo;Choose data source type&amp;rdquo; page, select &amp;ldquo;Prometheus&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/grafana-add-data-source.png&#34; alt=&#34;Grafana data source&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;On the &amp;ldquo;Settings&amp;rdquo; page, set the URL for the Prometheus server to
&lt;em&gt;http://NAME:PORT&lt;/em&gt;, where NAME is the DNS name for the Thanos service obtained
at the end of &lt;a href=&#34;#step-2-install-and-configure-thanos&#34;&gt;Step 2&lt;/a&gt; and PORT is the
corresponding service port. Leave all other values at their default.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/grafana-thanos-url.png&#34; alt=&#34;Grafana data source configuration&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click &amp;ldquo;Save &amp;amp; Test&amp;rdquo; to save and test the configuration. If everything is
configured correctly, you should see a success message like the one below.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/grafana-success.png&#34; alt=&#34;Grafana test&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-5-test-the-system&#34;&gt;Step 5: Test the system&lt;/h2&gt;
&lt;p&gt;At this point, you can start deploying applications into your &amp;ldquo;data producer&amp;rdquo;
clusters and collating the metrics in Thanos and Grafana. For demonstration
purposes, this guide will deploy a MariaDB replication cluster using Bitnami&amp;rsquo;s
MariaDB Helm chart in each &amp;ldquo;data producer&amp;rdquo; cluster and display the metrics
generated by each MariaDB service in Grafana.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Deploy MariaDB in each cluster with one master and one slave using the
production configuration with the commands below. Replace the
MARIADB-ADMIN-PASSWORD and MARIADB-REPL-PASSWORD placeholders with the
database administrator account and replication account password respectively.
You can also optionally create a MariaDB user account for application use by
specifying values for the USER-PASSWORD, USER-NAME and DB-NAME placeholders.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install mariadb &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set rootUser.password&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;MARIADB-ADMIN-PASSWORD &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set replication.password&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;MARIADB-REPL-PASSWORD &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set db.user&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;USER-NAME &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set db.password&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;USER-PASSWORD &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set db.name&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;DB-NAME &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set slave.replicas&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set metrics.enabled&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set metrics.serviceMonitor.enabled&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  bitnami/mariadb 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note the &lt;em&gt;metrics.enabled&lt;/em&gt; parameter, which enables the Prometheus exporter
for MySQL server metrics, and the &lt;em&gt;metrics.serviceMonitor.enabled&lt;/em&gt; parameter,
which creates a Prometheus Operator ServiceMonitor.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Once deployment in each cluster is complete, note the instructions to connect
to each database service.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/mariadb-service.png&#34; alt=&#34;MariaDB service&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Browse to the
&lt;a href=&#34;https://github.com/percona/grafana-dashboards/blob/master/dashboards/MySQL_Overview.json&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;MySQL Overview dashboard in the Percona GitHub repository&lt;/a&gt;
and copy the JSON model.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Log in to Grafana. From the Grafana dashboard, click the &amp;ldquo;Import -&amp;gt; Dashboard&amp;rdquo;
menu item.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;On the &amp;ldquo;Import&amp;rdquo; page, paste the JSON model into the &amp;ldquo;Or paste JSON&amp;rdquo; field.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/grafana-dashboard-import.png&#34; alt=&#34;Grafana dashboard import&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click &amp;ldquo;Load&amp;rdquo; to load the data and then &amp;ldquo;Import&amp;rdquo; to import the dashboard. The
new dashboard should appear in Grafana, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/grafana-mysql-dashboard.png&#34; alt=&#34;Grafana MySQL dashboard&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Connect to the MariaDB service in the first &amp;ldquo;data producer&amp;rdquo; cluster and
perform some actions, such as creating a database, adding records to a table
and executing a query. Perform similar actions in the second &amp;ldquo;data producer&amp;rdquo;
cluster. You should see your activity in each cluster reflected in the MySQL
Overview chart in Grafana, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/grafana-metrics.png&#34; alt=&#34;MariaDB metrics in Grafana&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;You can view metrics from individual master and slave nodes in each cluster by
selecting a different host in the &amp;ldquo;Host&amp;rdquo; drop down of the dashboard, as shown
below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/grafana-hosts.png&#34; alt=&#34;MariaDB hosts in Grafana&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can now continue adding more applications to your clusters. So long as you
enable Prometheus metrics and a Prometheus Operator ServiceMonitor for each
deployment, Thanos will continuously receive and aggregate the metrics and you
can inspect them using Grafana.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;p&gt;To learn more about the topics discussed in this guide, use the links below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/prometheus-operator&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Prometheus Operator Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/thanos&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Thanos Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/grafana&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Grafana Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/mariadb&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami MariaDB Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/ingress/tree/master/controllers/nginx&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;NGINX Ingress controller documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/tutorials/secure-kubernetes-services-with-ingress-tls-letsencrypt/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Secure Kubernetes Services with Ingress, TLS and Let&amp;rsquo;s Encrypt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Assign Pods to Nodes With Bitnami Helm Chart Affinity Rules</title>
      
      <link>/guides/kubernetes/assign-pods-to-nodes-with-bitnami-helm-chart-affinity-rules/</link>
      <pubDate>Tue, 13 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>/guides/kubernetes/assign-pods-to-nodes-with-bitnami-helm-chart-affinity-rules/</guid>
      <description>

        
        &lt;p&gt;First published on &lt;a href=&#34;https://docs.bitnami.com/tutorials/assign-pod-nodes-helm-affinity-rules/&#34;&gt;https://docs.bitnami.com/tutorials/assign-pod-nodes-helm-affinity-rules/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;When you install an application in a Kubernetes cluster, the &lt;a href=&#34;https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubernetes scheduler&lt;/a&gt; decides in which nodes the application pods will be installed unless certain constraints are defined. For example, Kubernetes scheduler may decide to install application pods in a node with more available memory. This is mostly useful except when cluster administrators prefer to distribute a group of pods across the cluster in a specific manner. For this use case, they need a tool that can force Kubernetes to follow custom rules specified by the user.&lt;/p&gt;
&lt;p&gt;Affinity rules supply a way to force the scheduler to follow specific rules that determine where pods should be distributed. To help users to implement affinity rules, Bitnami has enhanced its Helm charts by including opinionated affinities in their manifest files. Cluster administrators now only need to define the criteria to be followed by the scheduler when placing application pods in cluster nodes. They can then enable this feature via a simple install-time parameter&lt;/p&gt;
&lt;p&gt;This tutorial will demonstrate the available affinity rules and how they can be adapted to your needs.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and Prerequisites&lt;/h2&gt;
&lt;p&gt;This article assumes that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have a Google Cloud account. &lt;a href=&#34;https://cloud.google.com/free&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Register for a Google Cloud account&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a Kubernetes cluster running with Helm v3.x and &lt;code&gt;kubectl&lt;/code&gt; installed. &lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about getting started with Kubernetes and Helm using different cloud providers&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;callout td-box--gray-darkest p-3 mx-5 border-bottom border-right border-left border-top&#34;&gt;
    &lt;p&gt;This guide uses a Kubernetes cluster created in GKE. These steps are the same for all Kubernetes engines. They donâ€™t work, however, in Minikube, since with Minikube you only can create single-node clusters.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;how-affinity-rules-work-in-bitnami-helm-charts&#34;&gt;How Affinity Rules Work in Bitnami Helm Charts&lt;/h2&gt;
&lt;p&gt;All Bitnami infrastructure solutions available in the &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Helm charts catalog&lt;/a&gt; now include pre-defined affinity rules exposed through the &lt;code&gt;podAffinityPreset&lt;/code&gt; and &lt;code&gt;podAntiAffinitypreset&lt;/code&gt; parameters in their &lt;code&gt;values.yml&lt;/code&gt; file:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/bitnami-helm-chart-affinity-rules/image-1.png&#34; alt=&#34;Pod affinity rules&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Pod affinity and anti-affinity rules allow you to define how the scheduler should behave when locating application pods in your cluster eligible nodes. Depending on the option you choose, the scheduler will behave as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;podAffinityPreset&lt;/code&gt; - Using the &lt;code&gt;podAffinity&lt;/code&gt; rule, the scheduler will locate a new pod on the same node where other pods with the same label are located. This approach is especially helpful to group under the same node pods that meet specific pre-defined patterns.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;podAntiAffinitypreset&lt;/code&gt; - Using the &lt;code&gt;podAntiAffinity&lt;/code&gt; parameter lets the scheduler locates one pod in each node. Thus, you will prevent locating a new pod on the same node as other pods are running. This option is convenient if your deployment will demand high availability.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Having the pods distributed across all nodes allows Kubernetes to ensure high availability of your cluster by keeping running the remaining nodes when one node fails.&lt;/p&gt;
&lt;p&gt;These are the values you can set for both pod affinity and anti-affinity rules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Soft&lt;/strong&gt; - Use this value to make the scheduler enforce a rule wherever it can be met (best-effort approach). If the rule cannot be met, the scheduler will deploy the required pods in the nodes with enough resources.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hard&lt;/strong&gt; - Use this value to make the scheduler enforce a rule. This means that if there are remaining pods that do not comply with the pre-defined rule, they won&amp;rsquo;t be allocated in any node.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bitnami Helm charts have the &lt;code&gt;podAntiAffinity&lt;/code&gt; rule with the &lt;code&gt;soft&lt;/code&gt; value enabled by default. Hence, if there are not enough nodes to place one pod per node, it will leave the scheduler to decide where the remaining pods should be located.&lt;/p&gt;
&lt;p&gt;The following section shows two different use cases of configuring &lt;code&gt;podAntiaffinity&lt;/code&gt; parameter.&lt;/p&gt;
&lt;h2 id=&#34;deploying-a-chart-using-the-podantiaffinity-rule&#34;&gt;Deploying a Chart Using the &lt;code&gt;podAntiAffinity&lt;/code&gt; Rule&lt;/h2&gt;
&lt;p&gt;The following examples illustrate how the &lt;code&gt;podAntiAffinity&lt;/code&gt; rule works in the context of the Bitnami MySQL Helm chart. They cover two use cases: installing the chart with the default &lt;code&gt;podAntiAffinity&lt;/code&gt; value and changing the &lt;code&gt;podAntiAffinity&lt;/code&gt; value from &lt;code&gt;soft&lt;/code&gt; to &lt;code&gt;hard&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;use-case-1-install-the-chart-with-the-default-podantiaffinity-value&#34;&gt;Use Case 1: Install the Chart with the Default &lt;code&gt;podAntiaffinity&lt;/code&gt; Value&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Install the Bitnami Helm charts repository by running:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;helm repo add bitnami https://charts.bitnami.com/bitnami 
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Deploy the MySQL Helm chart by executing the command below. Note that the chart will deploy the cluster with three nodes and two replicas - one primary and one secondary. To make the scheduler follow the default &lt;code&gt;podAntiAffinity&lt;/code&gt; rule, set the parameter as follows:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;helm install mysql bitnami/mysql --set architecture=replication --set secondary.replicaCount=2 --set secondary.podAntiAffinityPreset=soft 
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Verify the cluster by checking the nodes. Use the following command to list the connected nodes:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;kubectl get nodes 
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;You will see an output message like this:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/bitnami-helm-chart-affinity-rules/image-2.png&#34; alt=&#34;Example kubectl get pods output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Three nodes are running in the cluster.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Check how the pods are distributed. Execute the command below:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;kubectl get pods -o wide 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/bitnami-helm-chart-affinity-rules/image-3.png&#34; alt=&#34;Example kubectl get pods -o wide output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;As expected, both the primary and the secondary pods are in different nodes.&lt;/p&gt;
&lt;p&gt;To verify how the scheduler acts when the &lt;em&gt;soft&lt;/em&gt; value is defined, scale up the cluster by setting the number of secondary replicas to three instead of one. Thus, the resulting number of pods will be four, instead of two.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;To scale the cluster, use the command below:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;kubectl scale sts/mysql-secondary --replicas 3 
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Check the pods by running again the &lt;code&gt;kubectl get pods&lt;/code&gt; command. The &lt;code&gt;soft&lt;/code&gt; value left the scheduler to locate the remaining pod that didn&amp;rsquo;t comply with the &amp;ldquo;one pod per node&amp;rdquo; rule:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/bitnami-helm-chart-affinity-rules/image-4.png&#34; alt=&#34;Example kubectl get pods output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Note that two pods are running in the same node.&lt;/p&gt;
&lt;h3 id=&#34;use-case-2-change-the-podantiaffinity-value-from-soft-to-hard&#34;&gt;Use Case 2: Change the &lt;code&gt;podAntiAffinity&lt;/code&gt; Value from Soft to Hard&lt;/h3&gt;
&lt;p&gt;To try the &lt;code&gt;hard&lt;/code&gt; type of the &lt;code&gt;podAntiAffinity&lt;/code&gt; rule, deploy the chart again by changing the &lt;code&gt;secondary.podAntiAffinityPreset&lt;/code&gt; value from &lt;code&gt;soft&lt;/code&gt; to &lt;code&gt;hard&lt;/code&gt; as shown below. The chart will deploy the cluster with three nodes and two replicas - one primary and one secondary.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm install mysql-hard bitnami/mysql --set architecture=replication --set secondary.replicaCount=2 --set secondary.podAntiAffinityPreset=hard
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Check the nodes and the pods by running the &lt;code&gt;kubectl get nodes&lt;/code&gt; and the &lt;code&gt;kubectl get pods â€“o wide&lt;/code&gt; commands:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/bitnami-helm-chart-affinity-rules/image-5.png&#34; alt=&#34;Example kubectl get pods -o wide output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Both the primary and secondary pods are running in the same node.&lt;/p&gt;
&lt;p&gt;To verify how the scheduler acts when the &lt;code&gt;hard&lt;/code&gt; value is defined, scale up the cluster by setting the number of secondary replicas to three instead of one. Thus, the resulting number of pods will be four, instead of two.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Scale up the cluster by executing the command below:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;kubectl scale sts/mysql-hard secondary --replicas 3 
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;When checking the pods, you will see that the scheduler has ignored the &amp;ldquo;one pod per node&amp;rdquo; rule and also located only as many pods as there are nodes. The fourth pod was not deployed as there are only three nodes available.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/bitnami-helm-chart-affinity-rules/image-6.png&#34; alt=&#34;Example kubectl get pods -o wide output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;podAntiAffinity&lt;/code&gt; rule is an easy way to control how application pods will be distributed across the cluster nodes when installing a Helm chart. Deploy your favorite Bitnami applications and enable this feature via a simple install-time parameter.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful Links&lt;/h2&gt;
&lt;p&gt;To learn more about the topics discussed in this article, use the links below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Helm charts catalog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Helm charts documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubernetes scheduler documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubernetes pod affinity documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Blog: Kubeapps Meets Tanzu Kubernetes Grid: a New Release is out</title>
      
      <link>/blog/kubeapps-meets-tanzu-kubernetes-grid-a-new-release-is-out/</link>
      <pubDate>Fri, 11 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/kubeapps-meets-tanzu-kubernetes-grid-a-new-release-is-out/</guid>
      <description>

        
        &lt;p&gt;&lt;em&gt;Special thanks to Antonio Gamez and Michael Nelson, members of the VMware Kubeapps Team&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The latest version of &lt;a href=&#34;https://github.com/kubeapps/kubeapps/releases/tag/v2.3.2&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubeapps (v.2.3.2)&lt;/a&gt; is now available for deployment on VMware Tanzuâ„¢ Kubernetes Gridâ„¢ (TKG) workload clusters. VMware Tanzu users already benefit from deploying Kubeapps in several environments and, now with a little configuration Kubeapps can be integrated with your TKG workload cluster.&lt;/p&gt;
&lt;p&gt;In addition to this capability,  Kubeapps also features full compatibility with the latest versions of &lt;a href=&#34;https://pinniped.dev/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Pinniped&lt;/a&gt; which means that it can be used with &lt;a href=&#34;https://github.com/kubeapps/kubeapps/blob/7aa7c579251e0fb5b446ab71a67d8d847d6ce843/docs/user/using-an-OIDC-provider-with-pinniped.md#enabling-oidc-login-in-managed-clusters&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;any OIDC provider for your TKG clusters and even in managed clusters&lt;/a&gt; such as Azure Kubernetes Service (AKS) and Google Kubernetes Engine (GKE).&lt;/p&gt;
&lt;p&gt;Want to know more? Keep reading to discover the latest capabilities of Kubeapps that will enable developers and admin clusters to deploy and manage trusted open-source content in TKG clusters.&lt;/p&gt;
&lt;h2 id=&#34;a-bit-of-history-what-is-kubeapps&#34;&gt;A bit of History: What is Kubeapps?&lt;/h2&gt;
&lt;p&gt;Kubeapps is an in-cluster web-based application that enables users with a one-time installation to deploy, manage, and upgrade applications on a Kubernetes cluster.&lt;/p&gt;
&lt;p&gt;This past year, the Kubeapps team has added key new features to support different use cases and scenarios. Firstly, we added &lt;a href=&#34;https://blog.bitnami.com/2020/05/kubeapps-now-supports-private-docker-registries.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;support for private Helm and Docker registries&lt;/a&gt; and later, in &lt;a href=&#34;https://blog.bitnami.com/2020/10/Kubeapps-2.0.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubeapps version 2.0&lt;/a&gt;, we built support to run Kubeapps on various VMware Tanzu â„¢ platforms such as Tanzu â„¢ Mission Control, vSphere and Tanzu â„¢ Kubernetes Grid.&lt;/p&gt;
&lt;p&gt;With Kubeapps you can:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Customize deployments through an intuitive, form-based user interface&lt;/li&gt;
&lt;li&gt;Inspect, upgrade and delete applications installed in the cluster&lt;/li&gt;
&lt;li&gt;Browse and deploy from public or private chart repositories including VMware Marketplaceâ„¢ and Bitnami Application Catalog&lt;/li&gt;
&lt;li&gt;Secure authentication to Kubeapps using an OAuth2/OIDC provider such as the VMware Cloud Service Portal&lt;/li&gt;
&lt;li&gt;Secure authorization based on Kubernetes role-based access control&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;key-features-of-kubeapps-232&#34;&gt;Key Features of Kubeapps 2.3.2&lt;/h2&gt;
&lt;p&gt;In this Kubeapps release, we have focused on delivering key user experience features including the capability to enable Tanzu users to deploy Kubeapps directly as a Helm chart in TKG workload clusters. This version is tested and validated on the latest version of TKG (v1.3.1)&lt;/p&gt;
&lt;p&gt;Once Kubeapps is up and running, cluster admins will benefit from having :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SSO for Authentication with TKG using Pinniped by configuring an OIDC provider&lt;/li&gt;
&lt;li&gt;Ability to configure VMware Tanzuâ„¢ Application Catalog (TAC) as a private Chart repository;&lt;/li&gt;
&lt;li&gt;Capability to configure VMware Marketplace â„¢ Catalog and the Bitnami Application Catalog as public chart repositories;&lt;/li&gt;
&lt;li&gt;A customized user interface adapted to the Tanzu look and feel.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/blogs/kubeapps-232-release/kubeapps-tkg.png&#34; alt=&#34;alt_text&#34;  title=&#34;Kubeapps support for SSO Authentication&#34; /&gt;
&lt;em&gt;Kubeapps support for SSO Authentication&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;All these new capabilities are designed to offer a seamless experience between Kubeapps and Tanzu Kubernetes Grid clusters.&lt;/p&gt;
&lt;h2 id=&#34;how-can-i-configure-kubeapps-to-run-in-my-tkg-clusters&#34;&gt;How can I configure Kubeapps to run in my TKG clusters?&lt;/h2&gt;
&lt;p&gt;Tanzu users can execute these simple steps to gain the maximum advantage with this new version of Kubeapps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Configure your cluster to enable SSO for Authentication with TKG using Pinniped and integrate Kubeapps with the identity management provider&lt;/li&gt;
&lt;li&gt;Adjust the Kubeapps user interface to get a customized look and feel&lt;/li&gt;
&lt;li&gt;Configure role-based access control in Kubeapps (RBAC) to manage roles and permissions among the teams in your organization&lt;/li&gt;
&lt;li&gt;Deploy Kubeapps in the cluster&lt;/li&gt;
&lt;li&gt;Add public and private repositories to Kubeapps: the public VMware Marketplaceâ„¢ repository and your private &lt;a href=&#34;https://tanzu.vmware.com/application-catalog&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;VMware Tanzu Application Catalog&lt;/a&gt; for &lt;a href=&#34;https://tanzu.vmware.com/tanzu/advanced&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Tanzu Advanced&lt;/a&gt; repository&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;At this point your development team can start deploying, listing, removing and managing applications in your TKG clusters from the Kubeapps user interface with total confidence!&lt;/p&gt;
&lt;p&gt;Refer to the Kubeapps documentation to learn how to &lt;a href=&#34;https://github.com/kubeapps/kubeapps/tree/master/docs/step-by-step/kubeapps-on-tkg&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;deploy and configure Kubeapps on VMware Tanzu Kubernetes Grid.&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;support-and-resources&#34;&gt;Support and Resources&lt;/h2&gt;
&lt;p&gt;Since Kubeapps is an OSS project, support for this version of Kubeapps will be provided on a best-effort basis.&lt;/p&gt;
&lt;p&gt;For solving the problems you may have (including deployment support, operational support and bug fixes), please &lt;a href=&#34;https://github.com/kubeapps/kubeapps/issues&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;open an issue in the Kubeapps GitHub repository.&lt;/a&gt; A markdown template is provided by default to open new issues with the information requested to prioritize and respond to them as soon as possible.&lt;/p&gt;
&lt;p&gt;Also, if you want to contribute to the project, feel free to &lt;a href=&#34;https://github.com/kubeapps/kubeapps/pulls&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;send us a pull request,&lt;/a&gt; and the team will check it and guide you in the process for a successful merge.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubeapps/kubeapps/tree/master/docs&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;The Kubeapps documentation section&lt;/a&gt; is full of useful resources to help you get the best of the chart.&lt;/p&gt;
&lt;p&gt;Check out the step-by-step guide for &lt;a href=&#34;https://github.com/kubeapps/kubeapps/tree/master/docs/step-by-step/kubeapps-on-tkg&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;deploying and configuring Kubeapps on VMware Tanzuâ„¢ Kubernetes Gridâ„¢&lt;/a&gt; and the &lt;a href=&#34;https://docs.bitnami.com/tutorials/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami documentation tutorials site&lt;/a&gt; for improving your Kubernetes skills.&lt;/p&gt;
&lt;p&gt;For more information on VMware Tanzu Kubernetes Grid, refer to &lt;a href=&#34;https://docs.vmware.com/en/VMware-Tanzu-Kubernetes-Grid/index.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;its documentation page&lt;/a&gt;  where you will find handy information on managing your Kubernetes clusters.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      
      <title>Videos: Getting Started with Kubeapps</title>
      
      <link>/videos/kubeapps-gs/</link>
      <pubDate>Wed, 06 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/videos/kubeapps-gs/</guid>
      <description>

        
        
      </description>
    </item>
    
    <item>
      
      <title>Guides: Customize GitLab&#39;s Default Auto DevOps Pipeline with Bitnami&#39;s Helm Charts</title>
      
      <link>/guides/ci-cd/gitlab-customize-default/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/guides/ci-cd/gitlab-customize-default/</guid>
      <description>

        
        &lt;p&gt;&lt;a href=&#34;https://bitnami.com/stack/gitlab&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s GitLab CE stack&lt;/a&gt; is a popular solution for agile development teams, providing a secure and fully-functional GitLab instance for software development and deployment. GitLab CE includes a Continuous Integration and Delivery (CI/CD) system that can build, test, and deploy software updates as well as a private registry for Docker containers.&lt;/p&gt;
&lt;p&gt;Bitnami also provides &lt;a href=&#34;https://github.com/bitnami/charts&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm charts&lt;/a&gt; for common applications. These charts make it easy to run applications on Kubernetes and are secure, up-to-date and built in conformance with current best practices. By combining these Helm charts with GitLab&amp;rsquo;s CI/CD system, developers can quickly create custom deployment pipelines on Kubernetes infrastructure for development, testing and production scenarios.&lt;/p&gt;
&lt;p&gt;This guide shows you how to integrate Bitnami&amp;rsquo;s Helm charts with GitLab&amp;rsquo;s Auto DevOps pipeline and create custom deployments on Kubernetes. With this configuration, every change to the application code in GitLab is automatically built as a Docker container and deployed to the Kubernetes cluster using &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Node.js Helm chart&lt;/a&gt;. Bitnami&amp;rsquo;s Helm charts support a number of additional parameters to ease this integration, including the ability to configure each deployment such that it is available at a public IP address for review and test.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and prerequisites&lt;/h2&gt;
&lt;p&gt;This guide assumes that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;You have deployed the &lt;a href=&#34;https://bitnami.com/stack/gitlab&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami GitLab CE stack&lt;/a&gt; on a cloud server, connected it with your Kubernetes cluster and configured a default Auto DevOps pipeline for your application. For more information on how to complete these tasks, refer to our &lt;a href=&#34;https://docs.bitnami.com/tutorials/create-ci-cd-pipeline-gitlab-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;detailed tutorial on creating a CI/CD pipeline with GitLab and Kubernetes&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Your application is a Node.js application and the application code is hosted in a GitLab repository. &lt;a href=&#34;https://docs.bitnami.com/tutorials/create-ci-cd-pipeline-gitlab-kubernetes/#step-6-commit-test-and-repeat&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Obtain the sample application&amp;rsquo;s code and the Dockerfile to build it&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Other programming languages or frameworks will require a different chart, but the broad steps to configure and integrate a custom Helm chart with GitLab&amp;rsquo;s Auto DevOps will remain the same.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You have &lt;a href=&#34;https://git-scm.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Git&lt;/a&gt; and &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes#step-3-install-kubectl-command-line&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;em&gt;kubectl&lt;/em&gt;&lt;/a&gt; installed and configured to work with your GitLab CE installation and Kubernetes cluster respectively.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-1-replace-the-default-auto-devops-helm-chart-with-a-custom-chart&#34;&gt;Step 1: Replace the default Auto DevOps Helm chart with a custom chart&lt;/h2&gt;
&lt;p&gt;GitLab configures the Auto DevOps pipeline with a default Helm chart, but it&amp;rsquo;s possible to override this with a custom chart by either adding a chart to your code repository or, for charts hosted externally, by setting various pipeline variables that tell GitLab how to obtain the chart. In this tutorial, since the assumption is that you&amp;rsquo;re using a Node.js application, the latter approach will be followed and GitLab will be configured to use the Bitnami Node.js chart from the Bitnami chart repository.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Navigate to the project&amp;rsquo;s &amp;ldquo;Settings -&amp;gt; CI/CD&amp;rdquo; page.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the &amp;ldquo;Variables&amp;rdquo; section, add the following variables and values:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;AUTO_DEVOPS_CHART=bitnami/node
AUTO_DEVOPS_CHART_REPOSITORY=https://charts.bitnami.com/bitnami
AUTO_DEVOPS_CHART_REPOSITORY_NAME=bitnami
HELM_RELEASE_NAME=myproject
HELM_UPGRADE_EXTRA_ARGS=--set fullnameOverride=myproject --set service.type=LoadBalancer --set getAppFromExternalRepository=false --set applicationPort=5000 --set image.pullSecrets={gitlab-registry} --set image.registry=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click &amp;ldquo;Save variables&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-customize-default/set-variables.png&#34; alt=&#34;GitLab Auto DevOps configuration&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Here is a quick explanation of what these variables do:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;AUTO_DEVOPS_CHART&lt;/em&gt; variable sets the name of the custom chart to use, while the &lt;em&gt;AUTO_DEVOPS_CHART_REPOSITORY&lt;/em&gt; and &lt;em&gt;AUTO_DEVOPS_CHART_REPOSITORY_NAME&lt;/em&gt; variables define the chart repository URL and chart repository name respectively.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;HELM_RELEASE_NAME&lt;/em&gt; variable sets the Helm release name.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;HELM_UPGRADE_EXTRA_ARGS&lt;/em&gt; variable sets the list of arguments to be passed to the custom chart (this varies per chart).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For the Bitnami Node.js chart, the parameters passed via the &lt;em&gt;HELM_UPGRADE_EXTRA_ARGS&lt;/em&gt; command are as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;fullnameOverride&lt;/em&gt; parameter configures the deployment name. It must be set to the same value as the &lt;em&gt;HELM_RELEASE_NAME&lt;/em&gt; variable, or else Auto DevOps will fail to recognize the deployment and mark the pipeline as failed.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;service.type&lt;/em&gt; parameter configures the deployment to be available at a public load balancer IP address so that it can be easily reviewed or tested.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;getAppFromExternalRepository&lt;/em&gt; parameter is set to &lt;em&gt;false&lt;/em&gt; because the application is already included in the generated container image and does not need to be downloaded from an external source.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;applicationPort&lt;/em&gt; parameter exposes the application on port 5000, which is the port configured for the application in the &lt;em&gt;Dockerfile&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;image.registry&lt;/em&gt; parameter is set to an empty value, because GitLab already provides its own image registry.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;image.pullSecrets&lt;/em&gt; parameter specifies the secret holding the GitLab registry credentials. The secret is already created by Auto DevOps.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can also view the &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/node#parameters&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;complete list of parameters supported by the chart&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Using a LoadBalancer service type will typically assign a static IP address for the deployment. Depending on your cloud provider&amp;rsquo;s policies, you may incur additional charges for this static IP address.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;step-2-commit-code-and-test-the-pipeline&#34;&gt;Step 2: Commit code and test the pipeline&lt;/h2&gt;
&lt;p&gt;At this point, you are ready to commit some code to the project and have GitLab test and deploy it using the Bitnami Helm chart. This tutorial assumes that you have a simple &amp;ldquo;Hello, world&amp;rdquo; application in Node.js, together with a Dockerfile to build it. If you don&amp;rsquo;t, you can &lt;a href=&#34;https://docs.bitnami.com/tutorials/create-ci-cd-pipeline-gitlab-kubernetes/#step-6-commit-test-and-repeat&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;obtain the sample application&amp;rsquo;s code and a Dockerfile to build it&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Commit a change to the application - for example, update the message &amp;ldquo;Hello world&amp;rdquo; in the &lt;em&gt;server.js&lt;/em&gt; file to &amp;ldquo;Yahoo world&amp;rdquo; - and push the change to GitLab:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;sed -i &amp;#39;s/Hello world/Yahoo world/g&amp;#39; server.js
git add .
git commit -m &amp;#34;Modified message text&amp;#34;
git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pushing this commit should automatically trigger the Auto DevOps pipeline in GitLab.&lt;/p&gt;
&lt;p&gt;In the first stage, GitLab will attempt to build a container image containing the application code using the provided Dockerfile. The container will be pushed to the internal GitLab registry. Here&amp;rsquo;s an example of the output you should see in this first stage:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-customize-default/pipeline-build.png&#34; alt=&#34;GitLab pipeline build output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Once the container image has been built and pushed, the second stage of the pipeline will attempt to deploy it to Kubernetes for review using Bitnami&amp;rsquo;s Node.js Helm chart. If successful, the stage output will display the commands you must run to obtain the load balancer IP address which you can browse to in order to see the application in action. Here&amp;rsquo;s an example of the output you should see in this second stage:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-customize-default/pipeline-deploy.png&#34; alt=&#34;GitLab pipeline deployment output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;If you run the commands shown in the output, you should see the load balancer IP address, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-customize-default/service.png&#34; alt=&#34;Service IP address&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Browse to the service IP address listed in the output and you should see the output of the Node.js application, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-customize-default/example-1.png&#34; alt=&#34;Example output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;At this point, you have successfully customized the default Auto DevOps pipeline provided by GitLab to use Bitnami&amp;rsquo;s Node.js Helm chart. Doing this ensures that your application deployments will always use a secure and up-to-date version of Node.js, while also giving you the flexibility to further customize the deployment as needed.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;p&gt;To learn more about the topics discussed in this guide, use the links below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/general/apps/gitlab/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami GitLab CE stack documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Node.js container&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Node.js Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;GitLab documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Create a Continuous Integration Pipeline with GitLab and Kubernetes</title>
      
      <link>/guides/ci-cd/gitlab-auto-devops/</link>
      <pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/guides/ci-cd/gitlab-auto-devops/</guid>
      <description>

        
        &lt;p&gt;As development velocity increases, it&amp;rsquo;s now become essential for enterprises to have a reliable and readily-available Continuous Integration/Continuous Delivery (CI/CD) pipeline integrated with cloud infrastructure. But although the requirements of such infrastructure are well understood, setting up this pipeline is still a complex task involving knowledge of cloud platforms, containerization tools like Docker, Docker Compose and others, container orchestration tools like Kubernetes and Helm, and DevOps tools and techniques.&lt;/p&gt;
&lt;p&gt;Bitnami eases the task of building an enterprise-ready CI/CD pipeline with its application stacks and container images.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://bitnami.com/stack/gitlab&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s GitLab CE stack&lt;/a&gt; lets you deploy a secure and fully-functional GitLab instance on the cloud in a matter of minutes and integrate it with a Kubernetes cluster.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://bitnami.com/containers&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s containers&lt;/a&gt; for &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Node.js&lt;/a&gt;, &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-ruby&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Ruby&lt;/a&gt;, &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-java&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Java&lt;/a&gt;  and others makes it easy to containerize your applications in a secure and reliable manner.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Put the two together, and you have everything you need to create a modern, enterprise-grade CI/CD pipeline that leverages the scalability of Kubernetes with the flexibility of GitLab and the development agility of Bitnami containers. This guide walks you through the process.&lt;/p&gt;
&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;This guide shows you how to set up a CI/CD pipeline between GitLab (deployed using the &lt;a href=&#34;https://bitnami.com/stack/gitlab&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami GitLab CE stack&lt;/a&gt;) and a Kubernetes cluster with GitLab&amp;rsquo;s Auto DevOps feature. With this configuration, every change to application code is automatically built as a Docker container (based on a &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Node.js base container&lt;/a&gt;) and deployed to the Kubernetes cluster for review and test.&lt;/p&gt;
&lt;p&gt;Communication and monitoring between the GitLab deployment and the Kubernetes cluster is achieved through the use of &lt;a href=&#34;https://helm.sh&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm&lt;/a&gt;, &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Ingress&lt;/a&gt; and &lt;a href=&#34;https://docs.gitlab.com/runner/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;GitLab Runner&lt;/a&gt;. When GitLab deploys each built container to the cluster, it also makes it available for review at an auto-generated sub-domain of your main domain name.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and prerequisites&lt;/h2&gt;
&lt;p&gt;This guide makes the following assumptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have deployed the Bitnami GitLab CE stack on a cloud server and have the GitLab CE administrator credentials. Learn about &lt;a href=&#34;https://docs.bitnami.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;deploying Bitnami applications&lt;/a&gt; and &lt;a href=&#34;https://docs.bitnami.com/general/faq/get-started/find-credentials/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;obtaining credentials&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a multi-node Kubernetes cluster running. &lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about deploying a Kubernetes cluster on different cloud platforms&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have the &lt;em&gt;kubectl&lt;/em&gt; command line (kubectl CLI) installed. &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes#step-3-install-kubectl-command-line&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about &lt;em&gt;kubectl&lt;/em&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have &lt;a href=&#34;https://git-scm.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Git&lt;/a&gt; installed.&lt;/li&gt;
&lt;li&gt;You have a domain name and the ability to configure a wildcard DNS record for that domain name. &lt;a href=&#34;https://en.wikipedia.org/wiki/Wildcard_DNS_record&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about wildcard DNS records&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have an SSH key pair which you can use for repository commits. To generate a new SSH key pair, use PuTTYgen (Windows) or the &lt;em&gt;ssh-keygen&lt;/em&gt; command (Linux and Mac OS X). Learn about &lt;a href=&#34;http://winscp.net/eng/docs/ui_puttygen&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;PuTTYgen&lt;/a&gt; and &lt;a href=&#34;http://www.macworld.co.uk/how-to/mac-software/how-generate-ssh-keys-3521606/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;em&gt;ssh-keygen&lt;/em&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-1-configure-dns-and-ssl-for-gitlab&#34;&gt;Step 1: Configure DNS and SSL for GitLab&lt;/h2&gt;
&lt;p&gt;As a first step, you must configure a domain name and SSL certificate for GitLab, such that browsing to the domain directs you to a secure page for your GitLab deployment. If you already have an SSL certificate for your domain, you can continue to use that or, if not, you can follow the approach below and generate a free Let&amp;rsquo;s Encrypt SSL certificate.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Follow the instructions to &lt;a href=&#34;https://docs.bitnami.com/general/faq/configuration/configure-custom-domain/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;configure a custom domain for GitLab&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;While logged in to the server console, &lt;a href=&#34;https://docs.bitnami.com/general/apps/gitlab/administration/generate-configure-certificate-letsencrypt/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;manually generate and install a Let&amp;rsquo;s Encrypt certificate using &lt;em&gt;lego&lt;/em&gt;&lt;/a&gt; as described in our guide.&lt;/li&gt;
&lt;li&gt;Test the configuration by browsing to &lt;em&gt;https://DOMAIN&lt;/em&gt; (replace the DOMAIN placeholder with the correct domain name) and confirming that you see a secure GitLab login page, as shown below:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/gitlab-ssl.png&#34; alt=&#34;GitLab secure login&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;step-2-configure-and-activate-the-gitlab-registry&#34;&gt;Step 2: Configure and activate the GitLab registry&lt;/h2&gt;
&lt;p&gt;The next step is to activate the GitLab registry, as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Log in to the server console using SSH (if you&amp;rsquo;re not already logged in).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Edit the &lt;em&gt;/etc/gitlab/gitlab.rb&lt;/em&gt; file and uncomment and update the &lt;em&gt;registry_external_url&lt;/em&gt; parameter as below, remembering to replace the DOMAIN placeholder with the GitLab domain name:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;registry_external_url &amp;#39;https://DOMAIN:5005&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the same file, uncomment and update the &lt;em&gt;external_url&lt;/em&gt; parameter as below, replacing the DOMAIN placeholder with the GitLab domain name:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;external_url &amp;#39;https://DOMAIN&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Save your changes to the file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Configure the GitLab registry to use the SSL certificates generated in the previous step. Replace the DOMAIN placeholder with the GitLab domain name.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;cd /etc/gitlab/ssl
sudo ln -sf server.crt DOMAIN.crt
sudo ln -sf server.key DOMAIN.key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Execute the commands below to reconfigure and restart GitLab with the changes.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;sudo gitlab-ctl reconfigure
sudo /opt/bitnami/ctlscript.sh restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Open port 5005 in the server firewall so that GitLab can connect to, and push built containers, to its internal registry. &lt;a href=&#34;https://docs.bitnami.com/general/faq/administration/use-firewall/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about opening firewall ports for your cloud platform&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-3-create-a-new-gitlab-project&#34;&gt;Step 3: Create a new GitLab project&lt;/h2&gt;
&lt;p&gt;You can now log in to GitLab and prepare a new project. This project will host the code that you will eventually run through your CI/CD pipeline to build and deploy on Kubernetes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Browse to your GitLab domain and log in using the administrator credentials.&lt;/li&gt;
&lt;li&gt;On the welcome page, select the &amp;ldquo;Create a project&amp;rdquo; option.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/create-project.png&#34; alt=&#34;GitLab project creation&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Enter a name and slug for your project. Set the visibility level to &amp;ldquo;Internal&amp;rdquo;. Click &amp;ldquo;Create project&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/configure-project.png&#34; alt=&#34;GitLab project creation&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Your project is created and you should see the project page, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/new-project.png&#34; alt=&#34;GitLab project page&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Click the &amp;ldquo;Clone&amp;rdquo; button and note the clone URL for the repository, which will be needed in &lt;a href=&#34;#step-6-commit-test-and-repeat&#34;&gt;Step 6&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/project-clone-url.png&#34; alt=&#34;GitLab project clone URL&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Before you can commit any code to the project repository, you must add your SSH key to your profile, as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Click your user profile icon in the top right corner of the navigation bar.&lt;/li&gt;
&lt;li&gt;Select the &amp;ldquo;Settings&amp;rdquo; menu icon.&lt;/li&gt;
&lt;li&gt;On the &amp;ldquo;User Settings&amp;rdquo; page, select the &amp;ldquo;SSH Keys&amp;rdquo; menu item.&lt;/li&gt;
&lt;li&gt;Paste the public key component of your SSH key pair in the &amp;ldquo;Key&amp;rdquo; field. Add an optional label and click the &amp;ldquo;Add Key&amp;rdquo; button to save the changes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/add-ssh-key.png&#34; alt=&#34;GitLab key addition&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;step-4-configure-a-kubernetes-cluster-for-the-project&#34;&gt;Step 4: Configure a Kubernetes cluster for the project&lt;/h2&gt;
&lt;p&gt;GitLab comes with built-in support for Kubernetes, making it easy to build and test your projects using a Kubernetes cluster. &lt;a href=&#34;https://docs.gitlab.com/ee/user/project/clusters/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about Kubernetes support in GitLab&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;First, allow outbound requests from GitLab hooks and services, as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Navigate to the GitLab administration panel by selecting the &amp;ldquo;Admin Area&amp;rdquo; link.&lt;/li&gt;
&lt;li&gt;Navigate to the &amp;ldquo;Settings -&amp;gt; Network&amp;rdquo; page and select the &amp;ldquo;Outbound requests&amp;rdquo; section.&lt;/li&gt;
&lt;li&gt;Tick the checkboxes to allow requests to the local network from hooks and services.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/allow-network-requests.png&#34; alt=&#34;GitLab network requests&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Then, configure your Kubernetes cluster in GitLab by following these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use the &lt;em&gt;kubectl&lt;/em&gt; command-line tool to obtain the following details for your Kubernetes cluster using the &lt;a href=&#34;https://docs.gitlab.com/ee/user/project/clusters/#add-existing-kubernetes-cluster&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;instructions in the GitLab documentation&lt;/a&gt;:
&lt;ul&gt;
&lt;li&gt;Cluster API URL&lt;/li&gt;
&lt;li&gt;Cluster CA certificate&lt;/li&gt;
&lt;li&gt;Cluster service token&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;From the project page in GitLab, select the &amp;ldquo;Operations -&amp;gt; Kubernetes&amp;rdquo; menu item.&lt;/li&gt;
&lt;li&gt;On the resulting page, click the &amp;ldquo;Add Kubernetes cluster&amp;rdquo; button.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/add-cluster.png&#34; alt=&#34;GitLab cluster configuration&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Select the &amp;ldquo;Add existing cluster&amp;rdquo; tab.&lt;/li&gt;
&lt;li&gt;Enter a name for your cluster with the API URL, CA certificate and server token obtained already. Check the boxes for &amp;ldquo;RBAC-enabled&amp;rdquo; cluster and &amp;ldquo;GitLab-managed cluster&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/configure-cluster.png&#34; alt=&#34;GitLab cluster configuration&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Click the &amp;ldquo;Add Kubernetes cluster&amp;rdquo; button to save the changes.&lt;/li&gt;
&lt;li&gt;On the resulting page, find the &amp;ldquo;Applications&amp;rdquo; section and install Helm, followed by Ingress. Note the Ingress endpoint IP address generated after installing Ingress.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/install-helm-ingress.png&#34; alt=&#34;Helm/Ingress installation&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Configure a wildcard DNS record for your domain pointing to the Ingress IP address through your DNS provider&amp;rsquo;s control panel. Learn how to configure wildcard DNS records for popular DNS providers like &lt;a href=&#34;https://www.godaddy.com/help/set-up-wildcard-dns-3301&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;GoDaddy&lt;/a&gt;, &lt;a href=&#34;https://www.namecheap.com/support/knowledgebase/article.aspx/597/2237/how-can-i-set-up-a-catchall-wildcard-subdomain&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;NameCheap&lt;/a&gt; and &lt;a href=&#34;https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html#domain-name-format-asterisk&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;AWS Route53&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Enter the base domain name used by the wildcard DNS record in the &amp;ldquo;Base domain&amp;rdquo; field in your GitLab Kubernetes cluster configuration. For example, if you configured a wildcard DNS record for *&lt;em&gt;.example.com&lt;/em&gt;, use &lt;em&gt;example.com&lt;/em&gt; as the base domain name. This will be the base domain used for all Auto DevOps review deployments. Click &amp;ldquo;Save changes&amp;rdquo; to save the changes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/configure-base-domain.png&#34; alt=&#34;GitLab base domain configuration&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Return to the &amp;ldquo;Applications&amp;rdquo; section and install Cert-Manager. Remember to provide a valid email address so that Cert-Manager can correctly associate your certificates with your account.&lt;/li&gt;
&lt;li&gt;From the same &amp;ldquo;Applications&amp;rdquo; section, install GitLab Runner.&lt;/li&gt;
&lt;li&gt;Confirm that the runner is successfully installed and activated for the project by navigating to the project&amp;rsquo;s &amp;ldquo;Settings -&amp;gt; CI/CD&amp;rdquo; page and checking the status of the runner in the &amp;ldquo;Runners&amp;rdquo; section.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/check-runner-status.png&#34; alt=&#34;GitLab runner status&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;step-5-enable-auto-devops-for-the-project&#34;&gt;Step 5: Enable Auto DevOps for the project&lt;/h2&gt;
&lt;p&gt;Once the Kubernetes integration is complete and a runner is active, enable Auto DevOps for the project. Auto DevOps provides a preconfigured CI/CD pipeline which can be used to quickly get started with building, testing and deploying your project. &lt;a href=&#34;https://docs.gitlab.com/ee/topics/autodevops/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about Auto DevOps in GitLab&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To enable Auto DevOps for the project:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Navigate to the project&amp;rsquo;s &amp;ldquo;Settings -&amp;gt; CI/CD&amp;rdquo; page.&lt;/li&gt;
&lt;li&gt;In the &amp;ldquo;Auto DevOps&amp;rdquo; section, check the box for &amp;ldquo;Default to Auto DevOps pipeline&amp;rdquo; and select the &amp;ldquo;Continuous deployment to production&amp;rdquo; strategy.&lt;/li&gt;
&lt;li&gt;Click &amp;ldquo;Save changes&amp;rdquo; to enable the default pipeline.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/enable-auto-devops.png&#34; alt=&#34;GitLab Auto DevOps configuration&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The default Auto DevOps pipeline comes with various stages already configured, depending on which version of GitLab you are running. For example, there are stages to build, run tests, check code quality, scan for dependencies, review code, deploy code and test performance. This default pipeline is fully customizable and stages can be added or removed depending on your requirements, simply by adjusting pipeline variables. &lt;a href=&#34;https://docs.gitlab.com/ee/topics/autodevops/#environment-variables&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about the available variables&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This tutorial will focus on creating a very simple pipeline consisting of only two stages: build and deploy. To turn off the other stages included in the default pipeline, follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Navigate to the project&amp;rsquo;s &amp;ldquo;Settings -&amp;gt; CI/CD&amp;rdquo; page.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the &amp;ldquo;Variables&amp;rdquo; section, add the following three variables and values:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;TEST_DISABLED: true
CODE_QUALITY_DISABLED: true
PERFORMANCE_DISABLED: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click &amp;ldquo;Save variables&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/set-variables.png&#34; alt=&#34;GitLab Auto DevOps configuration&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;step-6-commit-test-and-repeat&#34;&gt;Step 6: Commit, test and repeat&lt;/h2&gt;
&lt;p&gt;At this point, you are ready to commit some code to the project and have GitLab test and deploy it. This tutorial will create a simple &amp;ldquo;Hello, world&amp;rdquo; application in Node.js and then configure a Dockerfile to run it with Bitnami&amp;rsquo;s Node.js development container image.&lt;/p&gt;
&lt;p&gt;Follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Create a working directory for the application on your local host:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;mkdir myproject
cd myproject
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;package.json&lt;/em&gt; file listing the dependencies for the project:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;simple-node-app&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;1.0.0&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Node.js on Docker&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;main&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;server.js&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;scripts&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;node server.js&amp;#34;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;dependencies&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;express&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;^4.13&amp;#34;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;server.js&lt;/em&gt; file for the Express application which returns a &amp;ldquo;Hello world&amp;rdquo; message on access:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;use strict&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;express&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;require&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;express&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Constants
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// App
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;express&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Hello world\n&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;console&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Running on http://localhost:&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;Dockerfile&lt;/em&gt; with the following content:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; bitnami/node:9 as builder&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENV&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_ENV&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;production&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Copy app&amp;#39;s source code to the /app directory&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; . /app&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# The application&amp;#39;s directory will be the working directory&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WORKDIR&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; /app&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Install Node.js dependencies defined in &amp;#39;/app/packages.json&amp;#39;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;RUN&lt;/span&gt; npm install&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; bitnami/node:9-prod&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENV&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_ENV&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;production&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; --from&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;builder /app /app&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WORKDIR&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; /app&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENV&lt;/span&gt; PORT &lt;span class=&#34;m&#34;&gt;5000&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;EXPOSE&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; 5000&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Start the application&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;CMD&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;npm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This multi-stage &lt;em&gt;Dockerfile&lt;/em&gt; creates a new image using Bitnami&amp;rsquo;s Node.js container image as base. It copies the application files to the container&amp;rsquo;s &lt;em&gt;/app&lt;/em&gt; directory and then runs &lt;em&gt;npm install&lt;/em&gt; to install Express. It then creates a production-ready container image and configures the application to listen to request on port 5000.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Exposing the application on port 5000 is a requirement of GitLab&amp;rsquo;s &lt;a href=&#34;https://gitlab.com/gitlab-org/charts/auto-deploy-app&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;default Helm chart&lt;/a&gt;, which is used to deploy the application to the cluster. This can be overridden if needed using a custom Helm chart. Read more in our tutorial on &lt;a href=&#34;https://docs.bitnami.com/tutorials/customize-ci-cd-pipeline-gitlab-bitnami-charts&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;using a custom Helm chart with the Auto DevOps pipeline&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Initialize a Git repository and commit and push the application code to GitLab. Replace the NAME and EMAIL-ADDRESS placeholders with your name and email address (if not already configured) and the CLONE-URL placeholder with the repository clone URL obtained in &lt;a href=&#34;#step-3-create-a-new-gitlab-project&#34;&gt;Step 3&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;git config --global user.name &amp;#34;NAME&amp;#34;
git config --global user.name &amp;#34;EMAIL-ADDRESS&amp;#34;
git init    
git remote add origin CLONE-URL
git add .
git commit -m &amp;#34;Initial commit&amp;#34;
git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pushing this commit should automatically trigger the Auto DevOps pipeline in GitLab. To see the pipeline in action, navigate to the project&amp;rsquo;s &amp;ldquo;CI/CD -&amp;gt; Pipelines&amp;rdquo; page and confirm that the pipeline is running, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/running-pipeline.png&#34; alt=&#34;GitLab pipeline&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;In the first stage, GitLab will attempt to build a container image containing the application code using the provided Dockerfile. The container will be pushed to the internal GitLab registry. Here&amp;rsquo;s an example of the output you should see in this first stage:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/pipeline-build.png&#34; alt=&#34;GitLab pipeline build output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Once the container image has been built and pushed, the second stage of the pipeline will attempt to deploy it to Kubernetes for review. If successful, the stage output will display a URL, which you can browse to in order to see the application in action. Here&amp;rsquo;s an example of the output you should see in this second stage:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/pipeline-deploy.png&#34; alt=&#34;GitLab pipeline deployment output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;If you browse to the application URL listed in the output, you should see the output of the Node.js app, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/example-1.png&#34; alt=&#34;Example output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;To test the CI/CD feature, make a change to the application - for example, update the message &amp;ldquo;Hello world&amp;rdquo; in the &lt;em&gt;server.js&lt;/em&gt; file to &amp;ldquo;Aloha world&amp;rdquo; - and push the change to GitLab.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;sed -i &amp;#39;s/Hello world/Aloha world/g&amp;#39; server.js
git add .
git commit -m &amp;#34;Modified message text&amp;#34;
git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The new commit should trigger the pipeline, causing a new build and deployment to take place, and the new application will be deployed on your cluster for review. As before, check pipeline status in GitLab, wait for it to complete and then browse to the application URL listed in the output of the second stage. You should see the revised output, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/example-2.png&#34; alt=&#34;Example output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;At this point, you have successfully created a simple CI/CD pipeline between GitLab and a Kubernetes cluster. You can now continue to enhance it by &lt;a href=&#34;https://docs.gitlab.com/ee/topics/autodevops/#features&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;adding new stages to the Auto DevOps pipeline&lt;/a&gt;, modifying how your code is deployed with a &lt;a href=&#34;https://docs.gitlab.com/ee/topics/autodevops/#custom-helm-chart&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;custom deployment Helm chart&lt;/a&gt;, or &lt;a href=&#34;https://docs.gitlab.com/ee/user/project/pipelines/schedules.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;configuring pipelines to run on a schedule&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;p&gt;To learn more about the topics discussed in this guide, use the links below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/general/apps/gitlab/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami GitLab CE stack documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node#&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Node.js container&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/general/faq/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami applications FAQ&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami documentation for Kubernetes deployments on different cloud platforms&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;GitLab documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Wildcard_DNS_record&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Wildcard DNS records&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Key generation with &lt;a href=&#34;http://winscp.net/eng/docs/ui_puttygen&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;PuTTYgen&lt;/a&gt; and &lt;a href=&#34;http://www.macworld.co.uk/how-to/mac-software/how-generate-ssh-keys-3521606/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;em&gt;ssh-keygen&lt;/em&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
