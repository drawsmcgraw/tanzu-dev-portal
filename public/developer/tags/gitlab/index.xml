<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>VMware Tanzu Developer Center – GitLab</title>
    <link>/tags/gitlab/</link>
    <description>Recent content in GitLab on VMware Tanzu Developer Center</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 11 Feb 2021 00:00:00 +0000</lastBuildDate>
    
	  <atom:link href="/tags/gitlab/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      
      <title>Guides: Deploy Cloud Native Apps Using GitLab CI/CD and Cloud Native Buildpacks</title>
      
      <link>/guides/ci-cd/gitlab-ci-cd-cnb/</link>
      <pubDate>Thu, 11 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/guides/ci-cd/gitlab-ci-cd-cnb/</guid>
      <description>

        
        &lt;p&gt;GitLab is a single application built from the ground up for all stages of the DevOps lifecycle that enables  product, development, QA, security, and operations teams to work on the same project concurrently. It provides teams with a single data store, user interface, and permission model across the DevOps lifecycle. Teams can collaborate and work on a project utilizing a single conversation, which significantly reduces cycle time, allowing developers to focus exclusively on building great software quickly.
This tutorial will explain how to create a sample CI/CD pipeline in GitLab and use Cloud Native Buildpacks to package the project source code into deployable containers.&lt;/p&gt;
&lt;h2 id=&#34;what-are-cloud-native-buildpacks&#34;&gt;What Are Cloud Native Buildpacks?&lt;/h2&gt;
&lt;p&gt;Traditionally, in the build stage of the CI/CD cycle, the source code and its dependencies are packaged into containers that can be deployed against any proper container-hosting platform, either on-prem or in the cloud. A Dockerfile is usually used to pass all the commands required to assemble an image.&lt;/p&gt;
&lt;p&gt;The challenge with this process—especially for large-scale deployments done frequently—is making sure that each and every build is identical and complies with the security, software currency, and build rules of the organization.&lt;/p&gt;
&lt;p&gt;This is where buildpacks come in. A buildpack represents a package of all the tools and scripts required to produce a &lt;a href=&#34;https://www.opencontainers.org&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;standards-based&lt;/a&gt;, compliant container runtime.  The result is that developers no longer need to worry about maintaining Dockerfiles, and operators can make sure that all the containers are built using standard, preconfigured, tested, and approved images.
Not only that, because the software development is now abstracted from the underlying build process, it is possible to run a complete rebase for a whole environment (dev, test, staging, production) whether as part of a planned OS upgrade/patching process or in response to a newly identified vulnerability.&lt;/p&gt;
&lt;h2 id=&#34;how-to-use-cloud-native-buildpacks-with-gitlab-cicd&#34;&gt;How to Use Cloud Native Buildpacks with GitLab CI/CD&lt;/h2&gt;
&lt;p&gt;GitLab pipelines are defined in the &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; file; they consist of one or more jobs grouped into stages. If no stages are defined in a pipeline, the following three are assumed: build, test, and deploy. The jobs defined in the &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; file handle the CI/CD tasks required to get the code built, tested, verified, staged, and deployed to one or more target platforms.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-ci-cd-cnb/screenshots/image3.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;h3 id=&#34;create-a-new-project-in-gitlab-saas--or-using-your-gitlab-instance-if-you-have-a-self-managed-one&#34;&gt;Create a New Project in GitLab SaaS  (or Using Your GitLab Instance If You Have a Self-Managed One)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Log in to GitLab.com.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click on “New Project.”&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-ci-cd-cnb/screenshots/image8.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;As we are going to use Cloud Native Buildpacks, let’s create the new project based on the Spring project template by clicking “Create from Template” and then choosing the Spring template. This will create a sample Java Spring project, which by default will include a Dockerfile.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-ci-cd-cnb/screenshots/image10.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-ci-cd-cnb/screenshots/image12.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;As we are going to use a buildpack to build the project, let’s rename the Dockerfile to &lt;code&gt;backup-dockerfile&lt;/code&gt; to ensure it won’t be used during the build process. The easiest way to do this is to click the Web IDE link in the top right.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-ci-cd-cnb/screenshots/image5.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Click the down arrow next to &lt;code&gt;Dockerfile&lt;/code&gt;, and rename &lt;code&gt;Dockerfile&lt;/code&gt; to &lt;code&gt;backup-dockerfile&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-ci-cd-cnb/screenshots/image4.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;In GitLab, the project pipeline is configured in the &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; file. To add a pipeline file to the project, click the new file icon, and in the “Create New File” dialog click  &lt;code&gt;.gitlab-ci.yml&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-ci-cd-cnb/screenshots/image11.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-ci-cd-cnb/screenshots/image7.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;
&lt;p&gt;To add GitLab Auto DevOps templates, click the template dropdown and choose “Auto DevOps Template.”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This is the whole &lt;a href=&#34;https://docs.gitlab.com/ee/topics/autodevops/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;GitLab Auto DevOps&lt;/a&gt; template, which was built by GitLab engineers based on CI/CD best practices. Auto DevOps aims to simplify the setup and execution of a mature and modern software development lifecycle, but as using the whole Auto DevOps template covers every stage in the CI/CD lifecycle and requires a GitLab Ultimate license, we will trim down the &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; file to only include the build stage. To that end, remove all but the following in the &lt;code&gt;include&lt;/code&gt; section:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;include&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Jobs/Build.gitlab-ci.yml &lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# https://gitlab.com/gitlab-org/gitlab/blob/master/lib/gitlab/ci/templates/Jobs/Build.gitlab-ci.yml&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;
&lt;p&gt;In order to instruct the build job to use Cloud Native Buildpacks, add &lt;code&gt;AUTO_DEVOPS_BUILD_IMAGE_CNB_ENABLED: &amp;quot;true&amp;quot;&lt;/code&gt; under the variables section.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;By default, the &lt;code&gt;heroku/buildpacks:18&lt;/code&gt; builder will be used to build the output containers. This can be changed by assigning a different builder to the &lt;code&gt;AUTO_DEVOPS_BUILD_IMAGE_CNB_BUILDER&lt;/code&gt; variable, for example, &lt;code&gt;AUTO_DEVOPS_BUILD_IMAGE_CNB_BUILDER: paketobuildpacks/builder:base&lt;/code&gt;. If you have the &lt;code&gt;pack&lt;/code&gt; CLI installed locally, you can see all of the suggested buildpacks by running &lt;code&gt;pack builder suggest&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;Suggested builders:
	Google:                gcr.io/buildpacks/builder:v1      Ubuntu &lt;span class=&#34;m&#34;&gt;18&lt;/span&gt; base image with buildpacks &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; .NET, Go, Java, Node.js, and Python                                              
	Heroku:                heroku/buildpacks:18              heroku-18 base image with buildpacks &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; Ruby, Java, Node.js, Python, Golang, and PHP                                       
	Paketo Buildpacks:     paketobuildpacks/builder:base     Ubuntu bionic base image with buildpacks &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; Java, .NET Core, NodeJS, Go, Ruby, NGINX, and Procfile                        
	Paketo Buildpacks:     paketobuildpacks/builder:full     Ubuntu bionic base image with buildpacks &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; Java, .NET Core, NodeJS, Go, PHP, Ruby, Apache HTTPD, NGINX, and Procfile     
	Paketo Buildpacks:     paketobuildpacks/builder:tiny     Tiny base image &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;bionic build image, distroless-like run image&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; with buildpacks &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; Java Native Image and Go   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;Pass the environment variables to the running jobs. This can be accomplished several ways:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Directly adding them in the pipeline file (&lt;code&gt;.gitlab-ci.yml&lt;/code&gt;):&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-ci-cd-cnb/screenshots/image6.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Defining them on the pipeline level before running the pipeline:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-ci-cd-cnb/screenshots/image1.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Adding them under &amp;ldquo;Settings&amp;rdquo; in the left menu -&amp;gt; CI/CD, expanding the &amp;ldquo;Variables&amp;rdquo; tab, clicking the edit pen and changing the value to any other buildpack URL (diagram below), then triggering the pipeline again.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-ci-cd-cnb/screenshots/image2.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;Some buildpacks, like Google and Paketo, make the generated container available on port 8080. So if you are using the Gitlab Deploy template (part of GitLab Auto DevOps), you will need to change the listening port for the readiness probe from &lt;code&gt;5000&lt;/code&gt; (the default in the template) to &lt;code&gt;8080&lt;/code&gt;. This can be done easily by setting an environment variable named &lt;code&gt;HELM_UPGRADE_EXTRA_ARGS&lt;/code&gt; value to &lt;code&gt;--set service.internalPort=8080 --set service.externalPort=8080&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-ci-cd-cnb/screenshots/image9.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;h3 id=&#34;use-cloud-native-buildpacks-with-gitlab-in-gitlab-build-job-without-using-the-gitlab-build-template&#34;&gt;Use Cloud Native Buildpacks with GitLab in GitLab Build Job WITHOUT Using the GitLab Build Template&lt;/h3&gt;
&lt;p&gt;GitLab CI/CD also allows you to use your own build script if you so wish. Let’s look at a build script that reads the &lt;code&gt;AUTO_DEVOPS_BUILD_IMAGE_CNB_BUILDER&lt;/code&gt; environment variable to determine which buildpack to use, which we saw how to set in Step 11:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;build_using_passed_builder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;stage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;script&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;&amp;gt;- &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;if ! docker info &amp;amp;&amp;gt;/dev/null; then&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;if [ -z &amp;#34;$DOCKER_HOST&amp;#34; ] &amp;amp;&amp;amp; [ &amp;#34;$KUBERNETES_PORT&amp;#34; ]; then&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;export DOCKER_HOST=&amp;#39;tcp://localhost:2375&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;fi&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;fi&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;echo $AUTO_DEVOPS_BUILD_IMAGE_CNB_BUILDER&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;&amp;gt;- &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;if [  -z &amp;#34;$AUTO_DEVOPS_BUILD_IMAGE_CNB_BUILDER&amp;#34;]; then&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;export AUTO_DEVOPS_BUILD_IMAGE_CNB_BUILDER=&amp;#39;heroku/buildpacks:18&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;fi&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;wget https://github.com/buildpacks/pack/releases/download/v0.17.0/pack-v0.17.0-linux.tgz&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;tar -xvf pack-v0.17.0-linux.tgz&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;chmod +x pack &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;mv pack /usr/local/bin/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;pack build $IMAGE --builder $AUTO_DEVOPS_BUILD_IMAGE_CNB_BUILDER &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;docker push $IMAGE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let’s walk through this step by step to make sure we understand exactly what’s happening:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We first determine where Docker, which will be used to build our code, is running.&lt;/li&gt;
&lt;li&gt;We then look at the &lt;code&gt;AUTO_DEVOPS_BUILD_IMAGE_CNB_BUILDER&lt;/code&gt; environment variable to determine which buildpack to use. If this variable isn’t set, we default to using &lt;code&gt;heroku/buildpacks:18&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Next, we authenticate against Docker using the &lt;code&gt;CI_JOB_TOKEN&lt;/code&gt; variable provided automatically to us by GitLab.&lt;/li&gt;
&lt;li&gt;We then download the &lt;code&gt;pack&lt;/code&gt; CLI and make sure it has the proper permissions to make it executable.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;pack&lt;/code&gt; CLI is uses the buildpack defined in the &lt;code&gt;AUTO_DEVOPS_BUILD_IMAGE_CNB_BUILDER&lt;/code&gt; environment variable to build our code, tagging the container with the name we expect to be provided in the &lt;code&gt;IMAGE&lt;/code&gt; variable.&lt;/li&gt;
&lt;li&gt;Finally, we &lt;code&gt;docker push&lt;/code&gt; the image to the GitLab container registry.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you save this at &lt;code&gt;jobs/build.gitlab-ci.yml&lt;/code&gt;, for example, you can update your &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; file to use this custom build job instead, with the following change:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;include&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;jobs/build.gitlab-ci.yml&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;add-kubernetes-clusters-to-the-gitlab-project&#34;&gt;Add Kubernetes Clusters to the GitLab Project&lt;/h2&gt;
&lt;p&gt;Kubernetes clusters can be added to the GitLab project so that applications can be deployed to them directly from the CI/CD pipeline. To add to the K8s cluster project, please follow the steps in the &lt;a href=&#34;https://docs.gitlab.com/ee/user/project/clusters/add_remove_clusters.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Add and Removing Kubernetes Cluster&lt;/a&gt; guide.&lt;/p&gt;
&lt;h2 id=&#34;deploy-the-packaged-container-to-the-kubernetes-clusters&#34;&gt;Deploy the Packaged Container to the Kubernetes Clusters&lt;/h2&gt;
&lt;p&gt;GitLab automates and simplifies the deployment of containers to Kubernetes through the provided AutoDeploy template. Similar to the AutoBuild template, it’s based on CI/CD best practices and can save operators/developers the hassle of composing and maintaining long deployment scripts and &lt;a href=&#34;/guides/kubernetes/helm-what-is/&#34;&gt;Helm charts&lt;/a&gt;. To use the AutoDeploy template we’ll include the &lt;code&gt;Deploy.gitlab-ci.yml&lt;/code&gt; template under the “include” section in the &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; file, so it will look like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;include&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Jobs/Build.gitlab-ci.yml &lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# https://gitlab.com/gitlab-org/gitlab/blob/master/lib/gitlab/ci/templates/Jobs/Build.gitlab-ci.yml&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Jobs/Deploy.gitlab-ci.yml &lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# https://gitlab.com/gitlab-org/gitlab/blob/master/lib/gitlab/ci/templates/Jobs/Deploy.gitlab-ci.yml&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Including the template will once again kick off the pipeline, this time adding a second job to deploy to your Kubernetes cluster.
While the use of the AutoDeploy template requires a GitLab Ultimate license, you can get one by starting a &lt;a href=&#34;https://about.gitlab.com/free-trial/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;30-day trial license&lt;/a&gt;. Whether you use the AutoDeploy template or write your own build step, you can build CI/DI pipelines for your GitLab projects for free.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Customize GitLab&#39;s Default Auto DevOps Pipeline with Bitnami&#39;s Helm Charts</title>
      
      <link>/guides/ci-cd/gitlab-customize-default/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/guides/ci-cd/gitlab-customize-default/</guid>
      <description>

        
        &lt;p&gt;&lt;a href=&#34;https://bitnami.com/stack/gitlab&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s GitLab CE stack&lt;/a&gt; is a popular solution for agile development teams, providing a secure and fully-functional GitLab instance for software development and deployment. GitLab CE includes a Continuous Integration and Delivery (CI/CD) system that can build, test, and deploy software updates as well as a private registry for Docker containers.&lt;/p&gt;
&lt;p&gt;Bitnami also provides &lt;a href=&#34;https://github.com/bitnami/charts&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm charts&lt;/a&gt; for common applications. These charts make it easy to run applications on Kubernetes and are secure, up-to-date and built in conformance with current best practices. By combining these Helm charts with GitLab&amp;rsquo;s CI/CD system, developers can quickly create custom deployment pipelines on Kubernetes infrastructure for development, testing and production scenarios.&lt;/p&gt;
&lt;p&gt;This guide shows you how to integrate Bitnami&amp;rsquo;s Helm charts with GitLab&amp;rsquo;s Auto DevOps pipeline and create custom deployments on Kubernetes. With this configuration, every change to the application code in GitLab is automatically built as a Docker container and deployed to the Kubernetes cluster using &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Node.js Helm chart&lt;/a&gt;. Bitnami&amp;rsquo;s Helm charts support a number of additional parameters to ease this integration, including the ability to configure each deployment such that it is available at a public IP address for review and test.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and prerequisites&lt;/h2&gt;
&lt;p&gt;This guide assumes that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;You have deployed the &lt;a href=&#34;https://bitnami.com/stack/gitlab&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami GitLab CE stack&lt;/a&gt; on a cloud server, connected it with your Kubernetes cluster and configured a default Auto DevOps pipeline for your application. For more information on how to complete these tasks, refer to our &lt;a href=&#34;https://docs.bitnami.com/tutorials/create-ci-cd-pipeline-gitlab-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;detailed tutorial on creating a CI/CD pipeline with GitLab and Kubernetes&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Your application is a Node.js application and the application code is hosted in a GitLab repository. &lt;a href=&#34;https://docs.bitnami.com/tutorials/create-ci-cd-pipeline-gitlab-kubernetes/#step-6-commit-test-and-repeat&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Obtain the sample application&amp;rsquo;s code and the Dockerfile to build it&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Other programming languages or frameworks will require a different chart, but the broad steps to configure and integrate a custom Helm chart with GitLab&amp;rsquo;s Auto DevOps will remain the same.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You have &lt;a href=&#34;https://git-scm.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Git&lt;/a&gt; and &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes#step-3-install-kubectl-command-line&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;em&gt;kubectl&lt;/em&gt;&lt;/a&gt; installed and configured to work with your GitLab CE installation and Kubernetes cluster respectively.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-1-replace-the-default-auto-devops-helm-chart-with-a-custom-chart&#34;&gt;Step 1: Replace the default Auto DevOps Helm chart with a custom chart&lt;/h2&gt;
&lt;p&gt;GitLab configures the Auto DevOps pipeline with a default Helm chart, but it&amp;rsquo;s possible to override this with a custom chart by either adding a chart to your code repository or, for charts hosted externally, by setting various pipeline variables that tell GitLab how to obtain the chart. In this tutorial, since the assumption is that you&amp;rsquo;re using a Node.js application, the latter approach will be followed and GitLab will be configured to use the Bitnami Node.js chart from the Bitnami chart repository.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Navigate to the project&amp;rsquo;s &amp;ldquo;Settings -&amp;gt; CI/CD&amp;rdquo; page.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the &amp;ldquo;Variables&amp;rdquo; section, add the following variables and values:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;AUTO_DEVOPS_CHART=bitnami/node
AUTO_DEVOPS_CHART_REPOSITORY=https://charts.bitnami.com/bitnami
AUTO_DEVOPS_CHART_REPOSITORY_NAME=bitnami
HELM_RELEASE_NAME=myproject
HELM_UPGRADE_EXTRA_ARGS=--set fullnameOverride=myproject --set service.type=LoadBalancer --set getAppFromExternalRepository=false --set applicationPort=5000 --set image.pullSecrets={gitlab-registry} --set image.registry=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click &amp;ldquo;Save variables&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-customize-default/set-variables.png&#34; alt=&#34;GitLab Auto DevOps configuration&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Here is a quick explanation of what these variables do:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;AUTO_DEVOPS_CHART&lt;/em&gt; variable sets the name of the custom chart to use, while the &lt;em&gt;AUTO_DEVOPS_CHART_REPOSITORY&lt;/em&gt; and &lt;em&gt;AUTO_DEVOPS_CHART_REPOSITORY_NAME&lt;/em&gt; variables define the chart repository URL and chart repository name respectively.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;HELM_RELEASE_NAME&lt;/em&gt; variable sets the Helm release name.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;HELM_UPGRADE_EXTRA_ARGS&lt;/em&gt; variable sets the list of arguments to be passed to the custom chart (this varies per chart).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For the Bitnami Node.js chart, the parameters passed via the &lt;em&gt;HELM_UPGRADE_EXTRA_ARGS&lt;/em&gt; command are as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;fullnameOverride&lt;/em&gt; parameter configures the deployment name. It must be set to the same value as the &lt;em&gt;HELM_RELEASE_NAME&lt;/em&gt; variable, or else Auto DevOps will fail to recognize the deployment and mark the pipeline as failed.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;service.type&lt;/em&gt; parameter configures the deployment to be available at a public load balancer IP address so that it can be easily reviewed or tested.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;getAppFromExternalRepository&lt;/em&gt; parameter is set to &lt;em&gt;false&lt;/em&gt; because the application is already included in the generated container image and does not need to be downloaded from an external source.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;applicationPort&lt;/em&gt; parameter exposes the application on port 5000, which is the port configured for the application in the &lt;em&gt;Dockerfile&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;image.registry&lt;/em&gt; parameter is set to an empty value, because GitLab already provides its own image registry.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;image.pullSecrets&lt;/em&gt; parameter specifies the secret holding the GitLab registry credentials. The secret is already created by Auto DevOps.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can also view the &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/node#parameters&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;complete list of parameters supported by the chart&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Using a LoadBalancer service type will typically assign a static IP address for the deployment. Depending on your cloud provider&amp;rsquo;s policies, you may incur additional charges for this static IP address.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;step-2-commit-code-and-test-the-pipeline&#34;&gt;Step 2: Commit code and test the pipeline&lt;/h2&gt;
&lt;p&gt;At this point, you are ready to commit some code to the project and have GitLab test and deploy it using the Bitnami Helm chart. This tutorial assumes that you have a simple &amp;ldquo;Hello, world&amp;rdquo; application in Node.js, together with a Dockerfile to build it. If you don&amp;rsquo;t, you can &lt;a href=&#34;https://docs.bitnami.com/tutorials/create-ci-cd-pipeline-gitlab-kubernetes/#step-6-commit-test-and-repeat&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;obtain the sample application&amp;rsquo;s code and a Dockerfile to build it&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Commit a change to the application - for example, update the message &amp;ldquo;Hello world&amp;rdquo; in the &lt;em&gt;server.js&lt;/em&gt; file to &amp;ldquo;Yahoo world&amp;rdquo; - and push the change to GitLab:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;sed -i &amp;#39;s/Hello world/Yahoo world/g&amp;#39; server.js
git add .
git commit -m &amp;#34;Modified message text&amp;#34;
git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pushing this commit should automatically trigger the Auto DevOps pipeline in GitLab.&lt;/p&gt;
&lt;p&gt;In the first stage, GitLab will attempt to build a container image containing the application code using the provided Dockerfile. The container will be pushed to the internal GitLab registry. Here&amp;rsquo;s an example of the output you should see in this first stage:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-customize-default/pipeline-build.png&#34; alt=&#34;GitLab pipeline build output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Once the container image has been built and pushed, the second stage of the pipeline will attempt to deploy it to Kubernetes for review using Bitnami&amp;rsquo;s Node.js Helm chart. If successful, the stage output will display the commands you must run to obtain the load balancer IP address which you can browse to in order to see the application in action. Here&amp;rsquo;s an example of the output you should see in this second stage:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-customize-default/pipeline-deploy.png&#34; alt=&#34;GitLab pipeline deployment output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;If you run the commands shown in the output, you should see the load balancer IP address, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-customize-default/service.png&#34; alt=&#34;Service IP address&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Browse to the service IP address listed in the output and you should see the output of the Node.js application, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-customize-default/example-1.png&#34; alt=&#34;Example output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;At this point, you have successfully customized the default Auto DevOps pipeline provided by GitLab to use Bitnami&amp;rsquo;s Node.js Helm chart. Doing this ensures that your application deployments will always use a secure and up-to-date version of Node.js, while also giving you the flexibility to further customize the deployment as needed.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;p&gt;To learn more about the topics discussed in this guide, use the links below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/general/apps/gitlab/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami GitLab CE stack documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Node.js container&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Node.js Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;GitLab documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Create a Continuous Integration Pipeline with GitLab and Kubernetes</title>
      
      <link>/guides/ci-cd/gitlab-auto-devops/</link>
      <pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/guides/ci-cd/gitlab-auto-devops/</guid>
      <description>

        
        &lt;p&gt;As development velocity increases, it&amp;rsquo;s now become essential for enterprises to have a reliable and readily-available Continuous Integration/Continuous Delivery (CI/CD) pipeline integrated with cloud infrastructure. But although the requirements of such infrastructure are well understood, setting up this pipeline is still a complex task involving knowledge of cloud platforms, containerization tools like Docker, Docker Compose and others, container orchestration tools like Kubernetes and Helm, and DevOps tools and techniques.&lt;/p&gt;
&lt;p&gt;Bitnami eases the task of building an enterprise-ready CI/CD pipeline with its application stacks and container images.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://bitnami.com/stack/gitlab&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s GitLab CE stack&lt;/a&gt; lets you deploy a secure and fully-functional GitLab instance on the cloud in a matter of minutes and integrate it with a Kubernetes cluster.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://bitnami.com/containers&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s containers&lt;/a&gt; for &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Node.js&lt;/a&gt;, &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-ruby&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Ruby&lt;/a&gt;, &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-java&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Java&lt;/a&gt;  and others makes it easy to containerize your applications in a secure and reliable manner.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Put the two together, and you have everything you need to create a modern, enterprise-grade CI/CD pipeline that leverages the scalability of Kubernetes with the flexibility of GitLab and the development agility of Bitnami containers. This guide walks you through the process.&lt;/p&gt;
&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;This guide shows you how to set up a CI/CD pipeline between GitLab (deployed using the &lt;a href=&#34;https://bitnami.com/stack/gitlab&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami GitLab CE stack&lt;/a&gt;) and a Kubernetes cluster with GitLab&amp;rsquo;s Auto DevOps feature. With this configuration, every change to application code is automatically built as a Docker container (based on a &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Node.js base container&lt;/a&gt;) and deployed to the Kubernetes cluster for review and test.&lt;/p&gt;
&lt;p&gt;Communication and monitoring between the GitLab deployment and the Kubernetes cluster is achieved through the use of &lt;a href=&#34;https://helm.sh&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm&lt;/a&gt;, &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Ingress&lt;/a&gt; and &lt;a href=&#34;https://docs.gitlab.com/runner/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;GitLab Runner&lt;/a&gt;. When GitLab deploys each built container to the cluster, it also makes it available for review at an auto-generated sub-domain of your main domain name.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and prerequisites&lt;/h2&gt;
&lt;p&gt;This guide makes the following assumptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have deployed the Bitnami GitLab CE stack on a cloud server and have the GitLab CE administrator credentials. Learn about &lt;a href=&#34;https://docs.bitnami.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;deploying Bitnami applications&lt;/a&gt; and &lt;a href=&#34;https://docs.bitnami.com/general/faq/get-started/find-credentials/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;obtaining credentials&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a multi-node Kubernetes cluster running. &lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about deploying a Kubernetes cluster on different cloud platforms&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have the &lt;em&gt;kubectl&lt;/em&gt; command line (kubectl CLI) installed. &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes#step-3-install-kubectl-command-line&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about &lt;em&gt;kubectl&lt;/em&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have &lt;a href=&#34;https://git-scm.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Git&lt;/a&gt; installed.&lt;/li&gt;
&lt;li&gt;You have a domain name and the ability to configure a wildcard DNS record for that domain name. &lt;a href=&#34;https://en.wikipedia.org/wiki/Wildcard_DNS_record&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about wildcard DNS records&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have an SSH key pair which you can use for repository commits. To generate a new SSH key pair, use PuTTYgen (Windows) or the &lt;em&gt;ssh-keygen&lt;/em&gt; command (Linux and Mac OS X). Learn about &lt;a href=&#34;http://winscp.net/eng/docs/ui_puttygen&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;PuTTYgen&lt;/a&gt; and &lt;a href=&#34;http://www.macworld.co.uk/how-to/mac-software/how-generate-ssh-keys-3521606/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;em&gt;ssh-keygen&lt;/em&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-1-configure-dns-and-ssl-for-gitlab&#34;&gt;Step 1: Configure DNS and SSL for GitLab&lt;/h2&gt;
&lt;p&gt;As a first step, you must configure a domain name and SSL certificate for GitLab, such that browsing to the domain directs you to a secure page for your GitLab deployment. If you already have an SSL certificate for your domain, you can continue to use that or, if not, you can follow the approach below and generate a free Let&amp;rsquo;s Encrypt SSL certificate.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Follow the instructions to &lt;a href=&#34;https://docs.bitnami.com/general/faq/configuration/configure-custom-domain/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;configure a custom domain for GitLab&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;While logged in to the server console, &lt;a href=&#34;https://docs.bitnami.com/general/apps/gitlab/administration/generate-configure-certificate-letsencrypt/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;manually generate and install a Let&amp;rsquo;s Encrypt certificate using &lt;em&gt;lego&lt;/em&gt;&lt;/a&gt; as described in our guide.&lt;/li&gt;
&lt;li&gt;Test the configuration by browsing to &lt;em&gt;https://DOMAIN&lt;/em&gt; (replace the DOMAIN placeholder with the correct domain name) and confirming that you see a secure GitLab login page, as shown below:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/gitlab-ssl.png&#34; alt=&#34;GitLab secure login&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;step-2-configure-and-activate-the-gitlab-registry&#34;&gt;Step 2: Configure and activate the GitLab registry&lt;/h2&gt;
&lt;p&gt;The next step is to activate the GitLab registry, as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Log in to the server console using SSH (if you&amp;rsquo;re not already logged in).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Edit the &lt;em&gt;/etc/gitlab/gitlab.rb&lt;/em&gt; file and uncomment and update the &lt;em&gt;registry_external_url&lt;/em&gt; parameter as below, remembering to replace the DOMAIN placeholder with the GitLab domain name:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;registry_external_url &amp;#39;https://DOMAIN:5005&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the same file, uncomment and update the &lt;em&gt;external_url&lt;/em&gt; parameter as below, replacing the DOMAIN placeholder with the GitLab domain name:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;external_url &amp;#39;https://DOMAIN&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Save your changes to the file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Configure the GitLab registry to use the SSL certificates generated in the previous step. Replace the DOMAIN placeholder with the GitLab domain name.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;cd /etc/gitlab/ssl
sudo ln -sf server.crt DOMAIN.crt
sudo ln -sf server.key DOMAIN.key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Execute the commands below to reconfigure and restart GitLab with the changes.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;sudo gitlab-ctl reconfigure
sudo /opt/bitnami/ctlscript.sh restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Open port 5005 in the server firewall so that GitLab can connect to, and push built containers, to its internal registry. &lt;a href=&#34;https://docs.bitnami.com/general/faq/administration/use-firewall/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about opening firewall ports for your cloud platform&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-3-create-a-new-gitlab-project&#34;&gt;Step 3: Create a new GitLab project&lt;/h2&gt;
&lt;p&gt;You can now log in to GitLab and prepare a new project. This project will host the code that you will eventually run through your CI/CD pipeline to build and deploy on Kubernetes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Browse to your GitLab domain and log in using the administrator credentials.&lt;/li&gt;
&lt;li&gt;On the welcome page, select the &amp;ldquo;Create a project&amp;rdquo; option.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/create-project.png&#34; alt=&#34;GitLab project creation&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Enter a name and slug for your project. Set the visibility level to &amp;ldquo;Internal&amp;rdquo;. Click &amp;ldquo;Create project&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/configure-project.png&#34; alt=&#34;GitLab project creation&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Your project is created and you should see the project page, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/new-project.png&#34; alt=&#34;GitLab project page&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Click the &amp;ldquo;Clone&amp;rdquo; button and note the clone URL for the repository, which will be needed in &lt;a href=&#34;#step-6-commit-test-and-repeat&#34;&gt;Step 6&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/project-clone-url.png&#34; alt=&#34;GitLab project clone URL&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Before you can commit any code to the project repository, you must add your SSH key to your profile, as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Click your user profile icon in the top right corner of the navigation bar.&lt;/li&gt;
&lt;li&gt;Select the &amp;ldquo;Settings&amp;rdquo; menu icon.&lt;/li&gt;
&lt;li&gt;On the &amp;ldquo;User Settings&amp;rdquo; page, select the &amp;ldquo;SSH Keys&amp;rdquo; menu item.&lt;/li&gt;
&lt;li&gt;Paste the public key component of your SSH key pair in the &amp;ldquo;Key&amp;rdquo; field. Add an optional label and click the &amp;ldquo;Add Key&amp;rdquo; button to save the changes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/add-ssh-key.png&#34; alt=&#34;GitLab key addition&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;step-4-configure-a-kubernetes-cluster-for-the-project&#34;&gt;Step 4: Configure a Kubernetes cluster for the project&lt;/h2&gt;
&lt;p&gt;GitLab comes with built-in support for Kubernetes, making it easy to build and test your projects using a Kubernetes cluster. &lt;a href=&#34;https://docs.gitlab.com/ee/user/project/clusters/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about Kubernetes support in GitLab&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;First, allow outbound requests from GitLab hooks and services, as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Navigate to the GitLab administration panel by selecting the &amp;ldquo;Admin Area&amp;rdquo; link.&lt;/li&gt;
&lt;li&gt;Navigate to the &amp;ldquo;Settings -&amp;gt; Network&amp;rdquo; page and select the &amp;ldquo;Outbound requests&amp;rdquo; section.&lt;/li&gt;
&lt;li&gt;Tick the checkboxes to allow requests to the local network from hooks and services.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/allow-network-requests.png&#34; alt=&#34;GitLab network requests&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Then, configure your Kubernetes cluster in GitLab by following these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use the &lt;em&gt;kubectl&lt;/em&gt; command-line tool to obtain the following details for your Kubernetes cluster using the &lt;a href=&#34;https://docs.gitlab.com/ee/user/project/clusters/#add-existing-kubernetes-cluster&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;instructions in the GitLab documentation&lt;/a&gt;:
&lt;ul&gt;
&lt;li&gt;Cluster API URL&lt;/li&gt;
&lt;li&gt;Cluster CA certificate&lt;/li&gt;
&lt;li&gt;Cluster service token&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;From the project page in GitLab, select the &amp;ldquo;Operations -&amp;gt; Kubernetes&amp;rdquo; menu item.&lt;/li&gt;
&lt;li&gt;On the resulting page, click the &amp;ldquo;Add Kubernetes cluster&amp;rdquo; button.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/add-cluster.png&#34; alt=&#34;GitLab cluster configuration&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Select the &amp;ldquo;Add existing cluster&amp;rdquo; tab.&lt;/li&gt;
&lt;li&gt;Enter a name for your cluster with the API URL, CA certificate and server token obtained already. Check the boxes for &amp;ldquo;RBAC-enabled&amp;rdquo; cluster and &amp;ldquo;GitLab-managed cluster&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/configure-cluster.png&#34; alt=&#34;GitLab cluster configuration&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Click the &amp;ldquo;Add Kubernetes cluster&amp;rdquo; button to save the changes.&lt;/li&gt;
&lt;li&gt;On the resulting page, find the &amp;ldquo;Applications&amp;rdquo; section and install Helm, followed by Ingress. Note the Ingress endpoint IP address generated after installing Ingress.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/install-helm-ingress.png&#34; alt=&#34;Helm/Ingress installation&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Configure a wildcard DNS record for your domain pointing to the Ingress IP address through your DNS provider&amp;rsquo;s control panel. Learn how to configure wildcard DNS records for popular DNS providers like &lt;a href=&#34;https://www.godaddy.com/help/set-up-wildcard-dns-3301&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;GoDaddy&lt;/a&gt;, &lt;a href=&#34;https://www.namecheap.com/support/knowledgebase/article.aspx/597/2237/how-can-i-set-up-a-catchall-wildcard-subdomain&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;NameCheap&lt;/a&gt; and &lt;a href=&#34;https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html#domain-name-format-asterisk&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;AWS Route53&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Enter the base domain name used by the wildcard DNS record in the &amp;ldquo;Base domain&amp;rdquo; field in your GitLab Kubernetes cluster configuration. For example, if you configured a wildcard DNS record for *&lt;em&gt;.example.com&lt;/em&gt;, use &lt;em&gt;example.com&lt;/em&gt; as the base domain name. This will be the base domain used for all Auto DevOps review deployments. Click &amp;ldquo;Save changes&amp;rdquo; to save the changes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/configure-base-domain.png&#34; alt=&#34;GitLab base domain configuration&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Return to the &amp;ldquo;Applications&amp;rdquo; section and install Cert-Manager. Remember to provide a valid email address so that Cert-Manager can correctly associate your certificates with your account.&lt;/li&gt;
&lt;li&gt;From the same &amp;ldquo;Applications&amp;rdquo; section, install GitLab Runner.&lt;/li&gt;
&lt;li&gt;Confirm that the runner is successfully installed and activated for the project by navigating to the project&amp;rsquo;s &amp;ldquo;Settings -&amp;gt; CI/CD&amp;rdquo; page and checking the status of the runner in the &amp;ldquo;Runners&amp;rdquo; section.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/check-runner-status.png&#34; alt=&#34;GitLab runner status&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;step-5-enable-auto-devops-for-the-project&#34;&gt;Step 5: Enable Auto DevOps for the project&lt;/h2&gt;
&lt;p&gt;Once the Kubernetes integration is complete and a runner is active, enable Auto DevOps for the project. Auto DevOps provides a preconfigured CI/CD pipeline which can be used to quickly get started with building, testing and deploying your project. &lt;a href=&#34;https://docs.gitlab.com/ee/topics/autodevops/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about Auto DevOps in GitLab&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To enable Auto DevOps for the project:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Navigate to the project&amp;rsquo;s &amp;ldquo;Settings -&amp;gt; CI/CD&amp;rdquo; page.&lt;/li&gt;
&lt;li&gt;In the &amp;ldquo;Auto DevOps&amp;rdquo; section, check the box for &amp;ldquo;Default to Auto DevOps pipeline&amp;rdquo; and select the &amp;ldquo;Continuous deployment to production&amp;rdquo; strategy.&lt;/li&gt;
&lt;li&gt;Click &amp;ldquo;Save changes&amp;rdquo; to enable the default pipeline.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/enable-auto-devops.png&#34; alt=&#34;GitLab Auto DevOps configuration&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The default Auto DevOps pipeline comes with various stages already configured, depending on which version of GitLab you are running. For example, there are stages to build, run tests, check code quality, scan for dependencies, review code, deploy code and test performance. This default pipeline is fully customizable and stages can be added or removed depending on your requirements, simply by adjusting pipeline variables. &lt;a href=&#34;https://docs.gitlab.com/ee/topics/autodevops/#environment-variables&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about the available variables&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This tutorial will focus on creating a very simple pipeline consisting of only two stages: build and deploy. To turn off the other stages included in the default pipeline, follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Navigate to the project&amp;rsquo;s &amp;ldquo;Settings -&amp;gt; CI/CD&amp;rdquo; page.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the &amp;ldquo;Variables&amp;rdquo; section, add the following three variables and values:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;TEST_DISABLED: true
CODE_QUALITY_DISABLED: true
PERFORMANCE_DISABLED: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click &amp;ldquo;Save variables&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/set-variables.png&#34; alt=&#34;GitLab Auto DevOps configuration&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;step-6-commit-test-and-repeat&#34;&gt;Step 6: Commit, test and repeat&lt;/h2&gt;
&lt;p&gt;At this point, you are ready to commit some code to the project and have GitLab test and deploy it. This tutorial will create a simple &amp;ldquo;Hello, world&amp;rdquo; application in Node.js and then configure a Dockerfile to run it with Bitnami&amp;rsquo;s Node.js development container image.&lt;/p&gt;
&lt;p&gt;Follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Create a working directory for the application on your local host:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;mkdir myproject
cd myproject
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;package.json&lt;/em&gt; file listing the dependencies for the project:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;simple-node-app&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;1.0.0&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Node.js on Docker&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;main&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;server.js&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;scripts&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;node server.js&amp;#34;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;dependencies&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;express&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;^4.13&amp;#34;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;server.js&lt;/em&gt; file for the Express application which returns a &amp;ldquo;Hello world&amp;rdquo; message on access:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;use strict&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;express&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;require&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;express&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Constants
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// App
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;express&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Hello world\n&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;console&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Running on http://localhost:&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;Dockerfile&lt;/em&gt; with the following content:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; bitnami/node:9 as builder&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENV&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_ENV&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;production&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Copy app&amp;#39;s source code to the /app directory&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; . /app&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# The application&amp;#39;s directory will be the working directory&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WORKDIR&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; /app&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Install Node.js dependencies defined in &amp;#39;/app/packages.json&amp;#39;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;RUN&lt;/span&gt; npm install&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; bitnami/node:9-prod&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENV&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_ENV&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;production&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; --from&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;builder /app /app&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WORKDIR&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; /app&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENV&lt;/span&gt; PORT &lt;span class=&#34;m&#34;&gt;5000&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;EXPOSE&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; 5000&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Start the application&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;CMD&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;npm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This multi-stage &lt;em&gt;Dockerfile&lt;/em&gt; creates a new image using Bitnami&amp;rsquo;s Node.js container image as base. It copies the application files to the container&amp;rsquo;s &lt;em&gt;/app&lt;/em&gt; directory and then runs &lt;em&gt;npm install&lt;/em&gt; to install Express. It then creates a production-ready container image and configures the application to listen to request on port 5000.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Exposing the application on port 5000 is a requirement of GitLab&amp;rsquo;s &lt;a href=&#34;https://gitlab.com/gitlab-org/charts/auto-deploy-app&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;default Helm chart&lt;/a&gt;, which is used to deploy the application to the cluster. This can be overridden if needed using a custom Helm chart. Read more in our tutorial on &lt;a href=&#34;https://docs.bitnami.com/tutorials/customize-ci-cd-pipeline-gitlab-bitnami-charts&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;using a custom Helm chart with the Auto DevOps pipeline&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Initialize a Git repository and commit and push the application code to GitLab. Replace the NAME and EMAIL-ADDRESS placeholders with your name and email address (if not already configured) and the CLONE-URL placeholder with the repository clone URL obtained in &lt;a href=&#34;#step-3-create-a-new-gitlab-project&#34;&gt;Step 3&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;git config --global user.name &amp;#34;NAME&amp;#34;
git config --global user.name &amp;#34;EMAIL-ADDRESS&amp;#34;
git init    
git remote add origin CLONE-URL
git add .
git commit -m &amp;#34;Initial commit&amp;#34;
git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pushing this commit should automatically trigger the Auto DevOps pipeline in GitLab. To see the pipeline in action, navigate to the project&amp;rsquo;s &amp;ldquo;CI/CD -&amp;gt; Pipelines&amp;rdquo; page and confirm that the pipeline is running, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/running-pipeline.png&#34; alt=&#34;GitLab pipeline&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;In the first stage, GitLab will attempt to build a container image containing the application code using the provided Dockerfile. The container will be pushed to the internal GitLab registry. Here&amp;rsquo;s an example of the output you should see in this first stage:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/pipeline-build.png&#34; alt=&#34;GitLab pipeline build output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Once the container image has been built and pushed, the second stage of the pipeline will attempt to deploy it to Kubernetes for review. If successful, the stage output will display a URL, which you can browse to in order to see the application in action. Here&amp;rsquo;s an example of the output you should see in this second stage:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/pipeline-deploy.png&#34; alt=&#34;GitLab pipeline deployment output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;If you browse to the application URL listed in the output, you should see the output of the Node.js app, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/example-1.png&#34; alt=&#34;Example output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;To test the CI/CD feature, make a change to the application - for example, update the message &amp;ldquo;Hello world&amp;rdquo; in the &lt;em&gt;server.js&lt;/em&gt; file to &amp;ldquo;Aloha world&amp;rdquo; - and push the change to GitLab.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;sed -i &amp;#39;s/Hello world/Aloha world/g&amp;#39; server.js
git add .
git commit -m &amp;#34;Modified message text&amp;#34;
git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The new commit should trigger the pipeline, causing a new build and deployment to take place, and the new application will be deployed on your cluster for review. As before, check pipeline status in GitLab, wait for it to complete and then browse to the application URL listed in the output of the second stage. You should see the revised output, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/example-2.png&#34; alt=&#34;Example output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;At this point, you have successfully created a simple CI/CD pipeline between GitLab and a Kubernetes cluster. You can now continue to enhance it by &lt;a href=&#34;https://docs.gitlab.com/ee/topics/autodevops/#features&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;adding new stages to the Auto DevOps pipeline&lt;/a&gt;, modifying how your code is deployed with a &lt;a href=&#34;https://docs.gitlab.com/ee/topics/autodevops/#custom-helm-chart&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;custom deployment Helm chart&lt;/a&gt;, or &lt;a href=&#34;https://docs.gitlab.com/ee/user/project/pipelines/schedules.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;configuring pipelines to run on a schedule&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;p&gt;To learn more about the topics discussed in this guide, use the links below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/general/apps/gitlab/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami GitLab CE stack documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node#&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Node.js container&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/general/faq/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami applications FAQ&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami documentation for Kubernetes deployments on different cloud platforms&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;GitLab documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Wildcard_DNS_record&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Wildcard DNS records&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Key generation with &lt;a href=&#34;http://winscp.net/eng/docs/ui_puttygen&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;PuTTYgen&lt;/a&gt; and &lt;a href=&#34;http://www.macworld.co.uk/how-to/mac-software/how-generate-ssh-keys-3521606/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;em&gt;ssh-keygen&lt;/em&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
