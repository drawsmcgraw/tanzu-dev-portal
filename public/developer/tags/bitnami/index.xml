<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>VMware Tanzu Developer Center â€“ Bitnami</title>
    <link>/tags/bitnami/</link>
    <description>Recent content in Bitnami on VMware Tanzu Developer Center</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 13 Jul 2021 00:00:00 +0000</lastBuildDate>
    
	  <atom:link href="/tags/bitnami/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      
      <title>Guides: Develop and Publish an ASP.NET Web Application using Bitnami Containers</title>
      
      <link>/guides/containers/develop-aspnet-application-bitnami-containers/</link>
      <pubDate>Thu, 03 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>/guides/containers/develop-aspnet-application-bitnami-containers/</guid>
      <description>

        
        &lt;p&gt;&lt;a href=&#34;https://www.docker.com&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker&lt;/a&gt; containers have become increasingly popular amongst developers on account of their ease of use, consistency and portability. For .NET developers looking to develop and publish applications using containers, Bitnami offers a number of options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-dotnet-sdk&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s .NET SDK container&lt;/a&gt; provides the complete .NET SDK for application development;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-dotnet&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s .NET container&lt;/a&gt; provides the .NET runtime environment for application execution;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-aspnet-core&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s ASP.NET Core container&lt;/a&gt; provides the ASP.NET runtime environment for application execution.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of these images are secure, optimized and up-to-date, enabling .NET developers to use them in daily development without being concerned about missing out on the latest language features and security fixes.&lt;/p&gt;
&lt;p&gt;This guide gets you started with Bitnami&amp;rsquo;s .NET containers, by using them to create a sample ASP.NET Web application and publish it as a container image to Docker Hub.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and Prerequisites&lt;/h2&gt;
&lt;p&gt;This guide focuses on creating a Docker image of a custom ASP.NET Web application using &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-aspnet-core&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s ASP.NET Core container image&lt;/a&gt;. In case you don&amp;rsquo;t have an ASP.NET Web application at hand, the first step of this guide shows you how to create one.&lt;/p&gt;
&lt;p&gt;This guide makes the following assumptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have a Docker environment installed and configured. &lt;a href=&#34;https://docs.docker.com/engine/installation/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about installing Docker&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a Docker Hub account. &lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Register for a free account&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a basic understanding of how containers work. Learn more about containers in &lt;a href=&#34;https://www.youtube.com/watch?v=Pb1bgI59dF0&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;our YouTube video&lt;/a&gt;, on &lt;a href=&#34;https://en.wikipedia.org/wiki/Operating-system-level_virtualization&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Wikipedia&lt;/a&gt; and on &lt;a href=&#34;http://www.zdnet.com/article/containers-fundamental-to-the-evolution-of-the-cloud/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;ZDNet&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-1-create-or-obtain-the-application-source-code&#34;&gt;Step 1: Create or obtain the application source code&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;If you already have an ASP.NET Web application of your own, you can use that instead and skip to &lt;a href=&#34;#step-2-build-a-docker-image-of-the-application&#34;&gt;Step 2&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The first step is to create a sample ASP.NET Web application which generates a welcome message. If you don&amp;rsquo;t have .NET installed, an easy way to do this is with the .NET CLI from &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-dotnet-sdk&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s .NET SDK container image&lt;/a&gt;. This allows you to execute .NET CLI commands using the Bitnami .NET SDK container on your host, exactly as though you had the complete .NET SDK already installed. If you already have a .NET development environment, you can use that instead and skip the Docker commands below.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Create a working directory for the application on your local host and make it the current directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;mkdir myapp
&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; myapp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use the following Docker commands to create and start a &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-dotnet-sdk&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami .NET SDK container&lt;/a&gt; on your host:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker create --rm -v &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;:/app --net&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;host&amp;#34;&lt;/span&gt; -t --name dotnetsdk bitnami/dotnet-sdk:latest
docker start dotnetsdk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;em&gt;-v&lt;/em&gt; argument to the first command tells Docker to mount the host&amp;rsquo;s current directory into the container&amp;rsquo;s &lt;em&gt;/app&lt;/em&gt; path, so that the effects of commands run in the container are seen on the host. The &lt;em&gt;&amp;ndash;net=&amp;ldquo;host&amp;rdquo;&lt;/em&gt; argument tells Docker to use the host&amp;rsquo;s network stack for the container, and the &lt;em&gt;&amp;ndash;rm&lt;/em&gt; argument removes the container once it exits. The container is named &lt;em&gt;dotnetsdk&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Once the container is running, connect to the container console with the command below. This will give you a command shell and allow you to use the .NET SDK tools available in the image for subsequent tasks.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; -it dotnetsdk bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Install the ASP.NET Web application templates and then use the .NET CLI to create a skeleton ASP.NET Web application:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;dotnet new -i /opt/bitnami/dotnet-sdk/templates/3.1.3/microsoft.dotnet.web.projecttemplates.3.1.3.1.2.nupkg
&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; /app
dotnet new webapp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Modify the application&amp;rsquo;s default welcome page:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sed -i &lt;span class=&#34;s1&#34;&gt;&amp;#39;s/Welcome/Hello from Bitnami/g&amp;#39;&lt;/span&gt; Pages/Index.cshtml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the application:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;dotnet run --urls&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;http://0.0.0.0:5000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will run the ASP.NET Web application on port 5000 and allow it to accept incoming connections from other hosts. To test it, browse to http://DOCKER-HOST-ADDRESS:5000/, where DOCKER-HOST-ADDRESS is the IP address of your host, and confirm that you see the modified welcome page shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/develop-aspnet-application-bitnami-containers/welcome.png&#34; alt=&#34;Default page&#34;  /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If the Docker host is a different machine, ensure that the host firewall is configured to allow access on port 5000.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Once you have confirmed that the application works, proceed to publish it:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;dotnet publish
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The published application will be stored in the &lt;em&gt;/app/bin/Debug/netcoreapp3.1/publish/&lt;/em&gt; directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exit and stop the container.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker stop dotnetsdk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-2-build-a-docker-image-of-the-application&#34;&gt;Step 2: Build a Docker image of the application&lt;/h2&gt;
&lt;p&gt;Once you have a published, tested version of your application, you can proceed to build a Docker image for it.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Create a file named &lt;em&gt;Dockerfile&lt;/em&gt; in the application&amp;rsquo;s working directory and fill it with the following content:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM bitnami/aspnet-core:latest
COPY ./bin/Debug/netcoreapp3.1/publish/ /app/
RUN useradd -r -u 1001 -g root nonroot
RUN chown -R nonroot /app
USER nonroot
WORKDIR /app
CMD [ &amp;quot;./app&amp;quot;, &amp;quot;--urls=http://0.0.0.0:5000&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This &lt;em&gt;Dockerfile&lt;/em&gt; uses the &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-aspnet-core&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami ASP.NET Core image&lt;/a&gt; as its starting point, because this image contains the ASP.NET framework and files needed to run an ASP.NET Web application.&lt;/p&gt;
&lt;p&gt;This &lt;em&gt;Dockerfile&lt;/em&gt; begins by copying the published application files from the current directory to the container&amp;rsquo;s &lt;em&gt;/app&lt;/em&gt; directory. It also creates a non-root user account that the application will run under. For security reasons, it&amp;rsquo;s recommended to always run your application using a non-root user account. Finally, it starts the application on port 5000.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;By default, the Bitnami .NET SDK container runs as the &lt;em&gt;root&lt;/em&gt; user, and the files generated will be owned by &lt;em&gt;root&lt;/em&gt;. Change the ownership of the files to the current user so that Docker is able to read and process them.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ..
sudo chown -R &lt;span class=&#34;nv&#34;&gt;$USER&lt;/span&gt;.&lt;span class=&#34;nv&#34;&gt;$USER&lt;/span&gt; myapp
&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; myapp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Build the image using the command below. Replace the DOCKER-USERNAME placeholder in the command below with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker build -t DOCKER-USERNAME/myapp:1.0 .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The result of this command is an image containing the application, the ASP.NET framework and all the related dependencies.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;step-3-test-and-publish-the-docker-image&#34;&gt;Step 3: Test and publish the Docker image&lt;/h1&gt;
&lt;p&gt;Once you have the application image, you can test it and publish it as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Run the new Docker image in a container to test it with the &lt;em&gt;docker run&lt;/em&gt; command. Replace the DOCKER_USERNAME placeholder in the command with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker run -p 5000:5000 DOCKER_USERNAME/myapp:1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This command runs the application in a container and maps port 5000 of the container to port 5000 on the Docker host. With this, a user can access the application by browsing to port 5000 of the host. To test it, browse to http://DOCKER-HOST-ADDRESS:5000/, where DOCKER-HOST-ADDRESS is the IP address of your host, and confirm that you see the application welcome page shown previously.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If the Docker host is a different machine, ensure that the host firewall is configured to allow access on port 5000.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Log in to Docker Hub and publish the image. Replace the DOCKER-USERNAME placeholder in the command below with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker login
docker push DOCKER-USERNAME/myapp:1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Once published on Docker Hub, your image is publicly available by default.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-dotnet-sdk&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami .NET SDK container image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-aspnet-core&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami ASP.NET Core container image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;ASP.NET documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Deploy a Custom Node.js Application using Bitnami Containers</title>
      
      <link>/guides/containers/deploy-custom-nodejs-app-bitnami-containers/</link>
      <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/guides/containers/deploy-custom-nodejs-app-bitnami-containers/</guid>
      <description>

        
        &lt;p&gt;Developers like using containers for development because they are easy to use, portable, and require less maintenance overhead compared to bare metal or virtual machines. &lt;a href=&#34;https://www.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker&lt;/a&gt; is a popular choice, because it provides tools that make it simple for developers to build, run and publish applications in containers.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;ve seen Docker in action and then wondered &amp;ldquo;can I use this with my own application&amp;rdquo;, then you&amp;rsquo;re in the right place.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://bitnami.com&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&lt;/a&gt; makes it easy to create a Docker image of your own application using its production-ready &lt;a href=&#34;https://bitnami.com/containers&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;container images&lt;/a&gt;. Once created, you can run and test your application with Docker, or publish it online so that others can find and use it. And, because Bitnami container images are always secure, optimized and up-to-date, you can rest assured that your application always has access to the latest language features and security fixes.&lt;/p&gt;
&lt;p&gt;This guide walks you through the process of creating an optimized, secure Docker image of a custom application using a Bitnami base container, then testing it and publishing it online. It also guides you through the steps to follow when you update your application and need to rebuild and republish it for your users.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and Prerequisites&lt;/h2&gt;
&lt;p&gt;This guide focuses on creating a secure and optimized Docker image of a custom Node.js application using Bitnami&amp;rsquo;s Node.js production image. In case you don&amp;rsquo;t have a Node.js application at hand, you can use &lt;a href=&#34;https://github.com/bitnami/tutorials/tree/master/simple-node-app&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;this simple &amp;ldquo;Hello world&amp;rdquo; application&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This guide makes the following assumptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have a Docker environment installed and configured. &lt;a href=&#34;https://docs.docker.com/engine/installation/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about installing Docker&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a Docker Hub account. &lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Register for a free account&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have Git installed and configured.&lt;/li&gt;
&lt;li&gt;You have a basic understanding of how containers work. Learn more about containers in &lt;a href=&#34;https://www.youtube.com/watch?v=Pb1bgI59dF0&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;our YouTube video&lt;/a&gt;, on &lt;a href=&#34;https://en.wikipedia.org/wiki/Operating-system-level_virtualization&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Wikipedia&lt;/a&gt; and on &lt;a href=&#34;http://www.zdnet.com/article/containers-fundamental-to-the-evolution-of-the-cloud/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;ZDNet&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-1-create-or-obtain-the-application-source-code&#34;&gt;Step 1: Create or obtain the application source code&lt;/h2&gt;
&lt;p&gt;To begin the process, ensure that you have access to the application source code. If you don&amp;rsquo;t have an existing Node.js application, follow the steps below to create one:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Create a working directory for the application on your local host:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;mkdir myproject
&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; myproject
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;package.json&lt;/em&gt; file listing the dependencies for the project:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;simple-node-app&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;1.0.0&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Node.js on Docker&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;main&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;server.js&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;scripts&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;node server.js&amp;#34;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;dependencies&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;express&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;^4.13&amp;#34;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;server.js&lt;/em&gt; file for the Express application which returns a &amp;ldquo;Hello world&amp;rdquo; message on access:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;use strict&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;express&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;require&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;express&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Constants
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// App
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;express&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Hello world\n&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;console&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Running on http://localhost:&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-2-create-a-dockerfile&#34;&gt;Step 2: Create a Dockerfile&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;Dockerfile&lt;/em&gt; is similar to a recipe: it contains all the ingredients needed to create a Docker image. Typically, each line represents a separate step and begins with an instruction keyword followed by a series of arguments. &lt;a href=&#34;https://docs.docker.com/engine/reference/builder&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about the &lt;em&gt;Dockerfile&lt;/em&gt; format&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the project directory, create a file named &lt;em&gt;Dockerfile&lt;/em&gt; and fill it with the following content:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;# First build stage
FROM bitnami/node:12 as builder
ENV NODE_ENV=&amp;#34;production&amp;#34;

# Copy app&amp;#39;s source code to the /app directory
COPY . /app

# The application&amp;#39;s directory will be the working directory
WORKDIR /app

# Install Node.js dependencies defined in &amp;#39;/app/packages.json&amp;#39;
RUN npm install

# Second build stage
FROM bitnami/node:12-prod
ENV NODE_ENV=&amp;#34;production&amp;#34;

# Copy the application code
COPY --from=builder /app /app

# Create a non-root user
RUN useradd -r -u 1001 -g root nonroot
RUN chown -R nonroot /app
USER nonroot

WORKDIR /app
EXPOSE 3000

# Start the application
CMD [&amp;#34;npm&amp;#34;, &amp;#34;start&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This &lt;em&gt;Dockerfile&lt;/em&gt; consists of two build stages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first stage uses the Bitnami Node.js 12.x development image to copy the application source and install the required application modules using &lt;em&gt;npm install&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The second stage uses the Bitnami Node.js 12.x production image and creates a minimal Docker image that only consists of the application source, modules and Node.js runtime.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Bitnami&amp;rsquo;s Node.js production image is different from its Node.js development image, because the production image (tagged with the suffix &lt;em&gt;prod&lt;/em&gt;) is based on &lt;a href=&#34;https://github.com/bitnami/minideb&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;minideb&lt;/a&gt; and does not include additional development dependencies. It is therefore lighter and smaller in size than the development image and is commonly used in multi-stage builds as the final target image.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;first-build-stage&#34;&gt;First build stage&lt;/h3&gt;
&lt;p&gt;Let&amp;rsquo;s take a closer look at the steps in the first build stage:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;FROM&lt;/em&gt; instruction kicks off the &lt;em&gt;Dockerfile&lt;/em&gt; and specifies the base image to use. Bitnami offers a number of container images for Docker which can be used as base images. Since the example application used in this guide is a Node.js application, &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Node.js development container&lt;/a&gt; is the best choice for the base image.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;NODE_ENV&lt;/em&gt; environment variable is defined so that &lt;em&gt;npm install&lt;/em&gt; only installs the application modules that are required in production environments.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;COPY&lt;/em&gt; instruction copies the source code from the current directory on the host to the &lt;em&gt;/app&lt;/em&gt; directory in the image.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;RUN&lt;/em&gt; instruction executes a shell command. It&amp;rsquo;s used to run &lt;em&gt;npm install&lt;/em&gt; to install the application dependencies.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;WORKDIR&lt;/em&gt; instructions set the working directory for the image.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;second-build-stage&#34;&gt;Second build stage&lt;/h3&gt;
&lt;p&gt;Here is what happens in the second build stage:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Since the target here is a minimal, secure image, the &lt;em&gt;FROM&lt;/em&gt; instruction specifies &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Node.js production container&lt;/a&gt; as the base image. Bitnami production images can be identified by the suffix &lt;em&gt;prod&lt;/em&gt; in the image tag.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;COPY&lt;/em&gt; instruction copies the source code and installed dependencies from the first stage to the &lt;em&gt;/app&lt;/em&gt; directory in the image.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;RUN&lt;/em&gt; commands create a non-root user account that the application will run under. For security reasons, it&amp;rsquo;s recommended to always run your application using a non-root user account.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;CMD&lt;/em&gt; instruction specifies the command to run when the image starts. In this case, &lt;em&gt;npm start&lt;/em&gt; will start the application.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-3-build-the-docker-image&#34;&gt;Step 3: Build the Docker image&lt;/h2&gt;
&lt;p&gt;Once the &lt;em&gt;Dockerfile&lt;/em&gt; is created, building a Docker image is as simple as calling the &lt;em&gt;docker build&lt;/em&gt; command. Execute the command below in the directory containing the &lt;em&gt;Dockerfile&lt;/em&gt;. Replace the DOCKER_USERNAME placeholder in the command below with your Docker account username. This Docker account username is necessary to avoid namespace errors when later pushing the image to your Docker Hub account.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker build -t DOCKER_USERNAME/my-node-app:0.1.0 .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;For successful execution of this and subsequent &lt;em&gt;docker&lt;/em&gt; commands, ensure that the user account you&amp;rsquo;re using belongs to the &lt;em&gt;docker&lt;/em&gt; group.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This will create an image named &lt;em&gt;my-node-app&lt;/em&gt;, tagged as version &lt;em&gt;0.1.0&lt;/em&gt;. This tag uniquely identifies a Docker image, allowing you to deploy a specific version of the application if needed.&lt;/p&gt;
&lt;p&gt;Here&amp;rsquo;s an example of what you should see during the build process:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-custom-nodejs-app-bitnami-containers/deploy-custom-nodejs-app-bitnami-containers-1.png&#34; alt=&#34;Image build process&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Once the build process is complete, use the &lt;em&gt;docker images&lt;/em&gt; command to verify that the image has been added to your local repository.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker images | grep my-node-app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The version tag added during the &lt;em&gt;docker build&lt;/em&gt; command also appears in the output of &lt;em&gt;docker images&lt;/em&gt;.  Here&amp;rsquo;s an example of what you should see:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-custom-nodejs-app-bitnami-containers/deploy-custom-nodejs-app-bitnami-containers-2.png&#34; alt=&#34;Image in local Docker registry&#34;  /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tagging image releases is a recommended practice. &lt;a href=&#34;https://docs.docker.com/engine/reference/commandline/tag/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about tags&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;step-4-test-the-docker-image&#34;&gt;Step 4: Test the Docker image&lt;/h2&gt;
&lt;p&gt;Run your new Docker image in a container to test it with the &lt;em&gt;docker run&lt;/em&gt; command. Replace the DOCKER_USERNAME placeholder in the command with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker run -it -p 3000:3000 DOCKER_USERNAME/my-node-app:0.1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This command runs the application in a container and makes port 3000 of the container accessible by binding it to port 3000 on the Docker host. With this, a user can access the application by browsing to port 3000 of the host.&lt;/p&gt;
&lt;p&gt;Here is what you should see as the container starts:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-custom-nodejs-app-bitnami-containers/deploy-custom-nodejs-app-bitnami-containers-3.png&#34; alt=&#34;Container startup&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;To test the application, browse to &lt;em&gt;http://localhost:3000&lt;/em&gt; (if the Docker host is the same machine) or &lt;em&gt;http://SERVER-IP:3000&lt;/em&gt; (if the Docker host is a different machine) and you should see this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-custom-nodejs-app-bitnami-containers/deploy-custom-nodejs-app-bitnami-containers-4.png&#34; alt=&#34;Application output&#34;  /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If the Docker host is a different machine, ensure that the host firewall is configured to allow access on port 3000.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &lt;em&gt;-i&lt;/em&gt; and &lt;em&gt;-t&lt;/em&gt; options to &lt;em&gt;docker run&lt;/em&gt; allocate a terminal for the container process, while the &lt;em&gt;-p&lt;/em&gt; option specifies the container-host port binding. &lt;a href=&#34;https://docs.docker.com/engine/reference/run/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about the &lt;em&gt;docker run&lt;/em&gt; command and its options&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;step-5-publish-the-docker-image&#34;&gt;Step 5: Publish the Docker image&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;This step requires a Docker Hub account. In case you don&amp;rsquo;t already have one, &lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;sign up on the Docker website&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;At this point, you have built, tagged and tested a Docker image containing your application code. To share it with others, you can upload the image to a public registry. A number of such registries are available, including &lt;a href=&#34;https://cloud.google.com/container-registry/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Google Container Registry&lt;/a&gt;, &lt;a href=&#34;https://quay.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Quay&lt;/a&gt; and others, but this guide will use &lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker Hub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To upload an image to Docker Hub, follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Use the &lt;em&gt;docker login&lt;/em&gt; command to log in:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker login
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use the &lt;em&gt;docker push&lt;/em&gt; command to push the image to your Docker Hub account, as shown below. Replace the DOCKER_USERNAME placeholder in the tag name with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker push DOCKER_USERNAME/my-node-app:0.1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here&amp;rsquo;s what you should see:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-custom-nodejs-app-bitnami-containers/deploy-custom-nodejs-app-bitnami-containers-5.png&#34; alt=&#34;Image publishing process&#34;  /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Once published on Docker Hub, your image is publicly available by default.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Check that the image has been successfully uploaded to Docker Hub by searching for it using the &lt;em&gt;docker search&lt;/em&gt; command, as shown below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker search DOCKER_USERNAME/my-node-app:0.1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once published on Docker Hub, other users can download your application and try it for themselves.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You can also delete images from Docker Hub using the Docker website.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;handling-updates&#34;&gt;Handling Updates&lt;/h2&gt;
&lt;p&gt;As you continue developing your application, you will inevitably want to release fresh Docker images. This might be to include new application features or bug fixes, or to use a new version of the base container that has the latest fixes. Doing this involves regenerating the application image and republishing it to the registry.&lt;/p&gt;
&lt;p&gt;To illustrate the process, let&amp;rsquo;s perform a code change in the example application and then release a fresh Docker image with the updated code. Follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Change to the directory containing the application source code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Edit the &lt;em&gt;server.js&lt;/em&gt; file and substitute the string &amp;ldquo;Hello world&amp;rdquo; with &amp;ldquo;Hello Mom&amp;rdquo;. Save the file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rebuild the image, tagging it as version 0.2.0. Replace the DOCKER_USERNAME placeholder in this and subsequent commands with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker build -t DOCKER_USERNAME/my-node-app:0.2.0  .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Confirm that the image was successfully built and added to the local registry:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker images | grep my-node-app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-custom-nodejs-app-bitnami-containers/deploy-custom-nodejs-app-bitnami-containers-6.png&#34; alt=&#34;Revised image in local Docker registry&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Test the new image:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker run -it -p 3000:3000 DOCKER_USERNAME/my-node-app:0.2.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here&amp;rsquo;s what you should see when you access the application through your Web browser:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-custom-nodejs-app-bitnami-containers/deploy-custom-nodejs-app-bitnami-containers-7.png&#34; alt=&#34;Application output&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Publish the new image to Docker Hub:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt; docker push DOCKER_USERNAME/my-node-app:0.2.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Follow these steps every time you want to update and republish your Docker image. If you are deploying the new image to a Kubernetes cluster, &lt;a href=&#34;https://docs.bitnami.com/tutorials/deploy-application-kubernetes-helm/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;read about rolling updates in our Kubernetes tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Node.js container image for Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bitnami.com/containers&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Other Bitnami container images for Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hub.docker.com&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker Hub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Deploy Locally a Spring Boot Application Using Bitnami Containers</title>
      
      <link>/guides/containers/deploy-locally-spring-boot-application-docker/</link>
      <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/guides/containers/deploy-locally-spring-boot-application-docker/</guid>
      <description>

        
        &lt;p&gt;&lt;a href=&#34;https://bitnami.com/stacks/containers&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami containers&lt;/a&gt; provide you with a ready-to-go environment for the development framework of your choice backed by Bitnami. By selecting a Bitnami container for local development, you can save a lot of time in coding as well as you benefit from having always the latest and more secure application image.&lt;/p&gt;
&lt;p&gt;You can use Bitnami container images for directly deploying applications or as a base for creating your own customized images. The Bitnami Tomcat container image includes all dependencies and libraries you need to deploy an application. That way, you can get productive immediately and focus only on what you love: coding.&lt;/p&gt;
&lt;p&gt;In this tutorial, you will learn how to use a &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-tomcat&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Tomcat container image&lt;/a&gt; as a framework for deploying locally a sample &lt;a href=&#34;https://spring.io/projects/spring-boot&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Spring Boot application&lt;/a&gt; that uses the &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-mariadb&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami MariaDB container image&lt;/a&gt; as a database.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and Prerequisites&lt;/h2&gt;
&lt;p&gt;This guide makes the following assumptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have basic knowledge of &lt;a href=&#34;https://www.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker&lt;/a&gt; containers.&lt;/li&gt;
&lt;li&gt;You have a Docker environment installed and configured. &lt;a href=&#34;https://docs.docker.com/install/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about installing Docker&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a Docker Hub account. &lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Register for a free account&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have Apache Maven already installed. &lt;a href=&#34;https://maven.apache.org/install.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Refer to the official Apache Maven Project documentation&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have Curl already installed. &lt;a href=&#34;https://curl.haxx.se/dlwiz/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Download and install the latest version of Curl for your operating system&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following are the steps you will complete in this guide:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Step 1: Obtain the application source code&lt;/li&gt;
&lt;li&gt;Step 2: Create a Dockerfile&lt;/li&gt;
&lt;li&gt;Step 3: Build the Docker image&lt;/li&gt;
&lt;li&gt;Step 4: Create a &lt;em&gt;docker-compose.yml&lt;/em&gt; file to configure application services&lt;/li&gt;
&lt;li&gt;Step 5: Test the Docker image and your custom application&lt;/li&gt;
&lt;li&gt;Step 6: Publish the Docker image&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-1-obtain-the-application-source-code&#34;&gt;Step 1: Obtain the application source code&lt;/h2&gt;
&lt;p&gt;To begin the process, ensure that you have access to the application source code. This tutorial uses a sample &lt;a href=&#34;https://github.com/spring-guides/gs-accessing-data-mysql&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Spring Boot application&lt;/a&gt; which has been modified to replace its database with the Bitnami MariaDB container image and to be packaged as a WAR file. To get the resulting package:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Clone the sample repository as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;git clone https://github.com/bitnami/tutorials.git
cd tutorials/spring-boot-app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will clone the sample repository. The &lt;em&gt;gs-mysql-data-0.1.0.war&lt;/em&gt; file is located in the &lt;em&gt;spring-boot-app&lt;/em&gt; subdirectory.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Learn more about the changes done in the application source code by checking check the &lt;a href=&#34;https://github.com/bitnami/tutorials/tree/master/spring-boot-app/README.md&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;repository README file&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-2-create-a-dockerfile&#34;&gt;Step 2: Create a Dockerfile&lt;/h2&gt;
&lt;p&gt;A &lt;a href=&#34;https://docs.docker.com/engine/reference/builder/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;em&gt;Dockerfile&lt;/em&gt;&lt;/a&gt; is similar to a recipe: it contains all the ingredients needed to create a Docker image. Each line of the file represents a separate step and contains the instructions for the container to build the application.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;Dockerfile&lt;/em&gt; in the sample &lt;em&gt;spring-boot-app&lt;/em&gt; repository to build your application with the Bitnami Tomcat container image providing the Tomcat infrastructure for the resulting application image. It should include the following content:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;FROM bitnami/tomcat:9.0
COPY gs-mysql-data-0.1.0.war /opt/bitnami/tomcat/webapps_default/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This &lt;em&gt;Dockerfile&lt;/em&gt; consists of one stage with two instructions for using the infrastructure &lt;em&gt;bitnami/tomcat:9.0&lt;/em&gt; image and to copy the application source at build time:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The FROM instruction kicks off the Dockerfile and specifies the base image to use. In this case, &lt;em&gt;bitnami/tomcat:9.0&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The COPY instruction copies the source code from the current directory on the host to the &lt;em&gt;/webapps_default&lt;/em&gt; directory in the image. Any WAR file copied into that directory will be automatically deployed by Tomcat at bootup time.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-3-build-the-docker-image&#34;&gt;Step 3: Build the Docker image&lt;/h2&gt;
&lt;p&gt;Once the &lt;em&gt;Dockerfile&lt;/em&gt; is created, it is time to build the docker image only by executing the &lt;em&gt;docker build&lt;/em&gt; command. Execute the command below in the same directory where the &lt;em&gt;Dockerfile&lt;/em&gt; is located, in this case, in the &lt;em&gt;spring-boot-app&lt;/em&gt; directory of the cloned repository. Remember to replace the DOCKER_USERNAME placeholder with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker build -t DOCKER_USERNAME/spring-java-app .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will create an image named &lt;em&gt;spring-java-app&lt;/em&gt;. Here is an example of the output you should see during the build process:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-locally-spring-boot-application-docker/spring-java-app.png&#34; alt=&#34;Build the Docker image&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Once the build process is complete, use the &lt;em&gt;docker image&lt;/em&gt; command to verify that the image has been added to your local repository.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker image ls DOCKER_USERNAME/spring-java-app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;step-4-create-a-docker-composeyml-file-to-configure-application-services&#34;&gt;Step 4: Create a &lt;em&gt;docker-compose.yml&lt;/em&gt; file to configure application services&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/compose/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Compose&lt;/a&gt; is a tool for defining and running applications with multiple containers in Docker. The &lt;em&gt;docker-compose.yml&lt;/em&gt; file is used to define the configuration of your application&amp;rsquo;s services. It includes the specification of the application&amp;rsquo;s service dependencies such as databases, queues, caches, etc. After defining them in the &lt;em&gt;docker-compose.yml&lt;/em&gt; file you are able to create and start one or more containers with a single command: &lt;em&gt;docker-compose up&lt;/em&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create a &lt;em&gt;docker-compose.yml&lt;/em&gt; file that contains the following content. Remember to replace the DOCKER_USERNAME placeholder with your Docker account username:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;version: &amp;#39;2&amp;#39;

services:
  mariadb:
    image: &amp;#39;bitnami/mariadb:10.3&amp;#39;
    environment:
      - ALLOW_EMPTY_PASSWORD=yes
      - MARIADB_DATABASE=db_example
      - MARIADB_USER=springuser
      - MARIADB_PASSWORD=ThePassword
    myapp:
    image: &amp;#39;DOCKER_USERNAME/spring-java-app&amp;#39;
    environment:
      - &amp;#39;SPRING_APPLICATION_JSON={&amp;#34;spring&amp;#34;: {&amp;#34;datasource&amp;#34;:{&amp;#34;url&amp;#34;: &amp;#34;jdbc:mysql://mariadb:3306/db_example&amp;#34;, &amp;#34;username&amp;#34;: &amp;#34;springuser&amp;#34;, &amp;#34;password&amp;#34;: &amp;#34;ThePassword&amp;#34;}}}&amp;#39;
    depends_on:
      - mariadb
    ports:
     - &amp;#39;8080:8080&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;The application environment variable set in this file allows you to use any MySQL database with any credentials at deployment time. This, makes your image secure for production environments.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;The ALLOW_EMPTY_PASSWORD parameter is set as &amp;ldquo;yes&amp;rdquo; in this &lt;em&gt;docker-compose.yml&lt;/em&gt; file since the application is built for development purposes. That value is highly discouraged for production. Remember to secure your deployments by setting a password in production environments.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;step-5-test-the-docker-image-and-your-custom-application&#34;&gt;Step 5: Test the Docker image and your custom application&lt;/h2&gt;
&lt;p&gt;Run your new Docker image in a container to test it with the &lt;em&gt;docker-compose up&lt;/em&gt; command.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker-compose up
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will create all the containers and volumes both for your application and the database. Now, it is time to test if the application works fine by calling the API endpoint using &lt;em&gt;Curl&lt;/em&gt;. Follow these instructions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Open a new terminal in your local system and execute the following command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;curl &amp;#39;localhost:8080/gs-mysql-data-0.1.0/demo/all&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The output should be an empty array &amp;ldquo;[]&amp;rdquo; that means that there is no data present in the database.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Let&amp;rsquo;s insert some data in the database by executing:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;curl &amp;#39;localhost:8080/gs-mysql-data-0.1.0/demo/add?name=First&amp;amp;email=someemail@someemailprovider.com&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Query the application again to check if the data is present in the database:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;curl &amp;#39;localhost:8080/gs-mysql-data-0.1.0/demo/all&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now, you should get an output similar to this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;[{&amp;#34;id&amp;#34;:1, &amp;#34;name&amp;#34;:&amp;#34;First&amp;#34;, &amp;#34;email&amp;#34;:&amp;#34;someemail@someemailprovider.com&amp;#34;}]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Congratulations! You have your Spring Boot application running locally and ready to use!&lt;/p&gt;
&lt;h2 id=&#34;step-6-publish-the-docker-image&#34;&gt;Step 6: Publish the Docker image&lt;/h2&gt;
&lt;p&gt;Now that your Docker image is built and contains your application code, you can upload it into a public registry. This tutorial uses &lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker Hub&lt;/a&gt;, but you can select one of your own choice such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/container-registry/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Google Container Registry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/ecr/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Amazon EC2 Container Registry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://azure.microsoft.com/en-us/services/container-registry/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Azure container Registry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://quay.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Quay&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To upload the image to Docker Hub, follow the steps below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Log in to Docker Hub:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker login
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Push the image to your Docker Hub account. Replace the DOCKER_USERNAME placeholder with the username of your Docker Hub account and &lt;em&gt;my-custom-app:latest&lt;/em&gt; with the name and the version of your Docker image:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;docker push DOCKER_USERNAME/my-custom-app:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Confirm that you see the image in your Docker Hub repositories dashboard.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://spring.io/projects/spring-boot&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Spring Boot official site&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/tutorials&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami tutorials repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-tomcat&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Tomcat container image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker Hub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bitnami.com/containers&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami containers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/tutorials/deploy-java-application-kubernetes-helm&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Deploy a Java application on Kubernetes with Helm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Creating Your First Helm Chart</title>
      
      <link>/guides/kubernetes/create-helm-chart/</link>
      <pubDate>Fri, 05 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/guides/kubernetes/create-helm-chart/</guid>
      <description>

        
        &lt;p&gt;So, you&amp;rsquo;ve got your &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubernetes cluster up and running&lt;/a&gt; and &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes/#step-4-install-helm&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;set up Helm v3.x&lt;/a&gt;, but how do you run your applications on it? This guide walks you through the process of creating your first ever chart, explaining what goes inside these packages and the tools you use to develop them. By the end of it you should have an understanding of the advantages of using Helm to deliver your own applications to your cluster.&lt;/p&gt;
&lt;p&gt;For a typical cloud-native application with a 3-tier architecture, the diagram below illustrates how it might be described in terms of &lt;a href=&#34;http://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubernetes objects&lt;/a&gt;. In this example, each tier consists of a &lt;a href=&#34;http://kubernetes.io/docs/user-guide/deployments/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Deployment&lt;/a&gt; and &lt;a href=&#34;http://kubernetes.io/docs/user-guide/services/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Service&lt;/a&gt; object, and may additionally define &lt;a href=&#34;http://kubernetes.io/docs/user-guide/configmap/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;ConfigMap&lt;/a&gt; or &lt;a href=&#34;http://kubernetes.io/docs/user-guide/secrets/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Secret&lt;/a&gt; objects. Each of these objects are typically defined in separate YAML files, and are fed into the &lt;em&gt;kubectl&lt;/em&gt; command line tool.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/create-helm-chart/diagrams/three-tier-kubernetes-architecture.png&#34; alt=&#34;3-tier application architecture on Kubernetes&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;A Helm chart encapsulates each of these YAML definitions, provides a mechanism for configuration at deploy-time and allows you to define metadata and documentation that might be useful when sharing the package. Helm can be useful in different scenarios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Find and use popular software packaged as Kubernetes charts&lt;/li&gt;
&lt;li&gt;Share your own applications as Kubernetes charts&lt;/li&gt;
&lt;li&gt;Create reproducible builds of your Kubernetes applications&lt;/li&gt;
&lt;li&gt;Intelligently manage your Kubernetes object definitions&lt;/li&gt;
&lt;li&gt;Manage releases of Helm packages&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&amp;rsquo;s explore the second and third scenarios by creating our first chart.&lt;/p&gt;
&lt;h2 id=&#34;step-1-generate-your-first-chart&#34;&gt;Step 1: Generate your first chart&lt;/h2&gt;
&lt;p&gt;The best way to get started with a new chart is to use the &lt;em&gt;helm create&lt;/em&gt; command to scaffold out an example we can build on. Use this command to create a new chart named &lt;em&gt;mychart&lt;/em&gt; in a new directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm create mychart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Helm will create a new directory in your project called &lt;em&gt;mychart&lt;/em&gt; with the structure shown below. Let&amp;rsquo;s navigate our new chart (pun intended) to find out how it works.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mychart
|-- Chart.yaml
|-- charts
|-- templates
|   |-- NOTES.txt
|   |-- _helpers.tpl
|   |-- deployment.yaml
|   |-- ingress.yaml
|   `-- service.yaml
`-- values.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;templates&#34;&gt;Templates&lt;/h3&gt;
&lt;p&gt;The most important piece of the puzzle is the &lt;em&gt;templates/&lt;/em&gt; directory. This is where Helm finds the YAML definitions for your Services, Deployments and other Kubernetes objects. If you already have definitions for your application, all you need to do is replace the generated YAML files for your own. What you end up with is a working chart that can be deployed using the &lt;em&gt;helm install&lt;/em&gt; command.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s worth noting however, that the directory is named &lt;em&gt;templates&lt;/em&gt;, and Helm runs each file in this directory through a &lt;a href=&#34;https://golang.org/pkg/text/template/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Go template&lt;/a&gt; rendering engine. Helm extends the template language, adding a number of utility functions for writing charts. Open the &lt;em&gt;service.yaml&lt;/em&gt; file to see what this looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
name: {{ template &amp;quot;fullname&amp;quot; . }}
labels:
    chart: &amp;quot;{{ .Chart.Name }}-{{ .Chart.Version | replace &amp;quot;+&amp;quot; &amp;quot;_&amp;quot; }}&amp;quot;
spec:
type: {{ .Values.service.type }}
ports:
- port: {{ .Values.service.externalPort }}
    targetPort: {{ .Values.service.internalPort }}
    protocol: TCP
    name: {{ .Values.service.name }}
selector:
    app: {{ template &amp;quot;fullname&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a basic Service definition using templating. When deploying the chart, Helm will generate a definition that will look a lot more like a valid Service. We can do a dry-run of a &lt;em&gt;helm install&lt;/em&gt; and enable debug to inspect the generated definitions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm install --dry-run --debug ./mychart
...
# Source: mychart/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
name: pouring-puma-mychart
labels:
    chart: &amp;quot;mychart-0.1.0&amp;quot;
spec:
type: ClusterIP
ports:
- port: 80
    targetPort: 80
    protocol: TCP
    name: nginx
selector:
    app: pouring-puma-mychart
...
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;values&#34;&gt;Values&lt;/h4&gt;
&lt;p&gt;The template in &lt;em&gt;service.yaml&lt;/em&gt; makes use of the Helm-specific objects &lt;em&gt;.Chart&lt;/em&gt; and &lt;em&gt;.Values.&lt;/em&gt;. The former provides metadata about the chart to your definitions such as the name, or version. The latter &lt;em&gt;.Values&lt;/em&gt; object is a key element of Helm charts, used to expose configuration that can be set at the time of deployment. The defaults for this object are defined in the &lt;em&gt;values.yaml&lt;/em&gt; file. Try changing the default value for &lt;em&gt;service.internalPort&lt;/em&gt; and execute another dry-run, you should find that the &lt;em&gt;targetPort&lt;/em&gt; in the Service and the &lt;em&gt;containerPort&lt;/em&gt; in the Deployment changes. The &lt;em&gt;service.internalPort&lt;/em&gt; value is used here to ensure that the Service and Deployment objects work together correctly. The use of templating can greatly reduce boilerplate and simplify your definitions.&lt;/p&gt;
&lt;p&gt;If a user of your chart wanted to change the default configuration, they could provide overrides directly on the command-line:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install --dry-run --debug ./mychart --set service.internalPort&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For more advanced configuration, a user can specify a YAML file containing overrides with the &lt;em&gt;--values&lt;/em&gt; option.&lt;/p&gt;
&lt;h4 id=&#34;helpers-and-other-functions&#34;&gt;Helpers and other functions&lt;/h4&gt;
&lt;p&gt;The &lt;em&gt;service.yaml&lt;/em&gt; template also makes use of partials defined in &lt;em&gt;_helpers.tpl&lt;/em&gt;, as well as functions like &lt;em&gt;replace&lt;/em&gt;. The &lt;a href=&#34;https://helm.sh/docs/chart_template_guide/getting_started/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm documentation&lt;/a&gt; has a deeper walkthrough of the templating language, explaining how functions, partials and flow control can be used when developing your chart.&lt;/p&gt;
&lt;h3 id=&#34;documentation&#34;&gt;Documentation&lt;/h3&gt;
&lt;p&gt;Another useful file in the &lt;em&gt;templates/&lt;/em&gt; directory is the &lt;em&gt;NOTES.txt&lt;/em&gt; file. This is a templated, plaintext file that gets printed out after the chart is successfully deployed. As we&amp;rsquo;ll see when we deploy our first chart, this is a useful place to briefly describe the next steps for using a chart. Since &lt;em&gt;NOTES.txt&lt;/em&gt; is run through the template engine, you can use templating to print out working commands for obtaining an IP address, or getting a password from a Secret object.&lt;/p&gt;
&lt;h3 id=&#34;metadata&#34;&gt;Metadata&lt;/h3&gt;
&lt;p&gt;As mentioned earlier, a Helm chart consists of metadata that is used to help describe what the application is, define constraints on the minimum required Kubernetes and/or Helm version and manage the version of your chart. All of this metadata lives in the &lt;em&gt;Chart.yaml&lt;/em&gt; file. The &lt;a href=&#34;https://helm.sh/docs/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm documentation&lt;/a&gt; describes the different fields for this file.&lt;/p&gt;
&lt;h2 id=&#34;step-2-deploy-your-first-chart&#34;&gt;Step 2: Deploy your first chart&lt;/h2&gt;
&lt;p&gt;The chart you generated in the previous step is set up to run an NGINX server exposed via a Kubernetes Service. By default, the chart will create a &lt;em&gt;ClusterIP&lt;/em&gt; type Service, so NGINX will only be exposed internally in the cluster. To access it externally, we&amp;rsquo;ll use the &lt;em&gt;NodePort&lt;/em&gt; type instead. We can also set the name of the Helm release so we can easily refer back to it. Let&amp;rsquo;s go ahead and deploy our NGINX chart using the &lt;em&gt;helm install&lt;/em&gt; command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install example ./mychart --set service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;NodePort
NAME:   example
LAST DEPLOYED: Tue May  &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; 20:03:27 &lt;span class=&#34;m&#34;&gt;2017&lt;/span&gt;
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; v1/Service
NAME             CLUSTER-IP  EXTERNAL-IP  PORT&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;       AGE
example-mychart  10.0.0.24   &amp;lt;nodes&amp;gt;      80:30630/TCP  &lt;span class=&#34;nv&#34;&gt;0s&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; v1beta1/Deployment
NAME             DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE
example-mychart  &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;           &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          0s

NOTES:
1. Get the application URL by running these commands:
&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_PORT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl get --namespace default -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.spec.ports[0].nodePort}&amp;#34;&lt;/span&gt; services example-mychart&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_IP&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl get nodes --namespace default -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.items[0].status.addresses[0].address}&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; http://&lt;span class=&#34;nv&#34;&gt;$NODE_IP&lt;/span&gt;:&lt;span class=&#34;nv&#34;&gt;$NODE_PORT&lt;/span&gt;/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The output of &lt;em&gt;helm install&lt;/em&gt; displays a handy summary of the state of the release, what objects were created, and the rendered &lt;em&gt;NOTES.txt&lt;/em&gt; file to explain what to do next. Run the commands in the output to get a URL to access the NGINX service and pull it up in your browser.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/create-helm-chart/nginx-server.png&#34; alt=&#34;nginx server default page&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;If all went well, you should see the NGINX welcome page as shown above. Congratulations! You&amp;rsquo;ve just deployed your very first service packaged as a Helm chart!&lt;/p&gt;
&lt;h2 id=&#34;step-3-modify-chart-to-deploy-a-custom-service&#34;&gt;Step 3: Modify chart to deploy a custom service&lt;/h2&gt;
&lt;p&gt;The generated chart creates a Deployment object designed to run an image provided by the default values. This means all we need to do to run a different service is to change the referenced image in &lt;em&gt;values.yaml&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We are going to update the chart to run a &lt;a href=&#34;https://github.com/prydonius/todomvc/tree/master/examples/react&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;todo list application&lt;/a&gt; available on &lt;a href=&#34;https://hub.docker.com/r/prydonius/todo/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker Hub&lt;/a&gt;. In &lt;em&gt;values.yaml&lt;/em&gt;, update the image keys to reference the todo list image:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;image:
repository: prydonius/todo
tag: 1.0.0
pullPolicy: IfNotPresent
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you develop your chart, it&amp;rsquo;s a good idea to run it through the linter to ensure you&amp;rsquo;re following best practices and that your templates are well-formed. Run the &lt;em&gt;helm lint&lt;/em&gt; command to see the linter in action:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm lint ./mychart
&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; Linting ./mychart
&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;INFO&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Chart.yaml: icon is recommended

&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; chart&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;s&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; linted, no failures
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The linter didn&amp;rsquo;t complain about any major issues with the chart, so we&amp;rsquo;re good to go. However, as an example, here is what the linter might output if you managed to get something wrong:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;malformed&amp;#34;&lt;/span&gt; &amp;gt; mychart/values.yaml
helm lint ./mychart
&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; Linting mychart
&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;INFO&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Chart.yaml: icon is recommended
&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;ERROR&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; values.yaml: unable to parse YAML
    error converting YAML to JSON: yaml: line 34: could not find expected &lt;span class=&#34;s1&#34;&gt;&amp;#39;:&amp;#39;&lt;/span&gt;

Error: &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; chart&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;s&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; linted, &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; chart&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;s&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; failed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This time, the linter tells us that it was unable to parse my &lt;em&gt;values.yaml&lt;/em&gt; file correctly. With the line number hint, we can easily find the fix the bug we introduced.&lt;/p&gt;
&lt;p&gt;Now that the chart is once again valid, run &lt;em&gt;helm install&lt;/em&gt; again to deploy the todo list application:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install example2 ./mychart --set service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;NodePort
NAME:   example2
LAST DEPLOYED: Wed May  &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; 12:10:03 &lt;span class=&#34;m&#34;&gt;2017&lt;/span&gt;
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; v1/Service
NAME              CLUSTER-IP  EXTERNAL-IP  PORT&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;       AGE
example2-mychart  10.0.0.78   &amp;lt;nodes&amp;gt;      80:31381/TCP  &lt;span class=&#34;nv&#34;&gt;0s&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; apps/v1/Deployment
NAME              DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE
example2-mychart  &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;           &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          0s


NOTES:
1. Get the application URL by running these commands:
&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_PORT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl get --namespace default -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.spec.ports[0].nodePort}&amp;#34;&lt;/span&gt; services example2-mychart&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_IP&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl get nodes --namespace default -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.items[0].status.addresses[0].address}&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; http://&lt;span class=&#34;nv&#34;&gt;$NODE_IP&lt;/span&gt;:&lt;span class=&#34;nv&#34;&gt;$NODE_PORT&lt;/span&gt;/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Once again, we can run the commands in the NOTES to get a URL to access our application.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/create-helm-chart/todo-list-app.png&#34; alt=&#34;Todo List Application&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;If you have already built containers for your applications, you can run them with your chart by updating the default values or the &lt;em&gt;Deployment&lt;/em&gt; template. Check out the Bitnami Docs for an &lt;a href=&#34;https://docs.bitnami.com/tutorials/deploy-custom-nodejs-app-bitnami-containers/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;introduction to containerizing your applications&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;step-4-package-it-all-up-to-share&#34;&gt;Step 4: Package it all up to share&lt;/h2&gt;
&lt;p&gt;So far in this tutorial, we&amp;rsquo;ve been using the &lt;em&gt;helm install&lt;/em&gt; command to install a local, unpacked chart. However, if you are looking to share your charts with your team or the community, your consumers will typically install the charts from a tar package. We can use &lt;em&gt;helm package&lt;/em&gt; to create the tar package:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm package ./mychart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Helm will create a &lt;em&gt;mychart-0.1.0.tgz&lt;/em&gt; package in our working directory, using the name and version from the metadata defined in the &lt;em&gt;Chart.yaml&lt;/em&gt; file. A user can install from this package instead of a local directory by passing the package as the parameter to &lt;em&gt;helm install&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install example3 mychart-0.1.0.tgz --set service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;NodePort
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;repositories&#34;&gt;Repositories&lt;/h3&gt;
&lt;p&gt;In order to make it much easier to share packages, Helm has built-in support for installing packages from an HTTP server. Helm reads a repository index hosted on the server which describes what chart packages are available and where they are located.&lt;/p&gt;
&lt;p&gt;We can use the &lt;em&gt;helm serve&lt;/em&gt; command to run a local repository to serve our chart.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm serve
Regenerating index. This may take a moment.
Now serving you on 127.0.0.1:8879
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now, in a separate terminal window, you should be able to see your chart in the local repository and install it from there:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm search &lt;span class=&#34;nb&#34;&gt;local&lt;/span&gt;
NAME         	VERSION	DESCRIPTION
local/mychart	0.1.0  	A Helm chart &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; Kubernetes

helm install example4 local/mychart --set service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;NodePort
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To set up a remote repository you can follow the guide in the &lt;a href=&#34;https://github.com/kubernetes/helm/blob/master/docs/chart_repository.md&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm documentation&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h2&gt;
&lt;p&gt;As the applications your packaging as charts increase in complexity, you might find you need to pull in a dependency such as a database. Helm allows you to specify sub-charts that will be created as part of the same release. To define a dependency, create a &lt;em&gt;requirements.yaml&lt;/em&gt; file in the chart root directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;cat &amp;gt; ./mychart/requirements.yaml &lt;span class=&#34;s&#34;&gt;&amp;lt;&amp;lt;EOF
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;dependencies:
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;- name: mariadb
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;version: 0.6.0
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;repository: https://charts.helm.sh/stable
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;EOF&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Much like a runtime language dependency file (such as Python&amp;rsquo;s &lt;em&gt;requirements.txt&lt;/em&gt;), the &lt;em&gt;requirements.yaml&lt;/em&gt; file allows you to manage your chart&amp;rsquo;s dependencies and their versions. When updating dependencies, a lockfile is generated so that subsequent fetching of dependencies use a known, working version. Run the following command to pull in the MariaDB dependency we defined:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm dep update ./mychart
Hang tight &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; we grab the latest from your chart repositories...
...Unable to get an update from the &lt;span class=&#34;s2&#34;&gt;&amp;#34;local&amp;#34;&lt;/span&gt; chart repository &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;http://127.0.0.1:8879/charts&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;:
    Get http://127.0.0.1:8879/charts/index.yaml: dial tcp 127.0.0.1:8879: getsockopt: connection refused
...Successfully got an update from the &lt;span class=&#34;s2&#34;&gt;&amp;#34;bitnami&amp;#34;&lt;/span&gt; chart repository
...Successfully got an update from the &lt;span class=&#34;s2&#34;&gt;&amp;#34;incubator&amp;#34;&lt;/span&gt; chart repository
Update Complete. *Happy Helming!*
Saving &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; charts
Downloading mariadb from repo
$ ls ./mychart/charts
mariadb-0.6.0.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Helm has found a matching version in the &lt;em&gt;bitnami&lt;/em&gt; repository and has fetched it into my chart&amp;rsquo;s sub-chart directory. Now when we go and install the chart, we&amp;rsquo;ll see that MariaDB&amp;rsquo;s objects are created too:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install example5 ./mychart --set service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;NodePort
NAME:   example5
LAST DEPLOYED: Wed May  &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; 16:28:18 &lt;span class=&#34;m&#34;&gt;2017&lt;/span&gt;
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; v1/Secret
NAME              TYPE    DATA  AGE
example5-mariadb  Opaque  &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;     &lt;span class=&#34;nv&#34;&gt;1s&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; v1/ConfigMap
NAME              DATA  AGE
example5-mariadb  &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;     &lt;span class=&#34;nv&#34;&gt;1s&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; v1/PersistentVolumeClaim
NAME              STATUS  VOLUME                                    CAPACITY  ACCESSMODES  AGE
example5-mariadb  Bound   pvc-229f9ed6-3015-11e7-945a-66fc987ccf32  8Gi       RWO          &lt;span class=&#34;nv&#34;&gt;1s&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; v1/Service
NAME              CLUSTER-IP  EXTERNAL-IP  PORT&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;       AGE
example5-mychart  10.0.0.144  &amp;lt;nodes&amp;gt;      80:30896/TCP  1s
example5-mariadb  10.0.0.108  &amp;lt;none&amp;gt;       3306/TCP      &lt;span class=&#34;nv&#34;&gt;1s&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; apps/v1/Deployment
NAME              DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE
example5-mariadb  &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;           &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          1s
example5-mychart  &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;           &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          1s


NOTES:
1. Get the application URL by running these commands:
&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_PORT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl get --namespace default -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.spec.ports[0].nodePort}&amp;#34;&lt;/span&gt; services example5-mychart&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_IP&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl get nodes --namespace default -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.items[0].status.addresses[0].address}&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; http://&lt;span class=&#34;nv&#34;&gt;$NODE_IP&lt;/span&gt;:&lt;span class=&#34;nv&#34;&gt;$NODE_PORT&lt;/span&gt;/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;contribute-to-the-bitnami-repository&#34;&gt;Contribute to the Bitnami repository!&lt;/h2&gt;
&lt;p&gt;As a chart author, you can help to build out Bitnami&amp;rsquo;s chart repository by improving existing charts or submitting new ones. Checkout &lt;a href=&#34;https://kubeapps.com&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;https://kubeapps.com&lt;/a&gt; to see what&amp;rsquo;s currently available and head to &lt;a href=&#34;https://github.com/bitnami/charts&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;https://github.com/bitnami/charts&lt;/a&gt; to get involved.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;p&gt;We&amp;rsquo;ve walked through some of the ways Helm supercharges the delivery of applications on Kubernetes. From an empty directory, you were able to get a working Helm chart out of a single command, deploy it to your cluster and access an NGINX server. Then, by simply changing a few lines and re-deploying, you had a much more useful todo list application running on your cluster! Beyond templating, linting, sharing and managing dependencies, here are some other useful tools available to chart authors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/helm/blob/master/docs/charts_hooks.md&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Define hooks to run &lt;em&gt;Jobs&lt;/em&gt; before or after installing and upgrading releases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/helm/blob/master/docs/provenance.md&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Sign chart packages to help users verify its integrity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/helm/blob/master/docs/chart_tests.md&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Write integration/validation tests for your charts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/helm/blob/master/docs/charts_tips_and_tricks.md&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Employ a handful of tricks in your chart templates&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Move a Custom Spring Boot Application to Production Using Bitnami Helm Charts</title>
      
      <link>/guides/containers/deploy-spring-boot-application-production-helm/</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/guides/containers/deploy-spring-boot-application-production-helm/</guid>
      <description>

        
        &lt;p&gt;Bitnami provides ready-to-run &lt;a href=&#34;https://github.com/bitnami/charts&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm charts&lt;/a&gt; that can be directly deployed on &lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubernetes&lt;/a&gt; and also infrastructure charts that can help you deploy your custom applications. That is the case of the &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/tomcat&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Tomcat Helm chart&lt;/a&gt; that with some tweaks can be used to run Java applications in production easily.&lt;/p&gt;
&lt;p&gt;This tutorial walks you through the process of deploying a Spring Boot container image on Kubernetes using the Bitnami Apache Tomcat Helm chart. It uses the resulting image created in the &lt;a href=&#34;../deploy-locally-spring-boot-application-docker&#34;&gt;Deploy locally a Spring Boot application using Bitnami containers&lt;/a&gt; guide as an example. While the Bitnami Tomcat Helm chart will be modified to get the application container from the DockerHub registry, create a secret to secure the application pod and connect it to a MariaDB pod.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and prerequisites&lt;/h2&gt;
&lt;p&gt;This guide makes the following assumptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have basic knowledge of &lt;a href=&#34;https://www.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker&lt;/a&gt; containers.&lt;/li&gt;
&lt;li&gt;You have a Docker environment installed and configured. &lt;a href=&#34;https://docs.docker.com/install/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about installing Docker&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a Docker Hub account. &lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Register for a free account&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a &lt;a href=&#34;https://docs.bitnami.com/tutorials/deploy-locally-spring-boot-application-docker/#step-6-publish-the-docker-image&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Spring Boot container published&lt;/a&gt; in a container registry (this tutorial assumes that you are using &lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker Hub&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;You have a &lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubernetes cluster running&lt;/a&gt; in the platform of your choice. This tutorial uses &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Minikube&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have the &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes/#step-3-install-kubectl-command-line&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;em&gt;kubectl&lt;/em&gt; command line (&lt;em&gt;kubectl&lt;/em&gt; CLI)&lt;/a&gt; installed.&lt;/li&gt;
&lt;li&gt;You have &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes/#step-4-install-helm&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm v3.x&lt;/a&gt; installed.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following are the steps you will complete in this guide:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Step 1: Create the Helm chart&lt;/li&gt;
&lt;li&gt;Step 2: Adapt the Helm chart to include the source code and database&lt;/li&gt;
&lt;li&gt;Step 3: Create a secret to secure the deployment&lt;/li&gt;
&lt;li&gt;Step 4: Deploy the example application in Kubernetes&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Learn how to create a Spring Boot Docker container image in the &lt;a href=&#34;../deploy-locally-spring-boot-application-docker&#34;&gt;Deploy locally a Spring Boot application using Bitnami containers&lt;/a&gt; guide.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;step-1-create-the-helm-chart&#34;&gt;Step 1: Create the Helm chart&lt;/h2&gt;
&lt;p&gt;Begin by creating the Helm chart for our application. In this case, the Bitnami Tomcat Helm chart will serve you as a starting point which you can modify to build your custom chart. To do so, execute the following command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;helm fetch bitnami/tomcat --untar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will create a folder in your local system that contains all the files required for deploying Tomcat in a Kubernetes cluster.&lt;/p&gt;
&lt;h2 id=&#34;step-2-adapt-the-helm-chart-to-include-the-source-code-and-database&#34;&gt;Step 2: Adapt the Helm chart to include the source code and database&lt;/h2&gt;
&lt;p&gt;The first step consists of adapting the current Bitnami Tomcat Helm chart to include the sample Spring Boot container image and MariaDB as a database. Then, connect both pods when deploying the resulting chart. Follow the instructions below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Change to the &lt;em&gt;tomcat&lt;/em&gt; directory and create a file named &lt;em&gt;requirements.yaml&lt;/em&gt; with the content below to include MariaDB as a dependency:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;dependencies:
- name: mariadb
  version: 5.x.x
  repository: https://charts.helm.sh/stable/
  condition: mariadb.enabled
  tags:
    - spring-java-app-database
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Edit the &lt;em&gt;values.yaml&lt;/em&gt; file and replace the default values with the following to include your image. Remember to replace the DOCKER_USERNAME placeholder with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;[...]
image:
   registry: docker.io
   repository: DOCKER_USERNAME/spring-java-app
   tag: latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Add the following lines at the end of the &lt;em&gt;values.yaml&lt;/em&gt; file to specify the database:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;[...]
mariadb:
   Whether to deploy a mariadb server to satisfy the applications database requirements. To use an external database set this to false and configure the externalDatabase parameters
  enabled: true
   Disable MariaDB replication
  replication:
    enabled: false
   Create a database and a database user
   ref: https://github.com/bitnami/bitnami-docker-mariadb/blob/master/README.mdcreating-a-database-user-on-first-run

  db:
    name: db_example
    user: springuser
   If the password is not specified, mariadb will generates a random password

  password: ThePassword
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Edit the &lt;em&gt;templates/_helpers.tpl&lt;/em&gt; and add the lines below to generate the name of the MariaDB service so the application will be able to connect to it:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;{{/*
Create a default fully qualified app name.
We truncate at 63 chars because some Kubernetes name fields are limited to this (by the DNS naming spec).
*/}}
{{- define &amp;#34;mariadb.fullname&amp;#34; -}}
{{- printf &amp;#34;%s-%s&amp;#34; .Release.Name &amp;#34;mariadb&amp;#34; | trunc 63 | trimSuffix &amp;#34;-&amp;#34; -}}
{{- end -}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-3-create-a-secret-to-secure-the-deployment&#34;&gt;Step 3: Create a secret to secure the deployment&lt;/h2&gt;
&lt;p&gt;The next step is to create a secret for the Spring Boot application that secures the connection between the application and the database. Follow these instructions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In the &lt;em&gt;templates&lt;/em&gt; directory, create a file named &lt;em&gt;spring-secret.yaml&lt;/em&gt; that includes the following content:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;apiVersion: v1
kind: Secret
metadata:
  name: {{ template &amp;#34;tomcat.fullname&amp;#34; . }}-spring
  labels:
    app: {{ template &amp;#34;tomcat.fullname&amp;#34; . }}
    chart: &amp;#34;{{ .Chart.Name }}-{{ .Chart.Version }}&amp;#34;
    release: &amp;#34;{{ .Release.Name }}&amp;#34;
    heritage: &amp;#34;{{ .Release.Service }}&amp;#34;
type: Opaque
data:
  spring-db: {{ printf &amp;#34;{\&amp;#34;spring\&amp;#34;: {\&amp;#34;datasource\&amp;#34;:{\&amp;#34;url\&amp;#34;: \&amp;#34;jdbc:mysql://%s:3306/%s\&amp;#34;, \&amp;#34;username\&amp;#34;: \&amp;#34;%s\&amp;#34;, \&amp;#34;password\&amp;#34;: \&amp;#34;%s\&amp;#34;}}}&amp;#34; (include &amp;#34;mariadb.fullname&amp;#34; .) .Values.mariadb.db.name .Values.mariadb.db.user .Values.mariadb.db.password | b64enc }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Edit the &lt;em&gt;templates/deployment.yaml&lt;/em&gt; file to add the lines below. These refer to the secret created in the step above:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;[...]
- name: TOMCAT_PASSWORD
  valueFrom:
    secretKeyRef:
      name: {{ template &amp;#34;tomcat.fullname&amp;#34; . }}
      key: tomcat-password
- name: SPRING_APPLICATION_JSON
  valueFrom:
    secretKeyRef:
      name: {{ template &amp;#34;tomcat.fullname&amp;#34; . }}-spring
      key: spring-db
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-4-deploy-the-example-application-in-kubernetes&#34;&gt;Step 4: Deploy the example application in Kubernetes&lt;/h2&gt;
&lt;p&gt;Before deploying the resulting Helm chart, make sure that you can connect to your Kubernetes cluster by running this command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;kubectl cluster-info
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Execute the command below to install missing dependencies. In this case, it will install the database that we have indicated in the &lt;em&gt;requirements.yaml&lt;/em&gt; file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;helm dependency update .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Deploy the chart by executing the &lt;em&gt;helm install&lt;/em&gt; command. It is recommended to install it by passing a name using the &lt;em&gt;/&amp;ndash;n&lt;/em&gt; flag.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;helm install spring-java .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Check that all pods are ready by executing the &lt;em&gt;kubectl get pods&lt;/em&gt; command. Take into account that the database pod takes more time to be deployed than the Tomcat pod, is possible that the &lt;em&gt;kubectl logs&lt;/em&gt; command show errors during that time.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;kubectl get pods -w
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You should see an output similar to this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/containers/bitnami/deploy-spring-boot-application-production-helm/get-pods.png&#34; alt=&#34;Pod status&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To test that the Spring Boot application has been successfully deployed it is necessary to make it accessible from your local system. To do so, port forward the Tomcat pod as shown below. Replace &lt;em&gt;svc/spring-java-tomcat&lt;/em&gt; with the name of the service that appears in your deployment:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;kubectl port-forward svc/spring-java-tomcat 8080:80
Forwarding from 127.0.0.1:8080 -&amp;gt; 8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To test if the application works fine, open a new terminal and insert some data in the database by executing:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;curl &amp;#39;localhost:8080/gs-mysql-data-0.1.0/demo/add?name=First&amp;amp;email=someemail@someemailprovider.com&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Query the application again to check if the data is present in the database:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;curl &amp;#39;localhost:8080/gs-mysql-data-0.1.0/demo/all&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You should get an output similar to this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;[{&amp;#34;id&amp;#34;:1, &amp;#34;name&amp;#34;:&amp;#34;First&amp;#34;, &amp;#34;email&amp;#34;:&amp;#34;someemail@someemailprovider.com&amp;#34;}]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Congratulations! You have your Spring Boot application running in a Kubernetes production cluster and ready to use!&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bitnami.com/kubernetes&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Kubernetes projects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../deploy-locally-spring-boot-application-docker&#34;&gt;Deploy locally a Spring Boot application using Bitnami containers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com//kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Get started with Kubernetes guides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/tutorials/deploy-application-kubernetes-helm/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Deploy, Scale And Upgrade An Application On Kubernetes With Helm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/tomcat&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Tomcat Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Helm charts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hub.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker Hub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://spring.io/projects/spring-boot&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Spring Boot official site&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/tutorials&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami tutorials repository&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Best Practices for Creating Production-Ready Helm Charts</title>
      
      <link>/guides/kubernetes/production-ready-helm/</link>
      <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/guides/kubernetes/production-ready-helm/</guid>
      <description>

        
        &lt;p&gt;Three years have passed since &lt;a href=&#34;https://github.com/helm/helm/releases?after=v1.1&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;the first release of Helm&lt;/a&gt;, and it has indeed made a name for itself. Both avowed fans and fervent haters agree that the Kubernetes &amp;ldquo;apt-get equivalent&amp;rdquo; is the standard way of deploying to production (at least for now, let&amp;rsquo;s see what Operators end up bringing to the table). During this time, Bitnami has contributed to the project in many ways. You can find us in PRs in Helm&amp;rsquo;s code, in solutions like &lt;a href=&#34;https://hub.kubeapps.com/charts/bitnami&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubeapps&lt;/a&gt;, and especially in what we are mostly known for: &lt;a href=&#34;https://bitnami.com/stacks/helm&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;our huge application library&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As maintainers of a collection of more than &lt;a href=&#34;https://github.com/bitnami/charts/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;45 Helm charts&lt;/a&gt;, we know that creating a maintainable, secure and production-ready chart is far from trivial. In this sense, this blog post shows essential features that any chart developer should know.&lt;/p&gt;
&lt;h2 id=&#34;use-non-root-containers&#34;&gt;Use non-root containers&lt;/h2&gt;
&lt;p&gt;Ensuring that a container is able to perform only a very limited set of operations is vital for production deployments. This is possible thanks to the &lt;strong&gt;use of non-root containers, which are executed by a user different from &lt;em&gt;root&lt;/em&gt;.&lt;/strong&gt; Although creating a non-root container is a bit more complex than a root container (especially regarding filesystem permissions), it is absolutely worth it. Also, in environments like OpenShift, &lt;a href=&#34;https://engineering.bitnami.com/articles/running-non-root-containers-on-openshift.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;using non-root containers is mandatory&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In order to make your Helm chart work with non-root containers, add the &lt;a href=&#34;https://kubernetes.io/docs/tasks/configure-pod-container/security-context/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;em&gt;securityContext&lt;/em&gt;&lt;/a&gt; section to your &lt;em&gt;yaml&lt;/em&gt; files.&lt;/p&gt;
&lt;p&gt;This is what we do, for instance, in the Bitnami Elasticsearch Helm chart. This chart deploys several Elasticsearch &lt;em&gt;StatefulSets&lt;/em&gt; and &lt;em&gt;Deployments&lt;/em&gt; (data, ingestion, coordinating and master nodes), all of them with non-root containers. If we check the master node &lt;em&gt;StatefulSet&lt;/em&gt;, we see the following:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.securityContext.enabled }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;securityContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fsGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.securityContext.fsGroup }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The snippet above changes the permissions of the mounted volumes, so the container user can access them for read/write operations. In addition to this, inside the container definition, we see another &lt;em&gt;securityContext&lt;/em&gt; block:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.securityContext.enabled }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;securityContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;runAsUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.securityContext.runAsUser }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this part we specify the user running the container. In the &lt;em&gt;values.yaml&lt;/em&gt; file, we set the default values for these parameters:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;## Pod Security Context&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;##&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;securityContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;enabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fsGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1001&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;runAsUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1001&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With these changes, the chart will work as non-root in platforms like GKE, Minikube or OpenShift.&lt;/p&gt;
&lt;h2 id=&#34;do-not-persist-the-configuration&#34;&gt;Do not persist the configuration&lt;/h2&gt;
&lt;p&gt;Adding persistence is an essential part of deploying stateful applications. In our experience, deciding what or what not to persist can be tricky. After several iterations in our charts, we found that &lt;strong&gt;persisting the application configuration is not a recommended practice&lt;/strong&gt;. One advantage of Kubernetes is that you can change the deployment parameters very easily by just doing &lt;code&gt;kubectl edit deployment&lt;/code&gt; or &lt;code&gt;helm upgrade&lt;/code&gt;. If the configuration is persisted, none of the changes would be applied. So, when developing a production-ready Helm chart, make sure that the configuration can be easily changed with &lt;code&gt;kubectl&lt;/code&gt; or &lt;code&gt;helm upgrade&lt;/code&gt;. One common practice is to create a &lt;em&gt;ConfigMap&lt;/em&gt; with the configuration and have it mounted in the container. Let&amp;rsquo;s use the &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/rabbitmq&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami RabbitMQ chart&lt;/a&gt; as an example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ConfigMap&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;rabbitmq.fullname&amp;#34; . }}-config&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;rabbitmq.name&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;chart&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;rabbitmq.chart&amp;#34; .  }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{{ .Release.Name }}&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;heritage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{{ .Release.Service }}&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;enabled_plugins&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;|-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;rabbitmq.plugins&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rabbitmq.conf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|-&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    ##username and password
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    default_user={{.Values.rabbitmq.username}}
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    default_pass=CHANGEME&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.rabbitmq.configuration | indent 4 }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.rabbitmq.extraConfiguration | indent 4 }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that there is a section in the &lt;em&gt;values.yaml&lt;/em&gt; file that allows you to include any custom configuration:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;## Configuration file content: required cluster configuration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;## Do not override unless you know what you are doing. To add more configuration, use `extraConfiguration` instead&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;configuration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|-&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    ## Clustering
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    cluster_formation.peer_discovery_backend  = rabbit_peer_discovery_k8s
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    cluster_formation.k8s.host = kubernetes.default.svc.cluster.local
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    cluster_formation.node_cleanup.interval = 10
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    cluster_formation.node_cleanup.only_log_warning = true
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    cluster_partition_handling = autoheal
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    # queue master locator
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    queue_master_locator=min-masters
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    # enable guest user
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    loopback_users.guest = false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;## Configuration file content: extra configuration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;## Use this instead of  `configuration` to add more configuration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;extraConfiguration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|-&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    #disk_free_limit.absolute = 50MB
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    #management.load_definitions = /app/load_definition.json&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This &lt;em&gt;ConfigMap&lt;/em&gt; then gets mounted in the container filesystem, as shown in this extract of the &lt;em&gt;StatefulSet&lt;/em&gt; spec:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;config-volume&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;configMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;rabbitmq.fullname&amp;#34; . }}-config&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If the application needs to write in the configuration file, then you&amp;rsquo;ll need to create a copy inside the container, as &lt;em&gt;ConfigMaps&lt;/em&gt; are mounted as read-only. This is done in the same spec:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rabbitmq&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;rabbitmq.image&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;imagePullPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.image.pullPolicy | quote }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# ...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;#copy the mounted configuration to both places&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;cp  /opt/bitnami/rabbitmq/conf/* /opt/bitnami/rabbitmq/etc/rabbitmq&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# ...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will make your chart not only easy to upgrade, but also more adaptable to user needs, as they can provide their custom configuration file.&lt;/p&gt;
&lt;h2 id=&#34;integrate-charts-with-logging-and-monitoring-tools&#34;&gt;Integrate charts with logging and monitoring tools&lt;/h2&gt;
&lt;p&gt;If we are talking about production environments, we are talking about observability. It is essential having our deployments properly monitored so we can early detect potential issues. It also essential to have application usage, cost and resource consumption metrics. In order to gather this information, you would commonly deploy logging stacks like EFK (&lt;a href=&#34;https://www.elastic.co/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;ElasticSearch&lt;/a&gt;, &lt;a href=&#34;https://www.fluentd.org/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Fluentd&lt;/a&gt;, and &lt;a href=&#34;https://www.elastic.co/products/kibana&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kibana&lt;/a&gt; and monitoring tools like &lt;a href=&#34;https://prometheus.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Prometheus&lt;/a&gt;. Bitnami offers the &lt;a href=&#34;https://kubeprod.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Kubernetes Production Runtime (BKPR)&lt;/a&gt; that easily installs these tools (along with others) so your cluster is ready to handle production workloads.&lt;/p&gt;
&lt;p&gt;When writing your chart, make sure that your deployment is able to work with the above tools seamlessly. To do so, ensure the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All the containers log to stdout/stderr (so the EFK stack can easily ingest all the logging information)&lt;/li&gt;
&lt;li&gt;Prometheus exporters are included (either using sidecar containers or having a separate deployment)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All Bitnami charts work with BKPR (which includes EFK and Prometheus) out of the box. Let&amp;rsquo;s take a look at the &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/postgresql&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami PostgreSQL chart&lt;/a&gt; and &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-postgresql&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami PostgreSQL container&lt;/a&gt; to see how we did it.&lt;/p&gt;
&lt;p&gt;To begin with, the process inside the container runs at the foreground, so all the logging information is written to stdout/stderr, as shown below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;info &lt;span class=&#34;s2&#34;&gt;&amp;#34;** Starting PostgreSQL **&amp;#34;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; am_i_root&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;then&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; gosu &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$POSTGRESQL_DAEMON_USER&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[@]&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[@]&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With this, we ensured that it works with EFK. Then, in the chart we added a sidecar container for the Prometheus metrics:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.metrics.enabled }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;postgresql.metrics.image&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;imagePullPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.image.pullPolicy | quote }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.metrics.securityContext.enabled }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;securityContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;runAsUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.securityContext.runAsUser }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;$database := required &amp;#34;In order to enable metrics you need to specify a database (.Values.postgresqlDatabase or .Values.global.postgresql.postgresqlDatabase)&amp;#34; (include &amp;#34;postgresql.database&amp;#34; .) }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DATA_SOURCE_URI&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;printf &amp;#34;127.0.0.1:%d/%s?sslmode=disable&amp;#34; (int (include &amp;#34;postgresql.port&amp;#34; .)) $database | quote }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.usePasswordFile }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DATA_SOURCE_PASS_FILE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/bitnami/postgresql/secrets/postgresql-password&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;else }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DATA_SOURCE_PASS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;valueFrom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;secretKeyRef&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;postgresql.secretName&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;postgresql-password&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DATA_SOURCE_USER&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;postgresql.username&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.livenessProbe.enabled }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;livenessProbe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;httpGet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http-metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;initialDelaySeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.livenessProbe.initialDelaySeconds }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;periodSeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.livenessProbe.periodSeconds }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timeoutSeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.livenessProbe.timeoutSeconds }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;successThreshold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.livenessProbe.successThreshold }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;failureThreshold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.livenessProbe.failureThreshold }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.readinessProbe.enabled }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readinessProbe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;httpGet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http-metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;initialDelaySeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.readinessProbe.initialDelaySeconds }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;periodSeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.readinessProbe.periodSeconds }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timeoutSeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.readinessProbe.timeoutSeconds }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;successThreshold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.readinessProbe.successThreshold }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;failureThreshold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.readinessProbe.failureThreshold }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeMounts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.usePasswordFile }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;postgresql-password&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/opt/bitnami/postgresql/secrets/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.metrics.customMetrics }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;custom-metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/conf&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;--extend.query-path&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/conf/custom-metrics.yaml&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http-metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;9187&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.metrics.resources }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;toYaml .Values.metrics.resources | nindent 12 }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We also made sure that the pods or services contain the proper annotations that Prometheus uses to detect exporters. In this case, we defined them in the chart&amp;rsquo;s &lt;em&gt;values.yaml&lt;/em&gt; file, as shown below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;metrics&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;enabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ClusterIP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prometheus.io/scrape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prometheus.io/port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;9187&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;#...  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the case of the PostgreSQL chart, these annotations go to a metrics service, separate from the PostgreSQL service, which is defined as below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;{{- &lt;span class=&#34;l&#34;&gt;if .Values.metrics.enabled }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;postgresql.fullname&amp;#34; . }}-metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;postgresql.name&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;chart&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;postgresql.chart&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Release.Name | quote }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;heritage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Release.Service | quote }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;toYaml .Values.metrics.service.annotations | indent 4 }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.service.type }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;if and (eq .Values.metrics.service.type &amp;#34;LoadBalancer&amp;#34;) .Values.metrics.service.loadBalancerIP }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;loadBalancerIP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Values.metrics.service.loadBalancerIP }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http-metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;9187&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http-metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;template &amp;#34;postgresql.name&amp;#34; . }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.Release.Name }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;role&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;master&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;{{- &lt;span class=&#34;l&#34;&gt;end }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With these modifications, your chart will seamlessly integrate with your monitoring platform. All the obtained metrics will be crucial for maintaining the deployment in good shape.&lt;/p&gt;
&lt;h2 id=&#34;production-workloads-in-kubernetes-are-possible&#34;&gt;Production workloads in Kubernetes are possible&lt;/h2&gt;
&lt;p&gt;Now you know some essential guidelines for creating secured (with non-root containers), adaptable (with proper configuration management), and observable (with proper monitoring) charts. With these features, you have covered the basics to ensure that your application can be deployed to production. However, this is just another step in your journey to mastering Helm. You should also take into account other features like upgradability, usability, stability and testing.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful Links&lt;/h2&gt;
&lt;p&gt;To learn more, check the following links:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://helm.sh/docs/chart_best_practices/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Official Helm chart good practice guidelines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codefresh.io/docs/docs/new-helm/helm-best-practices/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm best practices by CodeFresh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubeprod.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Kubernetes Production Runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Helm charts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hub.kubeapps.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubeapps Hub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Create a Multi-Cluster Monitoring Dashboard with Thanos, Grafana and Prometheus</title>
      
      <link>/guides/kubernetes/prometheus-multicluster-monitoring/</link>
      <pubDate>Wed, 11 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/guides/kubernetes/prometheus-multicluster-monitoring/</guid>
      <description>

        
        &lt;p&gt;&lt;a href=&#34;https://prometheus.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Prometheus&lt;/a&gt;, coupled with
&lt;a href=&#34;https://grafana.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Grafana&lt;/a&gt;, is a popular monitoring solution for Kubernetes
clusters. It allows SRE teams and developers to capture metrics and telemetry
data for applications running in a cluster, allowing deeper insights into
application performance and reliability.&lt;/p&gt;
&lt;p&gt;The Prometheus/Grafana combination works well for individual clusters, but as
teams scale out and start working with multiple clusters, monitoring
requirements become correspondingly more complex. For effective multi-cluster
monitoring, a &amp;ldquo;single pane of glass&amp;rdquo; with centralized real-time monitoring, time
series comparisons across and within clusters and high availability is essential
for teams operating with multiple clusters and multiple providers.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://thanos.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Thanos&lt;/a&gt; is a monitoring system that aggregates data from
multiple Prometheus deployments. This data can then be inspected and analyzed
using Grafana, just as with regular Prometheus metrics. Although this setup
sounds complex, it&amp;rsquo;s actually very easy to achieve with the following Bitnami
Helm charts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/prometheus-operator&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Prometheus Operator Helm chart&lt;/a&gt;
lets you deploy Prometheus in your Kubernetes cluster with an additional
Thanos sidecar container.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/thanos&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Thanos Helm chart&lt;/a&gt;
lets you deploy all the Thanos components together with MinIO and Alertmanager
so you can quickly bootstrap a Thanos deployment.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/grafana&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Grafana Helm chart&lt;/a&gt;
lets you deploy Grafana in your Kubernetes cluster.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This guide walks you through the process of using these charts to create a
Thanos deployment that aggregates data from Prometheus Operators in multiple
clusters and allows further monitoring and analysis using Grafana.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and prerequisites&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;You have three separate multi-node Kubernetes clusters running on the same
cloud provider:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Two &amp;ldquo;data producer&amp;rdquo; clusters which will host Prometheus deployments and
applications that expose metrics via Prometheus.&lt;/li&gt;
&lt;li&gt;One &amp;ldquo;data aggregator&amp;rdquo; cluster which will host Thanos and aggregate the data
from the data producers. This cluster will also host Grafana for data
visualization and reporting.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You have the &lt;em&gt;kubectl&lt;/em&gt; CLI and the Helm v3.x package manager installed and configured to work with your Kubernetes clusters. &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes#step-3-install-kubectl-command-line&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn how to install &lt;em&gt;kubectl&lt;/em&gt; and Helm v3.x&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This guide uses clusters hosted on the Google Kubernetes Engine (GKE) service
but you can use any Kubernetes provider. Learn about
&lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;deploying a Kubernetes cluster on different cloud platforms&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;step-1-install-the-prometheus-operator-on-each-cluster&#34;&gt;Step 1: Install the Prometheus Operator on each cluster&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/prometheus-operator&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Prometheus Operator chart&lt;/a&gt;
provides easy monitoring definitions for Kubernetes services and management of
Prometheus instances. It also includes an optional Thanos sidecar container,
which can be used by your Thanos deployment to access cluster metrics.&lt;/p&gt;
&lt;p&gt;Only one instance of the Prometheus Operator component should be running in a
cluster.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Add the Bitnami charts repository to Helm:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm repo add bitnami https://charts.bitnami.com/bitnami
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Install the Prometheus Operator in the first &amp;ldquo;data producer&amp;rdquo; cluster using the command below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install prometheus-operator &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set prometheus.thanos.create&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set operator.service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ClusterIP &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set prometheus.service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ClusterIP &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set alertmanager.service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ClusterIP &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set prometheus.thanos.service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;LoadBalancer &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set prometheus.externalLabels.cluster&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;data-producer-0&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  bitnami/prometheus-operator
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;em&gt;prometheus.thanos.create&lt;/em&gt; parameter creates a Thanos sidecar container,
while the &lt;em&gt;prometheus.thanos.service.type&lt;/em&gt; parameter makes the sidecar service
available at a public load balancer IP address. Note the
&lt;em&gt;prometheus.externalLabels&lt;/em&gt; parameter which lets you define one or more unique
labels per Prometheus instance - these labels are useful to differentiate
different stores or data sources in Thanos.&lt;/p&gt;
&lt;p&gt;The command above exposes the Thanos sidecar container in each cluster at a
public IP address using a &lt;em&gt;LoadBalancer&lt;/em&gt; service. This makes it easy for
Thanos to access Prometheus metrics in different clusters without needing any
special firewall or routing configuration. However, this approach is highly
insecure and should be used only for demonstration or testing purposes. In
production environments, it is preferable to deploy an NGINX Ingress
Controller to control access from outside the cluster and further limit access
using whitelisting and other security-related configuration.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use the command below to obtain the public IP address of the sidecar service.
You will use this IP address in the next step.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get svc | grep prometheus-operator-prometheus-thanos
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Repeat the steps shown above for the second &amp;ldquo;data producer&amp;rdquo; cluster. Use a
different value for the &lt;em&gt;prometheus.externalLabels.cluster&lt;/em&gt; parameter, such as
&lt;em&gt;data-producer-1&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;step-2-install-and-configure-thanos&#34;&gt;Step 2: Install and configure Thanos&lt;/h2&gt;
&lt;p&gt;The next step is to install Thanos in the &amp;ldquo;data aggregator&amp;rdquo; cluster and
integrate it with Alertmanager and MinIO as the object store.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Modify your Kubernetes context to reflect the cluster on which you wish to install Thanos.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;values.yaml&lt;/em&gt; file as shown below. Replace the KEY placeholder with a
hard-to-guess value and the SIDECAR-SERVICE-IP-ADDRESS-X placeholders with the
public IP addresses of the Thanos sidecar containers in the &amp;ldquo;data producer&amp;rdquo;
clusters.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;objstoreConfig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|-&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;  type: s3
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;  config:
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    bucket: thanos
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    endpoint: {{ include &amp;#34;thanos.minio.fullname&amp;#34; . }}.monitoring.svc.cluster.local:9000
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    access_key: minio
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    secret_key: KEY
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    insecure: true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;querier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;stores&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;SIDECAR-SERVICE-IP-ADDRESS-1:10901&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;SIDECAR-SERVICE-IP-ADDRESS-2:10901&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;bucketweb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;enabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;compactor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;enabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;storegateway&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;enabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ruler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;enabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;alertmanagers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;http://prometheus-operator-alertmanager.monitoring.svc.cluster.local:9093&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|-&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;    groups:
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;      - name: &amp;#34;metamonitoring&amp;#34;
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;        rules:
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;          - alert: &amp;#34;PrometheusDown&amp;#34;
&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;            expr: absent(up{prometheus=&amp;#34;monitoring/prometheus-operator&amp;#34;})&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;minio&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;enabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;accessKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;minio&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;secretKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;KEY&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;defaultBuckets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;thanos&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Install Thanos using the command below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install thanos bitnami/thanos &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --values values.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wait for the deployment to complete and note the DNS name and port number for
the Thanos Querier service in the deployment output, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/querier-service.png&#34; alt=&#34;Thanos Querier service&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Follow the instructions shown in the chart output to connect to the Thanos
Querier Web interface and navigate to the &amp;ldquo;Stores&amp;rdquo; tab. Confirm that both
sidecar services are running and registered with Thanos, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/querier-stores.png&#34; alt=&#34;Thanos Querier stores&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Confirm also that each service displays a unique &lt;em&gt;cluster&lt;/em&gt; labelset, as configured in &lt;a href=&#34;#step-1-install-the-prometheus-operator-on-each-cluster&#34;&gt;Step 1&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-3-install-grafana&#34;&gt;Step 3: Install Grafana&lt;/h2&gt;
&lt;p&gt;The next step is to install Grafana, also on the same &amp;ldquo;data aggregator&amp;rdquo; cluster
as Thanos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Use the command below, replacing GRAFANA-PASSWORD with a password for the
Grafana application:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install grafana bitnami/grafana &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set service.type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;LoadBalancer &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set admin.password&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;GRAFANA-PASSWORD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wait for the deployment to complete and obtain the public IP address for the
Grafana load balancer service:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl get svc &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep grafana
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Confirm that you are able to access Grafana by browsing to the load balancer
IP address on port 3000 and logging in with the username &lt;em&gt;admin&lt;/em&gt; and the
configured password. Here is what you should see:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/grafana-dashboard.png&#34; alt=&#34;Grafana dashboard&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-4-configure-grafana-to-use-thanos-as-a-data-source&#34;&gt;Step 4: Configure Grafana to use Thanos as a data source&lt;/h2&gt;
&lt;p&gt;Follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;From the Grafana dashboard, click the &amp;ldquo;Add data source&amp;rdquo; button.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;On the &amp;ldquo;Choose data source type&amp;rdquo; page, select &amp;ldquo;Prometheus&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/grafana-add-data-source.png&#34; alt=&#34;Grafana data source&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;On the &amp;ldquo;Settings&amp;rdquo; page, set the URL for the Prometheus server to
&lt;em&gt;http://NAME:PORT&lt;/em&gt;, where NAME is the DNS name for the Thanos service obtained
at the end of &lt;a href=&#34;#step-2-install-and-configure-thanos&#34;&gt;Step 2&lt;/a&gt; and PORT is the
corresponding service port. Leave all other values at their default.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/grafana-thanos-url.png&#34; alt=&#34;Grafana data source configuration&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click &amp;ldquo;Save &amp;amp; Test&amp;rdquo; to save and test the configuration. If everything is
configured correctly, you should see a success message like the one below.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/grafana-success.png&#34; alt=&#34;Grafana test&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-5-test-the-system&#34;&gt;Step 5: Test the system&lt;/h2&gt;
&lt;p&gt;At this point, you can start deploying applications into your &amp;ldquo;data producer&amp;rdquo;
clusters and collating the metrics in Thanos and Grafana. For demonstration
purposes, this guide will deploy a MariaDB replication cluster using Bitnami&amp;rsquo;s
MariaDB Helm chart in each &amp;ldquo;data producer&amp;rdquo; cluster and display the metrics
generated by each MariaDB service in Grafana.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Deploy MariaDB in each cluster with one master and one slave using the
production configuration with the commands below. Replace the
MARIADB-ADMIN-PASSWORD and MARIADB-REPL-PASSWORD placeholders with the
database administrator account and replication account password respectively.
You can also optionally create a MariaDB user account for application use by
specifying values for the USER-PASSWORD, USER-NAME and DB-NAME placeholders.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install mariadb &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set rootUser.password&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;MARIADB-ADMIN-PASSWORD &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set replication.password&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;MARIADB-REPL-PASSWORD &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set db.user&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;USER-NAME &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set db.password&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;USER-PASSWORD &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set db.name&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;DB-NAME &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set slave.replicas&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set metrics.enabled&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set metrics.serviceMonitor.enabled&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  bitnami/mariadb 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note the &lt;em&gt;metrics.enabled&lt;/em&gt; parameter, which enables the Prometheus exporter
for MySQL server metrics, and the &lt;em&gt;metrics.serviceMonitor.enabled&lt;/em&gt; parameter,
which creates a Prometheus Operator ServiceMonitor.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Once deployment in each cluster is complete, note the instructions to connect
to each database service.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/mariadb-service.png&#34; alt=&#34;MariaDB service&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Browse to the
&lt;a href=&#34;https://github.com/percona/grafana-dashboards/blob/master/dashboards/MySQL_Overview.json&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;MySQL Overview dashboard in the Percona GitHub repository&lt;/a&gt;
and copy the JSON model.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Log in to Grafana. From the Grafana dashboard, click the &amp;ldquo;Import -&amp;gt; Dashboard&amp;rdquo;
menu item.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;On the &amp;ldquo;Import&amp;rdquo; page, paste the JSON model into the &amp;ldquo;Or paste JSON&amp;rdquo; field.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/grafana-dashboard-import.png&#34; alt=&#34;Grafana dashboard import&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click &amp;ldquo;Load&amp;rdquo; to load the data and then &amp;ldquo;Import&amp;rdquo; to import the dashboard. The
new dashboard should appear in Grafana, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/grafana-mysql-dashboard.png&#34; alt=&#34;Grafana MySQL dashboard&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Connect to the MariaDB service in the first &amp;ldquo;data producer&amp;rdquo; cluster and
perform some actions, such as creating a database, adding records to a table
and executing a query. Perform similar actions in the second &amp;ldquo;data producer&amp;rdquo;
cluster. You should see your activity in each cluster reflected in the MySQL
Overview chart in Grafana, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/grafana-metrics.png&#34; alt=&#34;MariaDB metrics in Grafana&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;You can view metrics from individual master and slave nodes in each cluster by
selecting a different host in the &amp;ldquo;Host&amp;rdquo; drop down of the dashboard, as shown
below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/prometheus-multicluster-monitoring/grafana-hosts.png&#34; alt=&#34;MariaDB hosts in Grafana&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can now continue adding more applications to your clusters. So long as you
enable Prometheus metrics and a Prometheus Operator ServiceMonitor for each
deployment, Thanos will continuously receive and aggregate the metrics and you
can inspect them using Grafana.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;p&gt;To learn more about the topics discussed in this guide, use the links below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/prometheus-operator&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Prometheus Operator Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/thanos&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Thanos Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/grafana&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Grafana Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/mariadb&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami MariaDB Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/ingress/tree/master/controllers/nginx&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;NGINX Ingress controller documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/tutorials/secure-kubernetes-services-with-ingress-tls-letsencrypt/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Secure Kubernetes Services with Ingress, TLS and Let&amp;rsquo;s Encrypt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Assign Pods to Nodes With Bitnami Helm Chart Affinity Rules</title>
      
      <link>/guides/kubernetes/assign-pods-to-nodes-with-bitnami-helm-chart-affinity-rules/</link>
      <pubDate>Tue, 13 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>/guides/kubernetes/assign-pods-to-nodes-with-bitnami-helm-chart-affinity-rules/</guid>
      <description>

        
        &lt;p&gt;First published on &lt;a href=&#34;https://docs.bitnami.com/tutorials/assign-pod-nodes-helm-affinity-rules/&#34;&gt;https://docs.bitnami.com/tutorials/assign-pod-nodes-helm-affinity-rules/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;When you install an application in a Kubernetes cluster, the &lt;a href=&#34;https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubernetes scheduler&lt;/a&gt; decides in which nodes the application pods will be installed unless certain constraints are defined. For example, Kubernetes scheduler may decide to install application pods in a node with more available memory. This is mostly useful except when cluster administrators prefer to distribute a group of pods across the cluster in a specific manner. For this use case, they need a tool that can force Kubernetes to follow custom rules specified by the user.&lt;/p&gt;
&lt;p&gt;Affinity rules supply a way to force the scheduler to follow specific rules that determine where pods should be distributed. To help users to implement affinity rules, Bitnami has enhanced its Helm charts by including opinionated affinities in their manifest files. Cluster administrators now only need to define the criteria to be followed by the scheduler when placing application pods in cluster nodes. They can then enable this feature via a simple install-time parameter&lt;/p&gt;
&lt;p&gt;This tutorial will demonstrate the available affinity rules and how they can be adapted to your needs.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and Prerequisites&lt;/h2&gt;
&lt;p&gt;This article assumes that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have a Google Cloud account. &lt;a href=&#34;https://cloud.google.com/free&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Register for a Google Cloud account&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a Kubernetes cluster running with Helm v3.x and &lt;code&gt;kubectl&lt;/code&gt; installed. &lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about getting started with Kubernetes and Helm using different cloud providers&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;callout td-box--gray-darkest p-3 mx-5 border-bottom border-right border-left border-top&#34;&gt;
    &lt;p&gt;This guide uses a Kubernetes cluster created in GKE. These steps are the same for all Kubernetes engines. They donâ€™t work, however, in Minikube, since with Minikube you only can create single-node clusters.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;how-affinity-rules-work-in-bitnami-helm-charts&#34;&gt;How Affinity Rules Work in Bitnami Helm Charts&lt;/h2&gt;
&lt;p&gt;All Bitnami infrastructure solutions available in the &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Helm charts catalog&lt;/a&gt; now include pre-defined affinity rules exposed through the &lt;code&gt;podAffinityPreset&lt;/code&gt; and &lt;code&gt;podAntiAffinitypreset&lt;/code&gt; parameters in their &lt;code&gt;values.yml&lt;/code&gt; file:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/bitnami-helm-chart-affinity-rules/image-1.png&#34; alt=&#34;Pod affinity rules&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Pod affinity and anti-affinity rules allow you to define how the scheduler should behave when locating application pods in your cluster eligible nodes. Depending on the option you choose, the scheduler will behave as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;podAffinityPreset&lt;/code&gt; - Using the &lt;code&gt;podAffinity&lt;/code&gt; rule, the scheduler will locate a new pod on the same node where other pods with the same label are located. This approach is especially helpful to group under the same node pods that meet specific pre-defined patterns.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;podAntiAffinitypreset&lt;/code&gt; - Using the &lt;code&gt;podAntiAffinity&lt;/code&gt; parameter lets the scheduler locates one pod in each node. Thus, you will prevent locating a new pod on the same node as other pods are running. This option is convenient if your deployment will demand high availability.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Having the pods distributed across all nodes allows Kubernetes to ensure high availability of your cluster by keeping running the remaining nodes when one node fails.&lt;/p&gt;
&lt;p&gt;These are the values you can set for both pod affinity and anti-affinity rules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Soft&lt;/strong&gt; - Use this value to make the scheduler enforce a rule wherever it can be met (best-effort approach). If the rule cannot be met, the scheduler will deploy the required pods in the nodes with enough resources.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hard&lt;/strong&gt; - Use this value to make the scheduler enforce a rule. This means that if there are remaining pods that do not comply with the pre-defined rule, they won&amp;rsquo;t be allocated in any node.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bitnami Helm charts have the &lt;code&gt;podAntiAffinity&lt;/code&gt; rule with the &lt;code&gt;soft&lt;/code&gt; value enabled by default. Hence, if there are not enough nodes to place one pod per node, it will leave the scheduler to decide where the remaining pods should be located.&lt;/p&gt;
&lt;p&gt;The following section shows two different use cases of configuring &lt;code&gt;podAntiaffinity&lt;/code&gt; parameter.&lt;/p&gt;
&lt;h2 id=&#34;deploying-a-chart-using-the-podantiaffinity-rule&#34;&gt;Deploying a Chart Using the &lt;code&gt;podAntiAffinity&lt;/code&gt; Rule&lt;/h2&gt;
&lt;p&gt;The following examples illustrate how the &lt;code&gt;podAntiAffinity&lt;/code&gt; rule works in the context of the Bitnami MySQL Helm chart. They cover two use cases: installing the chart with the default &lt;code&gt;podAntiAffinity&lt;/code&gt; value and changing the &lt;code&gt;podAntiAffinity&lt;/code&gt; value from &lt;code&gt;soft&lt;/code&gt; to &lt;code&gt;hard&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;use-case-1-install-the-chart-with-the-default-podantiaffinity-value&#34;&gt;Use Case 1: Install the Chart with the Default &lt;code&gt;podAntiaffinity&lt;/code&gt; Value&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Install the Bitnami Helm charts repository by running:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;helm repo add bitnami https://charts.bitnami.com/bitnami 
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Deploy the MySQL Helm chart by executing the command below. Note that the chart will deploy the cluster with three nodes and two replicas - one primary and one secondary. To make the scheduler follow the default &lt;code&gt;podAntiAffinity&lt;/code&gt; rule, set the parameter as follows:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;helm install mysql bitnami/mysql --set architecture=replication --set secondary.replicaCount=2 --set secondary.podAntiAffinityPreset=soft 
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Verify the cluster by checking the nodes. Use the following command to list the connected nodes:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;kubectl get nodes 
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;You will see an output message like this:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/bitnami-helm-chart-affinity-rules/image-2.png&#34; alt=&#34;Example kubectl get pods output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Three nodes are running in the cluster.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Check how the pods are distributed. Execute the command below:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;kubectl get pods -o wide 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/bitnami-helm-chart-affinity-rules/image-3.png&#34; alt=&#34;Example kubectl get pods -o wide output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;As expected, both the primary and the secondary pods are in different nodes.&lt;/p&gt;
&lt;p&gt;To verify how the scheduler acts when the &lt;em&gt;soft&lt;/em&gt; value is defined, scale up the cluster by setting the number of secondary replicas to three instead of one. Thus, the resulting number of pods will be four, instead of two.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;To scale the cluster, use the command below:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;kubectl scale sts/mysql-secondary --replicas 3 
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Check the pods by running again the &lt;code&gt;kubectl get pods&lt;/code&gt; command. The &lt;code&gt;soft&lt;/code&gt; value left the scheduler to locate the remaining pod that didn&amp;rsquo;t comply with the &amp;ldquo;one pod per node&amp;rdquo; rule:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/bitnami-helm-chart-affinity-rules/image-4.png&#34; alt=&#34;Example kubectl get pods output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Note that two pods are running in the same node.&lt;/p&gt;
&lt;h3 id=&#34;use-case-2-change-the-podantiaffinity-value-from-soft-to-hard&#34;&gt;Use Case 2: Change the &lt;code&gt;podAntiAffinity&lt;/code&gt; Value from Soft to Hard&lt;/h3&gt;
&lt;p&gt;To try the &lt;code&gt;hard&lt;/code&gt; type of the &lt;code&gt;podAntiAffinity&lt;/code&gt; rule, deploy the chart again by changing the &lt;code&gt;secondary.podAntiAffinityPreset&lt;/code&gt; value from &lt;code&gt;soft&lt;/code&gt; to &lt;code&gt;hard&lt;/code&gt; as shown below. The chart will deploy the cluster with three nodes and two replicas - one primary and one secondary.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm install mysql-hard bitnami/mysql --set architecture=replication --set secondary.replicaCount=2 --set secondary.podAntiAffinityPreset=hard
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Check the nodes and the pods by running the &lt;code&gt;kubectl get nodes&lt;/code&gt; and the &lt;code&gt;kubectl get pods â€“o wide&lt;/code&gt; commands:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/bitnami-helm-chart-affinity-rules/image-5.png&#34; alt=&#34;Example kubectl get pods -o wide output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Both the primary and secondary pods are running in the same node.&lt;/p&gt;
&lt;p&gt;To verify how the scheduler acts when the &lt;code&gt;hard&lt;/code&gt; value is defined, scale up the cluster by setting the number of secondary replicas to three instead of one. Thus, the resulting number of pods will be four, instead of two.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Scale up the cluster by executing the command below:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;kubectl scale sts/mysql-hard secondary --replicas 3 
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;When checking the pods, you will see that the scheduler has ignored the &amp;ldquo;one pod per node&amp;rdquo; rule and also located only as many pods as there are nodes. The fourth pod was not deployed as there are only three nodes available.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/kubernetes/bitnami-helm-chart-affinity-rules/image-6.png&#34; alt=&#34;Example kubectl get pods -o wide output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;podAntiAffinity&lt;/code&gt; rule is an easy way to control how application pods will be distributed across the cluster nodes when installing a Helm chart. Deploy your favorite Bitnami applications and enable this feature via a simple install-time parameter.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful Links&lt;/h2&gt;
&lt;p&gt;To learn more about the topics discussed in this article, use the links below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Helm charts catalog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Helm charts documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubernetes scheduler documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kubernetes pod affinity documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: What is Bitnami?</title>
      
      <link>/guides/containers/what-is-bitnami/</link>
      <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/guides/containers/what-is-bitnami/</guid>
      <description>

        
        &lt;p&gt;Bitnami is an application packaging and publishing startup that was acquired by VMware in 2019. It is a leading provider of prepackaged open source software that runs natively in environments where the lionâ€™s share of developers and other users want to build or deploy applications: in the major public clouds, on laptops, and on Kubernetes.&lt;/p&gt;
&lt;h2 id=&#34;why-should-i-use-bitnami&#34;&gt;Why should I use Bitnami?&lt;/h2&gt;
&lt;p&gt;With more than a decade of experience publishing the &lt;a href=&#34;https://bitnami.com/stacks&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Community Catalog&lt;/a&gt;, an extensive library of open source applications and app building blocks, Bitnami is famous for keeping all of its software up to date with the latest application versions, dependencies, and operating systems. Every application is prepackaged to work out of the box, with no need to finish configuration or setup on your own. Every Bitnami app is packaged with best practices, run through extensive automated tests, and certified to be up to date and working in its target platform.&lt;/p&gt;
&lt;p&gt;Bitnami simplifies the management of multi-cloud, cross-platform environments not by trying to abstract differences away, but by providing functionally equivalent, platform-optimized application and infrastructure stacks for each of them. This enables a degree of standardization across platforms while allowing in-depth integration with vendor-specific features and services.&lt;/p&gt;
&lt;p&gt;And importantly, &lt;strong&gt;all software in the Bitnami Community Catalog is free to use and open source.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;where-can-i-find-bitnami-apps&#34;&gt;Where can I find Bitnami apps?&lt;/h2&gt;
&lt;p&gt;A great place to start is &lt;a href=&#34;https://bitnami.com/stacks&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami.com&lt;/a&gt;, where you can browse a catalog of more than 180 apps packaged for multiple platforms. Clicking on any app in the library will take you to its individual page where you can find out how to deploy it on your laptop with a native installer, in the cloud as a platform-specific VM image, on Docker, or on Kubernetes.&lt;/p&gt;
&lt;p&gt;You can also find Bitnami cloud images and containers in the cloud marketplaces for &lt;a href=&#34;https://aws.amazon.com/marketplace/search/results?x=29&amp;amp;y=22&amp;amp;searchTerms=bitnami&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;AWS&lt;/a&gt;, &lt;a href=&#34;https://azuremarketplace.microsoft.com/en-us/marketplace/apps?search=bitnami&amp;amp;page=1&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Microsoft Azure&lt;/a&gt;, and &lt;a href=&#34;https://console.cloud.google.com/marketplace/browse?q=bitnami&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Google Cloud&lt;/a&gt;; containers in &lt;a href=&#34;https://hub.docker.com/u/bitnami&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker Hub&lt;/a&gt; and &lt;a href=&#34;https://gallery.ecr.aws/?searchTerm=bitnami&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;AWS ECR Public&lt;/a&gt;; and Bitnami Helm charts in the Bitnami chart repository.&lt;/p&gt;
&lt;h2 id=&#34;check-out-bitnami-docs-and-community-sites&#34;&gt;Check out Bitnami docs and community sites&lt;/h2&gt;
&lt;p&gt;Each Bitnami app has extensive documentation that makes it easy to get started. Check out &lt;a href=&#34;https://docs.bitnami.com&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Documentation&lt;/a&gt; for more information.&lt;/p&gt;
&lt;p&gt;In addition to great content across many different marketplaces, Bitnami also has a large communityâ€”of more than 3 million developers! On the Bitnami Community page, Bitnami engineers and fellow developers help each other when they run into trouble, need ideas on how to use Bitnami stacks, or want to discuss topics like open source software.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Best Practices for Securing and Hardening Container Images</title>
      
      <link>/guides/containers/security-best-practices/</link>
      <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/guides/containers/security-best-practices/</guid>
      <description>

        
        &lt;p&gt;When a container is built and/or used, it is important to ensure that the image is built by following best practices in terms of security, efficiency, performance, etc. This article will go over some of the key points Bitnami takes into account when publishing Bitnami containers. It covers image tagging, non-root configuration and arbitrary UIDs, the importance of reducing size and dependencies, and the release process, including CVE scanning and tests.&lt;/p&gt;
&lt;h2 id=&#34;rolling-and-immutable-tags&#34;&gt;Rolling and immutable tags&lt;/h2&gt;
&lt;p&gt;A Docker tag is a label used to uniquely identify a Docker image. It allows users to deploy a specific version of an image. A single image can have multiple tags associated with it.&lt;/p&gt;
&lt;p&gt;Every time Bitnami publishes a new version of an image, the associated tags are also updated to make it easier for users to get the latest version.&lt;/p&gt;
&lt;h3 id=&#34;rolling-tags&#34;&gt;Rolling tags&lt;/h3&gt;
&lt;p&gt;Bitnami uses rolling tags (a tag that may not always point to the same image) for its Docker container images. To understand how this works, let&amp;rsquo;s use the Bitnami etcd container image tags as an example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;3, 3-debian-10, 3.4.13, 3.4.13-debian-10-r8, latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;latest&lt;/em&gt; tag always points to the latest revision of the etcd image.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;3&lt;/em&gt; tag is a rolling tag that always points to the latest revision of etcd 3.x.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;3.4.13&lt;/em&gt; tag is a rolling tag that points to the latest revision of etcd 3.4.13. It will be updated with different revisions or daily releases but only for etcd 3.4.13.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;3-debian-10&lt;/em&gt; tag points to the latest revision of etcd 3.x for Debian 10, in case there are other distros supported.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When Bitnami releases container images - typically to upgrade system packages - it fixes bugs or improves the system configuration and also updates container tags to point to the latest revision of the image. Therefore, the rolling tags shown above are dynamic; they will always point to the latest revision or daily release of the corresponding image.&lt;/p&gt;
&lt;p&gt;Continuing with the example above, the &lt;em&gt;3.4.13&lt;/em&gt; tag might point to the etcd 3.4.13 revision 8 today, but it will refer to the etcd 3.4.13 revision 9 when Bitnami next updates the container image.&lt;/p&gt;
&lt;p&gt;The suffix revision number (&lt;em&gt;rXX&lt;/em&gt;) is incremented every time that Bitnami releases an updated version of the image for the same version of the application. As explained in the next section, suffixed tags are also known as immutable tags.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Any tags that do not explicitly specify a distribution, such as &lt;em&gt;3&lt;/em&gt; or &lt;em&gt;3.4.13&lt;/em&gt;, should be assumed to refer to Debian 10.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;immutable-tags&#34;&gt;Immutable tags&lt;/h3&gt;
&lt;p&gt;A static, or immutable, tag always points to the same image. This is useful when you depend on a specific revision of an image For example, if you use the tag &lt;em&gt;3.4.13-debian-10-r8&lt;/em&gt;, this tag will always refer to etcd &lt;em&gt;3.4.13 revision 8&lt;/em&gt;. The use of this tag ensures that users get the same image every time.&lt;/p&gt;
&lt;h3 id=&#34;usage-recommendations&#34;&gt;Usage recommendations&lt;/h3&gt;
&lt;p&gt;Which tag should you use and when? Follow these guidelines:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you are using containers in a production environment (such as Kubernetes), use immutable tags. Bitnami uses immutable tags by default in the Bitnami Helm Charts. This ensures that your deployment won&amp;rsquo;t be affected if a new revision inadvertently breaks existing functionality.&lt;/li&gt;
&lt;li&gt;If you are using containers for development, use rolling tags. This ensures that you are always using the latest version. Rolling tags also make it easier to use a specific version of a development tool (such as &lt;em&gt;bitnami/node:12&lt;/em&gt; for Node.js 12).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;root-and-non-root-containers&#34;&gt;Root and non-root containers&lt;/h2&gt;
&lt;p&gt;There are two types of Bitnami container images: root and non-root. Non-root images add an extra layer of security and are generally recommended for production environments. However, because they run as a &lt;em&gt;non-root&lt;/em&gt; user, privileged tasks such as installing system packages, editing configuration files, creating system users and groups, and modifying network information, are typically off-limits.&lt;/p&gt;
&lt;p&gt;This section gives you a quick introduction to non-root container images, explains possible issues you might face using them, and also shows how to modify them to work as root images.&lt;/p&gt;
&lt;h3 id=&#34;non-root-containers&#34;&gt;Non-root containers&lt;/h3&gt;
&lt;p&gt;By default, Docker containers are run as &lt;em&gt;root&lt;/em&gt; users. This means that you can do whatever you want in the container, such as install system packages, edit configuration files, bind privilege ports, adjust permissions, create system users and groups, or access networking information.&lt;/p&gt;
&lt;p&gt;With a non-root container, you can&amp;rsquo;t do any of this. A non-root container must be configured only for its main purpose, for example, run the NGINX server.&lt;/p&gt;
&lt;p&gt;A non-root container is a container in which the user executing the processes is not the &lt;em&gt;root&lt;/em&gt; user but an unprivileged user, like &lt;em&gt;1001&lt;/em&gt;. This is usually modified through the &lt;code&gt;USER&lt;/code&gt; instruction in the Dockerfile.&lt;/p&gt;
&lt;h3 id=&#34;advantages-of-non-root-containers&#34;&gt;Advantages of non-root containers&lt;/h3&gt;
&lt;p&gt;Non-root containers are recommended for the following reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Security: Non-root containers are more secure. If there is a container engine security issue, running the container as an unprivileged user will prevent any malicious code from gaining elevated permissions on the container host. &lt;a href=&#34;https://docs.docker.com/engine/security/security/#other-kernel-security-features&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about Docker&amp;rsquo;s security features&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Platform restrictions: Some Kubernetes distributions (such as &lt;a href=&#34;https://www.openshift.com&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;OpenShift&lt;/a&gt;) run containers using random UUIDs. This approach is not compatible with root containers, which must always run with the &lt;em&gt;root&lt;/em&gt; user&amp;rsquo;s UUID. In such cases, root-only container images will simply not run and a non-root image is a must. &lt;a href=&#34;https://cookbook.openshift.org/users-and-role-based-access-control/why-do-my-applications-run-as-a-random-user-id.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about random UUIDs&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;disadvantages-of-non-root-containers&#34;&gt;Disadvantages of non-root containers&lt;/h3&gt;
&lt;p&gt;Non-root containers also have some disadvantages when used for local development:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Write failures on mounted volumes: Docker mounts host volumes preserving the host UUID and GUID. This can lead to permission conflicts with non-root containers, as the user running the container may not have the appropriate privileges to write on the host volume.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Write failures on persistent volumes in Kubernetes: Data persistence in Kubernetes is configured using persistent volumes. Kubernetes mounts these volumes with the &lt;em&gt;root&lt;/em&gt; user as the owner; therefore, non-root containers don&amp;rsquo;t have permissions to write to the persistent directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Issues with specific utilities or services: Some utilities (e.g. Git) or servers (e.g. PostgreSQL) run additional checks to find the user in the &lt;em&gt;/etc/passwd&lt;/em&gt; file. These checks will fail for non-root container images.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To learn more about these issues, as well as potential solutions for each, &lt;a href=&#34;https://engineering.bitnami.com/articles/running-non-root-containers-on-openshift.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;refer to our detailed blog post on this topic&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Bitnami non-root containers fix the above issues:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For Kubernetes, Bitnami Helm charts use an &lt;em&gt;initContainer&lt;/em&gt; for changing the volume permissions properly. As the image runs as non-root by default, it is necessary to adjust the ownership of the persistent volume so that the container can write data to it.
By default, the charts are configured to use Kubernetes Security Context to automatically change the ownership of the volume. However, this feature does not work in all Kubernetes distributions. As an alternative, the charts support using an &lt;em&gt;initContainer&lt;/em&gt; to change the ownership of the volume before mounting it in the final destination. &lt;a href=&#34;https://github.com/bitnami/charts/blob/9353a76a4ddda6bf1da78328496fb649c951e80d/bitnami/rabbitmq/templates/statefulset.yaml#L58&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;See an example of this in action from the Bitnami RabbitMQ chart&lt;/a&gt; you can see how this &lt;em&gt;initContainer&lt;/em&gt; is used.&lt;/li&gt;
&lt;li&gt;For specific utilities, Bitnami ships the &lt;a href=&#34;https://packages.debian.org/sid/libnss-wrapper&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;em&gt;libnss-wrapper&lt;/em&gt; package&lt;/a&gt;, which defines custom user space files to ensure the software acts correctly. &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-postgresql/blob/master/12/debian-10/rootfs/opt/bitnami/scripts/libpostgresql.sh#L25&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;See an example of this in action from the Bitnami PostgreSQL image&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;use-non-root-containers-as-root-containers&#34;&gt;Use non-root containers as root containers&lt;/h3&gt;
&lt;p&gt;If you wish to run a Bitnami non-root container image as a root container image, you can do it by adding the line &lt;code&gt;user: root&lt;/code&gt; right after the &lt;code&gt;image:&lt;/code&gt; directive in the container&amp;rsquo;s &lt;em&gt;docker-compose.yml&lt;/em&gt; file. After making this change, restart the container and it will run as the &lt;em&gt;root&lt;/em&gt; user with all privileges instead of an unprivileged user.&lt;/p&gt;
&lt;p&gt;In Kubernetes, the user that executes the container can be customized by using &lt;a href=&#34;https://kubernetes.io/docs/tasks/configure-pod-container/security-context/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Security Context&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;use-arbitrary-uuids&#34;&gt;Use arbitrary UUIDs&lt;/h3&gt;
&lt;p&gt;On some platforms like OpenShift, to support running containers with volumes mounted in a secure way, images must run as an arbitrary user ID. When those platforms mount volumes for a container, they configure the volume so it can only be written to by a particular user ID, and then run the image using that same user ID. This ensures the volume is only accessible to the appropriate container, but requires that the image is able to run as an arbitrary user ID.&lt;/p&gt;
&lt;p&gt;That means a non-root container executing on a platform with this policy can&amp;rsquo;t assume anything about the UUID. These platforms change the default container user to an arbitrary UUID, but the GUID is unmodified and containers are executed as &lt;em&gt;XXX:root&lt;/em&gt; (where &lt;em&gt;XXX&lt;/em&gt; is the arbitrary UUID).&lt;/p&gt;
&lt;p&gt;Bitnami images are configured with the proper permissions for the user and group in order to meet the requirements of these platforms. They do this by ensuring that the &lt;em&gt;XXX&lt;/em&gt; user belongs to the &lt;em&gt;root&lt;/em&gt; group and that the directories have the appropriate read, write and execution permissions.&lt;/p&gt;
&lt;h2 id=&#34;execute-one-process-per-container&#34;&gt;Execute one process per container&lt;/h2&gt;
&lt;p&gt;Each container should have only one concern. Decoupling applications into multiple containers makes it easier to scale horizontally and reuse containers. For instance, a web application stack might consist of three separate containers, each with its own unique image, to manage the web application, database, and an in-memory cache in a decoupled manner.&lt;/p&gt;
&lt;p&gt;Although all Bitnami images follow this good practice there are cases where two or more processes need to be executed at the same time in the same image. One such case is that of the &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-postgresql-repmgr&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami PostgreSQL with Replication Manager Docker Image&lt;/a&gt; where, apart from the &lt;em&gt;postgres&lt;/em&gt; process, there is a separate process for the &lt;em&gt;repmgr&lt;/em&gt; daemon. There are also other cases where the application spawns additional processes on its own.&lt;/p&gt;
&lt;p&gt;It is therefore important to take a decision about the number of processes per container keeping in mind the goal of keeping each container as clean and modular as possible.&lt;/p&gt;
&lt;h2 id=&#34;performance-considerations&#34;&gt;Performance considerations&lt;/h2&gt;
&lt;p&gt;As indirectly described in the previous section, it is important to follow the &amp;ldquo;Principle of least privilege&amp;rdquo; (POLP), an important concept in computer security. This refers to the practice of limiting access rights for users to the bare minimum permissions they need to perform their work.&lt;/p&gt;
&lt;p&gt;In the same way, a good security practice is to install and maintain only the minimum necessary dependencies in a container image. It is also important to reduce the size of the images to improve the security, performance, efficiency, and maintainability of the containers.&lt;/p&gt;
&lt;p&gt;Package installation in Bitnami images (also applicable to already-installed packages) is usually done using the &lt;code&gt;install_packages&lt;/code&gt; script. This tool was created to install system packages in a smart way for container environments. Apart from installing packages only with the required dependencies (no recommended packages or documentation), it also removes the cache and unnecessary package repositories.&lt;/p&gt;
&lt;h2 id=&#34;daily-builds-and-release-process&#34;&gt;Daily builds and release process&lt;/h2&gt;
&lt;p&gt;Bitnami automatically re-releases its container catalog every 24 hours. In terms of security, releasing the Bitnami containers on a daily basis ensures that the system packages and components bundled in the image are up-to-date from the package repositories.&lt;/p&gt;
&lt;p&gt;As explained previously, this approach means that a new immutable tag is produced every day, increasing the revision number. At the same time, rolling tags are updated to point to this new immutable tag.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For the Bitnami Community Catalog, the release frequency is set to 1 day. However, this can be modified by the customer in the &lt;a href=&#34;https://tanzu.vmware.com/application-catalog&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Tanzu Application Catalog&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Apart from daily releases, there are other processes that can trigger a new release. For example, if there is a new version (major, minor, or patch) of the main component, Bitnami&amp;rsquo;s tracking system detects this new upstream release and trigger a new release of the Bitnami image, which uses the &lt;em&gt;-r0&lt;/em&gt; tag suffix.&lt;/p&gt;
&lt;p&gt;Before a new image is released, antivirus scanners and other tests are executed. If these are unsuccessful, the release is blocked. These are discussed in the following sections&lt;/p&gt;
&lt;h3 id=&#34;cve-and-virus-scanning&#34;&gt;CVE and virus scanning&lt;/h3&gt;
&lt;p&gt;If you are running development containers to create a proof of concept or for production workloads, you will probably already be aware of CVEs that may affect the container&amp;rsquo;s operating system and packages. There are various tools/scanners to check containers for CVEs, such as &lt;a href=&#34;https://coreos.com/clair/docs/latest/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Clair&lt;/a&gt;, &lt;a href=&#34;https://github.com/anchore/anchore-engine&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Anchore&lt;/a&gt;, &lt;a href=&#34;http://github.com/theupdateframework/notary&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Notary&lt;/a&gt; and others.&lt;/p&gt;
&lt;p&gt;There are two ways of ensuring the health of containers: using a virus scan or a CVE scan.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The virus scan is executed during the release process. The virus scan performed by Bitnami uses antivirus engines for scanning the files present in the container, stopping the release if a positive is detected.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;While the antivirus scan is a blocking step when releasing a container, the CVE scan is a tool executed periodically to trigger new releases. This tool analyzes the containers bundled by the Bitnami Helm charts. If it finds a CVE, it triggers the release of the affected container.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;verification-and-functional-testing&#34;&gt;Verification and functional testing&lt;/h3&gt;
&lt;p&gt;During the release process, all containers are tested to work with all deployment technologies with which they are likely to be used:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker Compose, using several Docker Compose files to test different features like LDAP, cluster topologies, etc.&lt;/li&gt;
&lt;li&gt;Helm charts, tested on different Kubernetes platforms such as GKE, AKS, IKS, TKG, etc., and under different scenarios.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Two types of tests are executed for each deployment method:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Verification tests: This type of testing involves inspecting a deployment to check certain properties. For example, checking if a particular file exists on the system and if it has the correct permissions.&lt;/li&gt;
&lt;li&gt;Functional tests: This type of testing is used to verify that an application is behaving as expected from the user&amp;rsquo;s perspective. For example, if the application must be accessible using a web browser, functional testing uses a headless browser to interact with the application and perform common actions such as logging in and out and adding users.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;fips&#34;&gt;FIPS&lt;/h2&gt;
&lt;p&gt;If customers require compliance with &lt;a href=&#34;https://csrc.nist.gov/publications/detail/fips/140/2/final&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;FIPS 140-2&lt;/a&gt;, Bitnami containers can ship a FIPS-enabled version of OpenSSL. In a FIPS-enabled kernel, OpenSSL (and the applications using it) will only use FIPS-approved encryption algorithms. In the case of applications that have a FIPS mode (such as Elasticsearch), this would be enabled as well.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;By implementing the above points in the Bitnami build and release process, Bitnami ensures that its container images are built following best practices in terms of security and performance and can be safely used on most platforms as part of production deployments.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;p&gt;To learn more about the topics discussed in this guide, use the links below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/tutorials/understand-rolling-tags-containers&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Understand Bitnami&amp;rsquo;s rolling tags for container images&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/tutorials/work-with-non-root-containers&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Work with non-root containers for Bitnami applications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://engineering.bitnami.com/articles/why-non-root-containers-are-important-for-security.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Why non-root containers are important for security&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://engineering.bitnami.com/articles/best-practices-writing-a-dockerfile.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Best practices writing a Dockerfile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://engineering.bitnami.com/articles/how-bitnami-continuously-scans-container-images-to-fix-cve-reported-security-issues.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;How Bitnami continuously scans container images to fix CVE-reported security issues&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://engineering.bitnami.com/articles/running-non-root-containers-on-openshift.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Running non-root containers on OpenShift&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Integrate Spring Cloud Data Flow Applications with a Scalable MongoDB Deployment on Kubernetes</title>
      
      <link>/guides/spring/scdf-mongodb/</link>
      <pubDate>Fri, 04 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>/guides/spring/scdf-mongodb/</guid>
      <description>

        
        &lt;p&gt;&lt;a href=&#34;https://dataflow.spring.io/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Spring Cloud Data Flow&lt;/a&gt; is a framework for creating data streaming applications and batch data processing pipelines. It is commonly used to develop and test microservices, and it comes with built-in support for popular data sources and data storage services. It is available under an Apache license.&lt;/p&gt;
&lt;p&gt;For developers looking to quickly build data processing applications on Kubernetes using Spring, the easiest way is with &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/spring-cloud-dataflow&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Spring Cloud Data Flow Helm chart&lt;/a&gt;. This chart bootstraps a Spring Cloud Data Flow deployment on a Kubernetes cluster using the Helm package manager. It is also secure, updated and packaged in accordance with current best practices.&lt;/p&gt;
&lt;p&gt;This article walks you through the process of deploying Spring Cloud Data Flow on Kubernetes using the Bitnami Spring Cloud Data Flow Helm chart. It also shows you how to connect your deployment with a MongoDB database service (also running on Kubernetes) and create a simple Spring Cloud Data Flow stream that accepts data input over HTTP and saves the data to the MongoDB service.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and Prerequisites&lt;/h2&gt;
&lt;p&gt;This article assumes that you have a Kubernetes cluster running with Helm v3.x and &lt;em&gt;kubectl&lt;/em&gt; installed. &lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about getting started with Kubernetes and Helm using different cloud providers&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;step-1-deploy-mongodb-on-kubernetes&#34;&gt;Step 1: Deploy MongoDB on Kubernetes&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;If you already have a MongoDB deployment, you can use that instead and skip to &lt;a href=&#34;#step-2-deploy-spring-cloud-data-flow-on-kubernetes&#34;&gt;Step 2&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The first step is to deploy a MongoDB service on Kubernetes. The simplest way to do this is with &lt;a href=&#34;https://github.com/helm/charts/tree/master/stable/mongodb&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s MongoDB Helm chart&lt;/a&gt;. Follow the steps below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Add the Bitnami chart repository to Helm:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm repo add bitnami https://charts.bitnami.com/bitnami
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Execute the following command to deploy MongoDB. The command below will also create a new database named &lt;em&gt;mydb&lt;/em&gt; and a user account named &lt;em&gt;user&lt;/em&gt; with full privileges on that database. Remember to replace the MONGODB-ROOT-PASSWORD placeholder with a custom password for the MongoDB administrator account and the MONGODB-USER-PASSWORD placeholder with a custom password for the &lt;em&gt;user&lt;/em&gt; account.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install mongodb bitnami/mongodb &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set auth.rootPassword&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;MONGODB-ROOT-PASSWORD &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set auth.database&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;mydb &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set auth.username&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;user &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --set auth.password&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;MONGODB-USER-PASSWORD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Wait for a few minutes until the chart is deployed. Note the DNS name for the service in the cluster. In this example, it will be &lt;em&gt;mongodb.default.svc.cluster.local&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/spring/scdf-mongodb/mongodb.png&#34; alt=&#34;MongoDB deployment&#34;  /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;See the &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/mongodb#parameters&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;complete list of parameters supported by the Bitnami MongoDB Helm chart&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-2-deploy-spring-cloud-data-flow-on-kubernetes&#34;&gt;Step 2: Deploy Spring Cloud Data Flow on Kubernetes&lt;/h2&gt;
&lt;p&gt;The next step is to deploy Spring Cloud Data Flow on the same cluster using Bitnami&amp;rsquo;s Helm chart and configure it for use. Follow the steps below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Execute the following command to deploy the chart:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install spring bitnami/spring-cloud-dataflow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Wait for a few minutes until the chart is deployed.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;See the &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/spring-cloud-dataflow#parameters&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;complete list of parameters supported by the Bitnami Spring Cloud Data Flow Helm chart&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Forward the Spring Cloud Data Flow server port:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export SERVICE_PORT=$(kubectl get --namespace default -o jsonpath=&amp;quot;{.spec.ports[0].port}&amp;quot; services spring-spring-cloud-dataflow-server)
kubectl port-forward --namespace default svc/spring-spring-cloud-dataflow-server ${SERVICE_PORT}:${SERVICE_PORT} --address=0.0.0.0 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Browse to http://IP-ADDRESS:8080/dashboard, where IP-ADDRESS should be the IP address of the &lt;em&gt;kubectl&lt;/em&gt; host. You will see the Spring Cloud Data Flow dashboard.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;On the &amp;ldquo;Applications&amp;rdquo; page, click the &amp;ldquo;Add Application(s)&amp;rdquo; button.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Select the option to &amp;ldquo;Bulk import application coordinates from an HTTP URI location&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Select the &amp;ldquo;Stream Apps (RabbitMQ/Docker)&amp;rdquo; category. The import URL will be prefilled for you.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click &amp;ldquo;Import the application(s)&amp;rdquo; to start the import process.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/spring/scdf-mongodb/import-apps.png&#34; alt=&#34;Import process&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Navigate back to the &amp;ldquo;Applications&amp;rdquo; page. Confirm that you see the imported applications, as shown below.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/spring/scdf-mongodb/apps.png&#34; alt=&#34;Imported applications&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-3-create-a-spring-cloud-data-flow-stream&#34;&gt;Step 3: Create a Spring Cloud Data Flow stream&lt;/h2&gt;
&lt;p&gt;The next step is to create a stream that accepts input over HTTP and then streams that data to MongoDB using Spring Cloud Data Flow. Follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Navigate to the &amp;ldquo;Streams&amp;rdquo; page.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click the &amp;ldquo;Create stream(s)&amp;rdquo; button.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the &amp;ldquo;Stream definition&amp;rdquo; box, define an HTTP (source) to MongoDB (sink) stream by entering the values below:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http | mongodb
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click the &amp;ldquo;Create stream(s)&amp;rdquo; button to proceed.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/spring/scdf-mongodb/create-stream.png&#34; alt=&#34;Stream creation&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Enter a name for the stream when prompted. Click the &amp;ldquo;Create the stream&amp;rdquo; button to save the new stream. In this example, the stream is named &lt;em&gt;mystream&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/spring/scdf-mongodb/name-stream.png&#34; alt=&#34;Stream naming&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Navigate back to the &amp;ldquo;Streams&amp;rdquo; page. Confirm that you see the new stream in the list of streams.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click the &amp;ldquo;Deploy&amp;rdquo; button to deploy the new stream.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/spring/scdf-mongodb/list-streams.png&#34; alt=&#34;Stream list&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the &amp;ldquo;Deploy Stream Definition&amp;rdquo; page, configure the deployment parameters for the stream as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the &lt;em&gt;http&lt;/em&gt; source column, find the &amp;ldquo;Deployment Platform&amp;rdquo; section and set the &lt;em&gt;create-load-balancer&lt;/em&gt; property to true. This makes the HTTP input endpoint for the stream available at a public IP address. Click &amp;ldquo;Update&amp;rdquo; once done.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/spring/scdf-mongodb/source.png&#34; alt=&#34;HTTP source configuration&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the &lt;em&gt;mongodb&lt;/em&gt; sink column, find the &amp;ldquo;Application Properties&amp;rdquo; section and set the following properties, which should match those configured in &lt;a href=&#34;#step-1-deploy-mongodb-on-kubernetes&#34;&gt;Step 1&lt;/a&gt;. Replace the MONGODB-USER-PASSWORD placeholder with the password defined for the &lt;em&gt;user&lt;/em&gt; account in &lt;a href=&#34;#step-1-deploy-mongodb-on-kubernetes&#34;&gt;Step 1&lt;/a&gt;. Click &amp;ldquo;Update&amp;rdquo; once done.
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;username&lt;/em&gt;: &lt;em&gt;user&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;authentication-database&lt;/em&gt;: &lt;em&gt;mydb&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;database&lt;/em&gt;: &lt;em&gt;mydb&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;password&lt;/em&gt;: MONGODB-USER-PASSWORD&lt;/li&gt;
&lt;li&gt;&lt;em&gt;collection&lt;/em&gt;: &lt;em&gt;spring&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;host&lt;/em&gt;: &lt;em&gt;mongodb.default.svc.cluster.local&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/spring/scdf-mongodb/sink.png&#34; alt=&#34;MongoDB sink configuration&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click the &amp;ldquo;Deploy stream&amp;rdquo; button to deploy the stream.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Wait for a few minutes until the chart is deployed. Once deployed, the &amp;ldquo;Streams&amp;rdquo; page will reflect the running deployment.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/spring/scdf-mongodb/list-streams-2.png&#34; alt=&#34;Stream status&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;You can also check the status of the deployment using the &lt;em&gt;kubectl get pods&lt;/em&gt; command.&lt;/p&gt;
&lt;h2 id=&#34;step-4-test-the-integration&#34;&gt;Step 4: Test the integration&lt;/h2&gt;
&lt;p&gt;Once the stream is deployed, you can proceed to test it, by sending it input over HTTP and then checking the MongoDB database to verify if the input was correctly saved. Follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Obtain the load balancer IP address for the HTTP input endpoint:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl get svc &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep mystream
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Send a JSON-formatted HTTP request to the endpoint. Replace the STREAM-IP-ADDRESS placeholder in the command below with the load balancer IP address.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;curl http://STREAM-IP-ADDRESS:8080 -X POST -H &lt;span class=&#34;s2&#34;&gt;&amp;#34;Content-type: application/json&amp;#34;&lt;/span&gt; -d &lt;span class=&#34;s2&#34;&gt;&amp;#34;{\&amp;#34;label\&amp;#34;: \&amp;#34;eggs\&amp;#34;}&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Connect to the MongoDB database service and query the &lt;em&gt;mydb&lt;/em&gt; database and &lt;em&gt;spring&lt;/em&gt; collection. Replace the MONGODB-USER-PASSWORD placeholder with the password defined for the &lt;em&gt;user&lt;/em&gt; account in &lt;a href=&#34;#step-1-deploy-mongodb-on-kubernetes&#34;&gt;Step 1&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl run --namespace default mongodb-client --rm --tty -i --restart&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Never&amp;#39;&lt;/span&gt; --image docker.io/bitnami/mongodb:4.2.8-debian-10-r39 --command -- bash
mongo admin --host &lt;span class=&#34;s2&#34;&gt;&amp;#34;mongodb&amp;#34;&lt;/span&gt; --authenticationDatabase mydb -u user -p MONGODB-USER-PASSWORD
use mydb
db.spring.find&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here is an example of the output you should see:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/spring/scdf-mongodb/query-results.png&#34; alt=&#34;MongoDB query results&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;This confirms that the integration is working successfully and that data sent to the Spring Cloud Data Flow endpoint is being successfully streamed and saved to the MongoDB database service.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;p&gt;To learn more about the topics discussed in this guide, use the links below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/spring-cloud-dataflow&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Spring Cloud Data Flow Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/helm/charts/tree/master/stable/mongodb&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami MongoDB Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dataflow.spring.io/docs/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Spring Cloud Data Flow documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/guides/event-streaming/scs-what-is/&#34;&gt;Spring Cloud Stream guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Build a Scalable, Fault-Tolerant Messaging Cluster on Kubernetes with Apache Kafka and MongoDB</title>
      
      <link>/guides/messaging-and-integration/kafka-mongodb/</link>
      <pubDate>Wed, 29 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/guides/messaging-and-integration/kafka-mongodb/</guid>
      <description>

        
        &lt;p&gt;&lt;a href=&#34;https://kafka.apache.org/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Apache Kafka&lt;/a&gt; is a popular open source tool for real-time publish/subscribe messaging. It uses a scalable, fault-tolerant cluster for message storage, and it can also be integrated with other open source data-oriented solutions such as &lt;a href=&#34;https://hadoop.apache.org/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Apache Hadoop&lt;/a&gt;, &lt;a href=&#34;https://spark.apache.org/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Apache Spark&lt;/a&gt; or &lt;a href=&#34;https://hbase.apache.org/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Apache HBase&lt;/a&gt; for real-time analysis and rendering of streaming data.&lt;/p&gt;
&lt;p&gt;Apache Kafka provides a &lt;a href=&#34;https://kafka.apache.org/documentation/#connectapi&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Connect API&lt;/a&gt;, which allows external storage systems to be integrated with Kafka. One such example is the &lt;a href=&#34;https://www.mongodb.com/kafka-connector&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;MongoDB Kafka Connector&lt;/a&gt;, which allows Kafka messages to be stored in MongoDB, or MongoDB data to be published to Kafka. This integration allows users to combine Kafka&amp;rsquo;s real-time messaging features with the powerful document-oriented data querying capabilities of MongoDB.&lt;/p&gt;
&lt;p&gt;Bitnami offers secure and up-to-date Helm charts for &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/kafka&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Apache Kafka&lt;/a&gt; and &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/mongodb&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;MongoDB&lt;/a&gt;. These charts can be used to deploy and integrate Apache Kafka and MongoDB on Kubernetes, adding improved scalability and reliability and ensuring that the deployments conform to current best practices. This article walks you through the integration.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and prerequisites&lt;/h2&gt;
&lt;p&gt;This article explains the process of integrating Apache Kafka and MongoDB on Kubernetes, such that messages published on Kafka topics are automatically stored as documents in a MongoDB collection using a sink connector. It assumes that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have a Docker environment installed and configured. &lt;a href=&#34;https://docs.docker.com/engine/installation/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about installing Docker&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a Docker Hub account. &lt;a href=&#34;https://hub.docker.com&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Register for a free account&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a Kubernetes cluster running with Helm v3.x and &lt;em&gt;kubectl&lt;/em&gt; installed. &lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about getting started with Kubernetes and Helm using different cloud providers&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-1-deploy-mongodb-on-kubernetes&#34;&gt;Step 1: Deploy MongoDB on Kubernetes&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;If you already have a MongoDB deployment, you can use that instead and skip to &lt;a href=&#34;#step-2-create-and-publish-a-custom-mongodb-kafka-connector-image&#34;&gt;Step 2&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The first step is to deploy a MongoDB service on Kubernetes. The simplest way to do this is with Bitnami&amp;rsquo;s MongoDB Helm chart. Follow the steps below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Add the Bitnami chart repository to Helm:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm repo add bitnami https://charts.bitnami.com/bitnami
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Execute the following command to deploy MongoDB. Remember to replace the MONGODB-ROOT-PASSWORD placeholder with a custom password for the MongoDB administrator account.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install mongodb bitnami/mongodb --set auth.rootPassword&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;MONGODB-ROOT-PASSWORD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Wait for a few minutes until the chart is deployed.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;See the &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/mongodb#parameters&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;complete list of parameters supported by the Bitnami MongoDB Helm chart&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use the commands shown in the &amp;ldquo;Notes&amp;rdquo; section to create a MongoDB client and connect to the MongoDB service. Remember to replace the MONGODB-ROOT-PASSWORD placeholder with the password defined at deployment time.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl run --namespace default mongodb-client --rm --tty -i --restart&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Never&amp;#39;&lt;/span&gt; --image docker.io/bitnami/mongodb:4.2.8-debian-10-r39 --command -- bash
mongo admin --host &lt;span class=&#34;s2&#34;&gt;&amp;#34;mongodb&amp;#34;&lt;/span&gt; --authenticationDatabase admin -u root -p MONGODB-ROOT-PASSWORD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;At the MongoDB command prompt, create a new MongoDB database and user, and grant the user access to the database. The commands below create a new database named &lt;em&gt;mydb&lt;/em&gt; and a user account named &lt;em&gt;user&lt;/em&gt; with full privileges on that database. Replace the MONGODB-USER-PASSWORD placeholder with a custom password.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;use mydb
db.createUser&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    user: &lt;span class=&#34;s2&#34;&gt;&amp;#34;user&amp;#34;&lt;/span&gt;,
    pwd: &lt;span class=&#34;s2&#34;&gt;&amp;#34;MONGODB-USER-PASSWORD&amp;#34;&lt;/span&gt;,
    roles: &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; role: &lt;span class=&#34;s2&#34;&gt;&amp;#34;dbOwner&amp;#34;&lt;/span&gt;, db: &lt;span class=&#34;s2&#34;&gt;&amp;#34;mydb&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exit the MongoDB CLI and terminate the client pod.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-2-create-and-publish-a-custom-mongodb-kafka-connector-image&#34;&gt;Step 2: Create and publish a custom MongoDB Kafka Connector image&lt;/h2&gt;
&lt;p&gt;The next step is to create a container image with the MongoDB Connector for Apache Kafka. This image should also include the Kafka Connect application, which takes care of streaming data between Apache Kafka and other storage systems (such as MongoDB). Follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Create a file named &lt;em&gt;Dockerfile&lt;/em&gt; with the following content:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM bitnami/kafka:latest

RUN mkdir -p /opt/bitnami/kafka/plugins &amp;amp;&amp;amp; \
    cd /opt/bitnami/kafka/plugins &amp;amp;&amp;amp; \
    curl --remote-name --location --silent https://search.maven.org/remotecontent?filepath=org/mongodb/kafka/mongo-kafka-connect/1.2.0/mongo-kafka-connect-1.2.0-all.jar

CMD /opt/bitnami/kafka/bin/connect-standalone.sh /opt/bitnami/kafka/config/connect-standalone.properties /opt/bitnami/kafka/config/mongo.properties
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This &lt;em&gt;Dockerfile&lt;/em&gt; uses Bitnami&amp;rsquo;s Kafka container image as its base image. This is because the Bitnami Kafka container image already contains a working Apache Kafka environment, including the Kafka Connect application and other required dependencies, configuration files and libraries.&lt;/p&gt;
&lt;p&gt;After selecting the base image, this &lt;em&gt;Dockerfile&lt;/em&gt; performs two main actions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It downloads the latest version of the MongoDB Connector for Apache Kafka and adds it to the image.&lt;/li&gt;
&lt;li&gt;It starts the Kafka Connect application in &amp;ldquo;standalone mode&amp;rdquo;, passing it a set of configuration files. These files contain the information needed for Kafka Connect to integrate with both Apache Kafka and MongoDB. The files are not included in the image at this point; instead, they will be defined using a Kubernetes &lt;em&gt;ConfigMap&lt;/em&gt; in a later step.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;At the time of writing, the latest version of the MongoDB Connector for Apache Kafka is v1.2.0. Replace this with the most recent version when using the Dockerfile shown above. You can find the latest version on &lt;a href=&#34;https://github.com/mongodb/mongo-kafka/releases&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;the project&amp;rsquo;s GitHub page&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Build the image using the command below. Replace the DOCKER-USERNAME placeholder in the command below with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker build -t DOCKER-USERNAME/mykafka:1.0 .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The result of this command is a Docker image containing Apache Kafka, Kafka Connect, the MongoDB Connector for Apache Kafka and all the related dependencies.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Log in to Docker Hub and publish the image. Replace the DOCKER-USERNAME placeholder in the command below with your Docker account username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker login
docker push DOCKER-USERNAME/mykafka:1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-3-deploy-apache-kafka-and-kafka-connect-on-kubernetes&#34;&gt;Step 3: Deploy Apache Kafka and Kafka Connect on Kubernetes&lt;/h2&gt;
&lt;p&gt;The next step is to deploy Apache Kafka and the custom Kafka Connect container on Kubernetes. Although you can do this as two separate deployments, an easier way is to combine the two steps into one using the Bitnami Kafka Helm chart. This chart supports an &lt;em&gt;extraDeploy&lt;/em&gt; parameter which lets you deploy a set of extra objects with your Apache Kafka deployment.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Begin by creating the following &lt;em&gt;values.yml&lt;/em&gt; file holding the values that will be supplied to the Helm chart. Replace the KAFKA-USERNAME and KAFKA-PASSWORD with a custom username and password for Kafka client authentication. Replace the DOCKER-USERNAME placeholder with your Docker account username and the MONGODB-USER-PASSWORD placeholder with the password set for the MongoDB &lt;em&gt;user&lt;/em&gt; account in &lt;a href=&#34;#step-1-deploy-mongodb-on-kubernetes&#34;&gt;Step 1&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;auth:
  clientProtocol: sasl
  interBrokerProtocol: plaintext
  jaas:
    clientUser: KAFKA-USERNAME
    clientPassword: KAFKA-PASSWORD
extraDeploy: |-
  - apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: {{ include &amp;quot;kafka.fullname&amp;quot; . }}-connect
      labels: {{- include &amp;quot;kafka.labels&amp;quot; . | nindent 6 }}
        app.kubernetes.io/component: connector
    spec:
      replicas: 1
      selector:
        matchLabels: {{- include &amp;quot;kafka.matchLabels&amp;quot; . | nindent 8 }}
          app.kubernetes.io/component: connector
      template:
        metadata:
          labels: {{- include &amp;quot;kafka.labels&amp;quot; . | nindent 10 }}
            app.kubernetes.io/component: connector
        spec:
          containers:
            - name: connect
              image: DOCKER-USERNAME/mykafka:1.0
              imagePullPolicy: IfNotPresent
              command:
                - /bin/bash
                - -ec
                - |
                  /opt/bitnami/kafka/bin/connect-standalone.sh /config/connect-standalone.properties /config/mongodb.properties
              ports:
                - name: connector
                  containerPort: 8083
              volumeMounts:
                - name: configuration
                  mountPath: /config
          volumes:
            - name: configuration
              configMap:
                name: {{ include &amp;quot;kafka.fullname&amp;quot; . }}-connect
  - apiVersion: v1
    kind: ConfigMap
    metadata:
      name: {{ include &amp;quot;kafka.fullname&amp;quot; . }}-connect
      labels: {{- include &amp;quot;kafka.labels&amp;quot; . | nindent 6 }}
        app.kubernetes.io/component: connector
    data:
      connect-standalone.properties: |-
        bootstrap.servers = {{ include &amp;quot;kafka.fullname&amp;quot; . }}-0.{{ include &amp;quot;kafka.fullname&amp;quot; . }}-headless.{{ .Release.Namespace }}.svc.{{ .Values.clusterDomain }}:{{ .Values.service.port }}
        key.converter=org.apache.kafka.connect.json.JsonConverter
        value.converter=org.apache.kafka.connect.json.JsonConverter
        key.converter.schemas.enable=true
        value.converter.schemas.enable=true
        offset.storage.file.filename=/tmp/connect.offsets
        offset.flush.interval.ms=10000
        plugin.path=/opt/bitnami/kafka/plugins
        sasl.mechanism=PLAIN
        security.protocol=SASL_PLAINTEXT
        sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \
          username=&amp;quot;KAFKA-USERNAME&amp;quot; \
          password=&amp;quot;KAFKA-PASSWORD&amp;quot;;
        consumer.sasl.mechanism=PLAIN
        consumer.security.protocol=SASL_PLAINTEXT
        consumer.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \
          username=&amp;quot;KAFKA-USERNAME&amp;quot; \
          password=&amp;quot;KAFKA-PASSWORD&amp;quot;;
      mongodb.properties: |-
        connection.uri=mongodb://user:MONGODB-ROOT-PASSWORD@mongodb.default.svc.cluster.local:27017/mydb
        name=mongo-sink
        topics=mytopic
        connector.class=com.mongodb.kafka.connect.MongoSinkConnector
        tasks.max=1
        key.converter=org.apache.kafka.connect.json.JsonConverter
        value.converter=org.apache.kafka.connect.json.JsonConverter
        key.converter.schemas.enable=false
        value.converter.schemas.enable=false
        database=mydb
        collection=sink
  - apiVersion: v1
    kind: Service
    metadata:
      name: {{ include &amp;quot;kafka.fullname&amp;quot; . }}-connect
      labels: {{- include &amp;quot;kafka.labels&amp;quot; . | nindent 6 }}
        app.kubernetes.io/component: connector
    spec:
      ports:
        - protocol: TCP
          port: 8083
          targetPort: connector
      selector: {{- include &amp;quot;kafka.matchLabels&amp;quot; . | nindent 6 }}
        app.kubernetes.io/component: connector
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This file contains a lot of information, so let&amp;rsquo;s step through it in detail:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The &lt;em&gt;auth&lt;/em&gt; parameters define the protocol that Kafka will use for client and inter-broker communication. It also specifies the username and password for JAAS-based client authentication.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;em&gt;extraDeploy&lt;/em&gt; parameter creates an additional deployment using the custom Kafka Connect image created in &lt;a href=&#34;#step-2-create-and-publish-a-custom-mongodb-kafka-connector-image&#34;&gt;Step 2&lt;/a&gt;. It also mounts a configuration volume at the &lt;em&gt;/config&lt;/em&gt; mount point. This volume will hold the configuration files for Kafka Connect.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The file defines an additional &lt;em&gt;ConfigMap&lt;/em&gt; which is mounted at &lt;em&gt;/config&lt;/em&gt; and holds two minimal configuration files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;connect-standalone.properties&lt;/em&gt; file defines the standalone mode configuration for Kafka Connect. It specifies the host name of the Apache Kafka server and the client credentials to use when connecting to it. It also tells Kafka Connect which converter to use (JSON) when serializing messages for MongoDB.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;mongodb.properties&lt;/em&gt; file contains additional configuration for the MongoDB sink connector. This configuration includes the MongoDB connection URI, database and collection to use for the saved messages. It also specifies the converter to use for the data (JSON again). In particular, note the &lt;em&gt;topics&lt;/em&gt; parameter, which specifies the list of topics to monitor/save in MongoDB.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Find additional properties to control how data is handled by the sink connector in the official &lt;a href=&#34;https://docs.mongodb.com/kafka-connector/master/kafka-sink/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kafka Sink Connector documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Once the configuration file has been created, deploy Apache Kafka on Kubernetes using the Helm chart:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install kafka bitnami/kafka -f values.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Wait for a few minutes until the chart is deployed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Confirm that the Apache Kafka and Kafka Connect pods are running:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl get pods
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You should see something like the output below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/messaging-and-integration/kafka-mongodb/pods.png&#34; alt=&#34;Running pods&#34;  /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;See the &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/kafka#parameters&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;complete list of parameters supported by the Bitnami Apache Kafka Helm chart&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-4-test-the-integration&#34;&gt;Step 4: Test the integration&lt;/h2&gt;
&lt;p&gt;You can now proceed to test the integration, by publishing messages to the Apache Kafka topic &lt;em&gt;mytopic&lt;/em&gt; and then checking if the messages were streamed and saved to MongoDB. Follow the steps below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;kafka_jaas.conf&lt;/em&gt; file with the content below. Replace the KAFKA-USER and KAFKA-PASSWORD placeholders with the values used in &lt;a href=&#34;#step-3-deploy-apache-kafka-and-kafka-connect-on-kubernetes&#34;&gt;Step 3&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;KafkaClient &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    org.apache.kafka.common.security.plain.PlainLoginModule required
    &lt;span class=&#34;nv&#34;&gt;username&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;KAFKA-USER&amp;#34;&lt;/span&gt;
    &lt;span class=&#34;nv&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;KAFKA-PASSWORD&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;client.properties&lt;/em&gt; file with the content below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;security.protocol&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;SASL_PLAINTEXT
sasl.mechanism&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;PLAIN
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create an Apache Kafka client pod and copy the files above to it:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl run kafka-client --restart&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Never&amp;#39;&lt;/span&gt; --image docker.io/bitnami/kafka:2.5.0-debian-10-r96 --namespace default --command -- sleep infinity
kubectl cp --namespace default client.properties kafka-client:/tmp/client.properties
kubectl cp --namespace default kafka_jaas.conf kafka-client:/tmp/kafka_jaas.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Log in to the Apache Kafka client pod console:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; --tty -i kafka-client --namespace default -- bash
&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;KAFKA_OPTS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;-Djava.security.auth.login.config=/tmp/kafka_jaas.conf&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;At the pod console, publish one or more messages to the &lt;em&gt;mytopic&lt;/em&gt; topic. Ensure that the messages are formatted in JSON, as shown in the example below.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kafka-console-producer.sh --producer.config /tmp/client.properties --broker-list kafka-0.kafka-headless.default.svc.cluster.local:9092 --topic mytopic
&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;:&lt;span class=&#34;s2&#34;&gt;&amp;#34;world&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;foo&amp;#34;&lt;/span&gt;:&lt;span class=&#34;s2&#34;&gt;&amp;#34;bar&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exit the Apache Kafka client pod.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a new MongoDB client pod:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl run --namespace default mongodb-client --rm --tty -i --restart&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Never&amp;#39;&lt;/span&gt; --image docker.io/bitnami/mongodb:4.2.8-debian-10-r39 --command -- bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;At the MongoDB client pod console, log in to the MongoDB client pod using the &lt;em&gt;user&lt;/em&gt; account credentials defined in &lt;a href=&#34;#step-1-deploy-mongodb-on-kubernetes&#34;&gt;Step 1&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;mongo admin --host &lt;span class=&#34;s2&#34;&gt;&amp;#34;mongodb&amp;#34;&lt;/span&gt; --authenticationDatabase mydb -u user -p MONGODB-USER-PASSWORD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Confirm that the messages sent previously are saved in the &lt;em&gt;sink&lt;/em&gt; collection in the &lt;em&gt;mydb&lt;/em&gt; database:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;use mydb
db.sink.find&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You should see the output below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/messaging-and-integration/kafka-mongodb/mongodb.png&#34; alt=&#34;Query results&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;At this point, the integration between Apache Kafka and MongoDB is complete. Messages sent to specified topics in Apache Kafka will be automatically transferred and saved in MongoDB, where they can be further queried, analyzed or modified.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;p&gt;To learn more about the topics discussed in this guide, use the links below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Apache Kafka Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami MongoDB Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kafka.apache.org/documentation/#connectapi&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Apache Kafka Connect API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.mongodb.com/kafka-connector/master/kafka-sink/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;MongoDB Kafka Sink Connector guide &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Continuously Develop and Monitor an Express Application on Kubernetes with Bitnami, Skaffold and Octant</title>
      
      <link>/guides/ci-cd/express-app-bitnami-skaffold-octant/</link>
      <pubDate>Thu, 30 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/guides/ci-cd/express-app-bitnami-skaffold-octant/</guid>
      <description>

        
        &lt;p&gt;As Kubernetes&#39; importance as a platform grows, developers are increasingly searching for ways to build and debug cloud-native applications on Kubernetes infrastructure from the get-go. Rather than first hacking on code in local (or virtualized) environments and then migrating it to cloud-native architecture, this new approach involves continuously developing, debugging and deploying containerized applications on a live Kubernetes cluster.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;re a developer building cloud-native applications and targeting Kubernetes as your deployment architecture, Bitnami can help you with ready-to-use containers and Helm charts. Using these (instead of rolling your own) can save you time, help you follow best practices and allow you to focus on adding features to your application instead of dealing with Kubernetes-related complexity and configuration.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://bitnami.com/containers&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s containers&lt;/a&gt; for &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Node.js&lt;/a&gt;, &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-ruby&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Ruby&lt;/a&gt;, &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-java&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Java&lt;/a&gt; and many others make it easy to containerize your applications in a consistent manner using the latest and most secure version of your programming language.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/bitnami/charts/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Helm charts&lt;/a&gt; for runtime environments like &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Node.js&lt;/a&gt; and infrastructure components like &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/memcached&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Memcached&lt;/a&gt;, &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/mysql&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;MySQL&lt;/a&gt;, &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/elasticsearch&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Elasticsearch&lt;/a&gt;, &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/kafka&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Apache Kafka&lt;/a&gt; and many others let you deploy your applications on Kubernetes in a secure and reliable manner without worrying about packaging, dependencies and Kubernetes YAML files.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This guide gets you started with continuous development (CD) on Kubernetes. It uses &lt;a href=&#34;https://skaffold.dev/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Skaffold&lt;/a&gt;, in combination with Bitnami containers and Helm charts, to let you test and debug your application in a live Kubernetes environment with minimal setup effort. It also uses  &lt;a href=&#34;https://octant.dev/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Octant&lt;/a&gt; to help you monitor your cluster in real time and understand how your application behaves under different workloads.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and Prerequisites&lt;/h2&gt;
&lt;p&gt;This guide makes the following assumptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have a multi-node Kubernetes cluster running. &lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about deploying a Kubernetes cluster on different cloud platforms&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have the following tools installed and configured to work with your Kubernetes cluster:
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;kubectl&lt;/em&gt; CLI. &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes#step-3-install-kubectl-command-line&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn how to install &lt;em&gt;kubectl&lt;/em&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Helm v2.x package manager. &lt;a href=&#34;https://v2.helm.sh/docs/using_helm/#installing-helm&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about installing Helm v2.x&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;You have Docker installed. &lt;a href=&#34;https://docs.docker.com/install/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about installing and configuring Docker for your platform&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a Docker Hub account. If not, &lt;a href=&#34;https://hub.docker.com/signup&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;sign up for a free Docker Hub account&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;As of this writing, Skaffold only works with Helm v2.x.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;step-1-create-a-simple-express-application&#34;&gt;Step 1: Create a simple Express application&lt;/h2&gt;
&lt;p&gt;Your first step is to write some starter code. In this section, you will create a simple &amp;ldquo;Hello, world&amp;rdquo; application using &lt;a href=&#34;https://expressjs.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Express&lt;/a&gt;. Follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Create a working directory for the application on your development system:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;mkdir myproject
cd myproject
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;package.json&lt;/em&gt; file listing the dependencies for the project:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-express-app&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;1.0.0&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Express Hello World app&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;main&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;app.js&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;scripts&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;node app.js&amp;#34;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;dependencies&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;express&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;4.17.1&amp;#34;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create an &lt;em&gt;app.js&lt;/em&gt; file for the Express application which returns a &amp;ldquo;Hello world&amp;rdquo; message on access:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;use strict&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;express&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;require&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;express&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;express&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Hello world\n&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;console&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Running on http://localhost:&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you have Node.js installed in your local environment, you can test this application by running the following commands and then browsing to &lt;em&gt;http://localhost:3000&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install
npm start
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;step-2-configure-the-application-pipeline-with-skaffold&#34;&gt;Step 2: Configure the application pipeline with Skaffold&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://skaffold.dev/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Skaffold&lt;/a&gt; is an open source tool that makes it easy to build and deploy containers on Kubernetes. In this step, you will configure Skaffold to build your Express application as a container and to deploy it on the cluster using Helm.&lt;/p&gt;
&lt;p&gt;Begin by downloading and install Skaffold using the &lt;a href=&#34;https://skaffold.dev/docs/install/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;official installation instructions for your platform&lt;/a&gt;. Once Skaffold is installed, create a file named &lt;em&gt;skaffold.yaml&lt;/em&gt; in your project directory and fill it with the content below. To ensure this works correctly with your Docker Hub account, replace the DOCKER-HUB-USERNAME placeholder with your Docker Hub username.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;skaffold/v2alpha2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Config&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-express-app&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;artifacts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DOCKER-HUB-USERNAME/my-express-app&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;deploy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;helm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;releases&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-express-app&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;chartPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;bitnami/node&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;remote&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;setValues&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image.repository&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DOCKER-HUB-USERNAME/my-express-app&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;service.type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;LoadBalancer&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;getAppFromExternalRepository&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;applicationPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;3000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;setValueTemplates&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image.tag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{{ .DIGEST_HEX }}&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This file defines the Skaffold configuration for build and deploy stages. Let&amp;rsquo;s look at each stage in detail.&lt;/p&gt;
&lt;h3 id=&#34;build-stage&#34;&gt;Build stage&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;artifacts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DOCKER-HUB-USERNAME/my-express-app&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the build stage, Skaffold will use Docker and a local &lt;em&gt;Dockerfile&lt;/em&gt; to build the application, and then push it to a registry (by default, Docker Hub). Instead of creating a &lt;em&gt;Dockerfile&lt;/em&gt; from scratch, you will streamline your work by using &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Node.js Docker image&lt;/a&gt;, which comes with the latest bug fixes and most secure version of Node.js. Create the &lt;em&gt;Dockerfile&lt;/em&gt; as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM bitnami/node:10 as builder
ENV NODE_ENV=&amp;quot;production&amp;quot;

# Copy app&#39;s source code to the /app directory
COPY . /app

# The application&#39;s directory will be the working directory
WORKDIR /app

# Install Node.js dependencies defined in &#39;/app/package.json&#39;
RUN npm install

FROM bitnami/node:10-prod
ENV NODE_ENV=&amp;quot;production&amp;quot;
COPY --from=builder /app /app
WORKDIR /app
ENV PORT 3000
EXPOSE 3000

# Start the application
CMD [&amp;quot;npm&amp;quot;, &amp;quot;start&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Skaffold will automatically build and tag the image using this &lt;em&gt;Dockerfile&lt;/em&gt;. Once the image is built and tagged, the &lt;em&gt;image&lt;/em&gt; parameter in the build configuration tells Skaffold where to push the built image.&lt;/p&gt;
&lt;p&gt;If you are not already logged in to Docker Hub, use the command below to log in before proceeding. This is necessary so that Skaffold can push its built images to your Docker Hub account.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker login
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;deploy-stage&#34;&gt;Deploy stage&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;deploy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;helm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;releases&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-express-app&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;chartPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;bitnami/node&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;remote&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;setValues&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image.repository&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DOCKER-HUB-USERNAME/my-express-app&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;service.type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;LoadBalancer&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;getAppFromExternalRepository&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;applicationPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;3000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;setValueTemplates&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image.tag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{{ .DIGEST_HEX }}&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the deploy stage, Skaffold will use a Helm chart to deploy the built container to the Kubernetes cluster. Instead of spending time and effort to create and test a custom Helm chart for this purpose, you will use &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Node.js Helm chart&lt;/a&gt;. This is a ready-to-use, preconfigured solution that is compliant with current best practices and includes all the tools you need for a Node.js deployment on Kubernetes.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;remote&lt;/em&gt; parameter tells Skaffold that the chart is available in a remote repository (not locally) and the &lt;em&gt;chartPath&lt;/em&gt; parameter tells Skaffold where to find it. Skaffold relies on Helm&amp;rsquo;s repository list to locate the chart, so when using Bitnami&amp;rsquo;s Node.js chart as shown above, you must ensure that the Bitnami chart repository is known to Helm. If this is not the case, use the command below before proceeding to the next step:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm repo add bitnami https://charts.bitnami.com/bitnami
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Bitnami&amp;rsquo;s Node.js chart comes with a large number of configurable parameters, which allow you to tune the deployment to your needs. These parameters are set through the &lt;em&gt;setValues&lt;/em&gt; and &lt;em&gt;setValueTemplates&lt;/em&gt; options. Here&amp;rsquo;s a quick explanation of the ones used above:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;image.repository&lt;/em&gt; parameter tells the chart where to find the built image - in this case, the Docker Hub repository.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;image.tag&lt;/em&gt; parameter sets the tag to identify the image by - in this case, the auto-generated tag from the build stage.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;getAppFromExternalRepository&lt;/em&gt; parameter is set to &lt;em&gt;false&lt;/em&gt; because the application is already included in the generated image and does not need to be downloaded from an external source.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;service.type&lt;/em&gt; parameter configures the deployment to be available at a public load balancer IP address so that it can be easily reviewed or tested.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;applicationPort&lt;/em&gt; parameter exposes the application on port 3000, which is the port configured for the application in the &lt;em&gt;Dockerfile&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;For Node.js applications that use MongoDB, Bitnami&amp;rsquo;s Node.js chart will automatically deploy MongoDB on your cluster. Alternatively, if you&amp;rsquo;re using a cloud-based MongoDB service, you can skip the cluster deployment of MongoDB and instead configure the chart with the necessary credentials to connect to your remote MongoDB service. &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/node#parameters&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;See the complete list of available chart parameters&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;step-3-continuously-build-and-test-the-application&#34;&gt;Step 3: Continuously build and test the application&lt;/h2&gt;
&lt;p&gt;You&amp;rsquo;re now ready to build and test the application. Use the command below to tell Skaffold to start monitoring your project directory and build and deploy your Express application on Kubernetes using Bitnami&amp;rsquo;s container image and Helm chart:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;skaffold dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the build stage, Skaffold will build, tag and push your application to Docker Hub, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/express-app-bitnami-skaffold-octant/build.png&#34; alt=&#34;Build output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Once the image is built and pushed, Skaffold will proceed to the deployment stage and deploy the application on Kubernetes with Helm:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/express-app-bitnami-skaffold-octant/deploy.png&#34; alt=&#34;Deployment output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Once the deployment is complete, use the command shown in the output of the Helm chart to obtain the load balancer IP address for the service:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/express-app-bitnami-skaffold-octant/service.png&#34; alt=&#34;Service details&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;If you browse to the IP address, you should see the output of the Express application, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/express-app-bitnami-skaffold-octant/example-1.png&#34; alt=&#34;Example output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;To test the CD feature, make a change to the application - for example, update the message &amp;ldquo;Hello world&amp;rdquo; in the &lt;em&gt;app.js&lt;/em&gt; file to &amp;ldquo;Aloha world&amp;rdquo;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;sed -i &amp;#39;s/Hello world/Aloha world/g&amp;#39; app.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The change should be detected by Skaffold, which will build, push and deploy a fresh version of the application image to the Kubernetes cluster. Once the process is complete, browse to the application URL again and you should see the modified output of the application, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/express-app-bitnami-skaffold-octant/example-2.png&#34; alt=&#34;Example output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;At this point, you have successfully created a continuous development pipeline between your working directory and your Kubernetes cluster.&lt;/p&gt;
&lt;h2 id=&#34;step-4-monitor-and-inspect-the-running-application-with-octant&#34;&gt;Step 4: Monitor and inspect the running application with Octant&lt;/h2&gt;
&lt;p&gt;As you&amp;rsquo;re developing your application, it&amp;rsquo;s a good idea to monitor it on the cluster in real time. This gives you an idea of how it will behave under different conditions, and also lets you see the effect of changes you make to its deployment architecture.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://octant.dev&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Octant&lt;/a&gt; is an open source tool that lets you monitor your cluster and the applications running on it in real time through a simple Web interface. It also lets you debug faster by supporting granular inspection of Kubernetes objects and streaming container logs.&lt;/p&gt;
&lt;p&gt;Begin by downloading and install Octant to your system path using the &lt;a href=&#34;https://octant.dev/docs/master/getting-started&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;official installation instructions for your platform&lt;/a&gt;. Once Octant is installed, run it with the command below:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;octant
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will start a browser on your system and direct you to the Octant dashboard. In case you&amp;rsquo;re running Octant on a different or virtual host, you can instead use the command below and then browse to http://IP-ADDRESS:7777, where IP-ADDRESS is the IP address of the Octant host:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;octant --listener-addr 0.0.0.0:7777
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Note that Octant does not come with authentication enabled so, if accessing it remotely from a different host, ensure that your firewall configuration only allows access from whitelisted hosts or add your own authentication layer to avoid cluster information being exposed to unauthorized users.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Octant dashboard will display the running workloads on the cluster:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/express-app-bitnami-skaffold-octant/workloads.png&#34; alt=&#34;Octant workload display&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;You can also drill down to see individual pods, services, nodes and other cluster objects:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/express-app-bitnami-skaffold-octant/pods.png&#34; alt=&#34;Octant pod display&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Octant updates its data in real time so, when you make a change to your application and have it redeployed by Skaffold, the impact will be immediately visible in the Octant dashboard. This makes it a powerful tool to help developers understand how the application they are working on behaves on Kubernetes.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;p&gt;To learn more about the topics discussed in this guide, use the links below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Node.js container&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Node.js Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://skaffold.dev/docs/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Skaffold documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://octant.dev/docs/master/getting-started/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Octant documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://expressjs.com/en/starter/installing.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Express documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Customize GitLab&#39;s Default Auto DevOps Pipeline with Bitnami&#39;s Helm Charts</title>
      
      <link>/guides/ci-cd/gitlab-customize-default/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/guides/ci-cd/gitlab-customize-default/</guid>
      <description>

        
        &lt;p&gt;&lt;a href=&#34;https://bitnami.com/stack/gitlab&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s GitLab CE stack&lt;/a&gt; is a popular solution for agile development teams, providing a secure and fully-functional GitLab instance for software development and deployment. GitLab CE includes a Continuous Integration and Delivery (CI/CD) system that can build, test, and deploy software updates as well as a private registry for Docker containers.&lt;/p&gt;
&lt;p&gt;Bitnami also provides &lt;a href=&#34;https://github.com/bitnami/charts&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm charts&lt;/a&gt; for common applications. These charts make it easy to run applications on Kubernetes and are secure, up-to-date and built in conformance with current best practices. By combining these Helm charts with GitLab&amp;rsquo;s CI/CD system, developers can quickly create custom deployment pipelines on Kubernetes infrastructure for development, testing and production scenarios.&lt;/p&gt;
&lt;p&gt;This guide shows you how to integrate Bitnami&amp;rsquo;s Helm charts with GitLab&amp;rsquo;s Auto DevOps pipeline and create custom deployments on Kubernetes. With this configuration, every change to the application code in GitLab is automatically built as a Docker container and deployed to the Kubernetes cluster using &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s Node.js Helm chart&lt;/a&gt;. Bitnami&amp;rsquo;s Helm charts support a number of additional parameters to ease this integration, including the ability to configure each deployment such that it is available at a public IP address for review and test.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and prerequisites&lt;/h2&gt;
&lt;p&gt;This guide assumes that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;You have deployed the &lt;a href=&#34;https://bitnami.com/stack/gitlab&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami GitLab CE stack&lt;/a&gt; on a cloud server, connected it with your Kubernetes cluster and configured a default Auto DevOps pipeline for your application. For more information on how to complete these tasks, refer to our &lt;a href=&#34;https://docs.bitnami.com/tutorials/create-ci-cd-pipeline-gitlab-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;detailed tutorial on creating a CI/CD pipeline with GitLab and Kubernetes&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Your application is a Node.js application and the application code is hosted in a GitLab repository. &lt;a href=&#34;https://docs.bitnami.com/tutorials/create-ci-cd-pipeline-gitlab-kubernetes/#step-6-commit-test-and-repeat&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Obtain the sample application&amp;rsquo;s code and the Dockerfile to build it&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Other programming languages or frameworks will require a different chart, but the broad steps to configure and integrate a custom Helm chart with GitLab&amp;rsquo;s Auto DevOps will remain the same.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You have &lt;a href=&#34;https://git-scm.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Git&lt;/a&gt; and &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes#step-3-install-kubectl-command-line&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;em&gt;kubectl&lt;/em&gt;&lt;/a&gt; installed and configured to work with your GitLab CE installation and Kubernetes cluster respectively.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-1-replace-the-default-auto-devops-helm-chart-with-a-custom-chart&#34;&gt;Step 1: Replace the default Auto DevOps Helm chart with a custom chart&lt;/h2&gt;
&lt;p&gt;GitLab configures the Auto DevOps pipeline with a default Helm chart, but it&amp;rsquo;s possible to override this with a custom chart by either adding a chart to your code repository or, for charts hosted externally, by setting various pipeline variables that tell GitLab how to obtain the chart. In this tutorial, since the assumption is that you&amp;rsquo;re using a Node.js application, the latter approach will be followed and GitLab will be configured to use the Bitnami Node.js chart from the Bitnami chart repository.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Navigate to the project&amp;rsquo;s &amp;ldquo;Settings -&amp;gt; CI/CD&amp;rdquo; page.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the &amp;ldquo;Variables&amp;rdquo; section, add the following variables and values:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;AUTO_DEVOPS_CHART=bitnami/node
AUTO_DEVOPS_CHART_REPOSITORY=https://charts.bitnami.com/bitnami
AUTO_DEVOPS_CHART_REPOSITORY_NAME=bitnami
HELM_RELEASE_NAME=myproject
HELM_UPGRADE_EXTRA_ARGS=--set fullnameOverride=myproject --set service.type=LoadBalancer --set getAppFromExternalRepository=false --set applicationPort=5000 --set image.pullSecrets={gitlab-registry} --set image.registry=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click &amp;ldquo;Save variables&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-customize-default/set-variables.png&#34; alt=&#34;GitLab Auto DevOps configuration&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Here is a quick explanation of what these variables do:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;AUTO_DEVOPS_CHART&lt;/em&gt; variable sets the name of the custom chart to use, while the &lt;em&gt;AUTO_DEVOPS_CHART_REPOSITORY&lt;/em&gt; and &lt;em&gt;AUTO_DEVOPS_CHART_REPOSITORY_NAME&lt;/em&gt; variables define the chart repository URL and chart repository name respectively.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;HELM_RELEASE_NAME&lt;/em&gt; variable sets the Helm release name.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;HELM_UPGRADE_EXTRA_ARGS&lt;/em&gt; variable sets the list of arguments to be passed to the custom chart (this varies per chart).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For the Bitnami Node.js chart, the parameters passed via the &lt;em&gt;HELM_UPGRADE_EXTRA_ARGS&lt;/em&gt; command are as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;fullnameOverride&lt;/em&gt; parameter configures the deployment name. It must be set to the same value as the &lt;em&gt;HELM_RELEASE_NAME&lt;/em&gt; variable, or else Auto DevOps will fail to recognize the deployment and mark the pipeline as failed.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;service.type&lt;/em&gt; parameter configures the deployment to be available at a public load balancer IP address so that it can be easily reviewed or tested.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;getAppFromExternalRepository&lt;/em&gt; parameter is set to &lt;em&gt;false&lt;/em&gt; because the application is already included in the generated container image and does not need to be downloaded from an external source.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;applicationPort&lt;/em&gt; parameter exposes the application on port 5000, which is the port configured for the application in the &lt;em&gt;Dockerfile&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;image.registry&lt;/em&gt; parameter is set to an empty value, because GitLab already provides its own image registry.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;image.pullSecrets&lt;/em&gt; parameter specifies the secret holding the GitLab registry credentials. The secret is already created by Auto DevOps.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can also view the &lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/node#parameters&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;complete list of parameters supported by the chart&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Using a LoadBalancer service type will typically assign a static IP address for the deployment. Depending on your cloud provider&amp;rsquo;s policies, you may incur additional charges for this static IP address.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;step-2-commit-code-and-test-the-pipeline&#34;&gt;Step 2: Commit code and test the pipeline&lt;/h2&gt;
&lt;p&gt;At this point, you are ready to commit some code to the project and have GitLab test and deploy it using the Bitnami Helm chart. This tutorial assumes that you have a simple &amp;ldquo;Hello, world&amp;rdquo; application in Node.js, together with a Dockerfile to build it. If you don&amp;rsquo;t, you can &lt;a href=&#34;https://docs.bitnami.com/tutorials/create-ci-cd-pipeline-gitlab-kubernetes/#step-6-commit-test-and-repeat&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;obtain the sample application&amp;rsquo;s code and a Dockerfile to build it&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Commit a change to the application - for example, update the message &amp;ldquo;Hello world&amp;rdquo; in the &lt;em&gt;server.js&lt;/em&gt; file to &amp;ldquo;Yahoo world&amp;rdquo; - and push the change to GitLab:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;sed -i &amp;#39;s/Hello world/Yahoo world/g&amp;#39; server.js
git add .
git commit -m &amp;#34;Modified message text&amp;#34;
git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pushing this commit should automatically trigger the Auto DevOps pipeline in GitLab.&lt;/p&gt;
&lt;p&gt;In the first stage, GitLab will attempt to build a container image containing the application code using the provided Dockerfile. The container will be pushed to the internal GitLab registry. Here&amp;rsquo;s an example of the output you should see in this first stage:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-customize-default/pipeline-build.png&#34; alt=&#34;GitLab pipeline build output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Once the container image has been built and pushed, the second stage of the pipeline will attempt to deploy it to Kubernetes for review using Bitnami&amp;rsquo;s Node.js Helm chart. If successful, the stage output will display the commands you must run to obtain the load balancer IP address which you can browse to in order to see the application in action. Here&amp;rsquo;s an example of the output you should see in this second stage:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-customize-default/pipeline-deploy.png&#34; alt=&#34;GitLab pipeline deployment output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;If you run the commands shown in the output, you should see the load balancer IP address, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-customize-default/service.png&#34; alt=&#34;Service IP address&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Browse to the service IP address listed in the output and you should see the output of the Node.js application, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-customize-default/example-1.png&#34; alt=&#34;Example output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;At this point, you have successfully customized the default Auto DevOps pipeline provided by GitLab to use Bitnami&amp;rsquo;s Node.js Helm chart. Doing this ensures that your application deployments will always use a secure and up-to-date version of Node.js, while also giving you the flexibility to further customize the deployment as needed.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;p&gt;To learn more about the topics discussed in this guide, use the links below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/general/apps/gitlab/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami GitLab CE stack documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Node.js container&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/charts/tree/master/bitnami/node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Node.js Helm chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;GitLab documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      
      <title>Guides: Create a Continuous Integration Pipeline with GitLab and Kubernetes</title>
      
      <link>/guides/ci-cd/gitlab-auto-devops/</link>
      <pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/guides/ci-cd/gitlab-auto-devops/</guid>
      <description>

        
        &lt;p&gt;As development velocity increases, it&amp;rsquo;s now become essential for enterprises to have a reliable and readily-available Continuous Integration/Continuous Delivery (CI/CD) pipeline integrated with cloud infrastructure. But although the requirements of such infrastructure are well understood, setting up this pipeline is still a complex task involving knowledge of cloud platforms, containerization tools like Docker, Docker Compose and others, container orchestration tools like Kubernetes and Helm, and DevOps tools and techniques.&lt;/p&gt;
&lt;p&gt;Bitnami eases the task of building an enterprise-ready CI/CD pipeline with its application stacks and container images.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://bitnami.com/stack/gitlab&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s GitLab CE stack&lt;/a&gt; lets you deploy a secure and fully-functional GitLab instance on the cloud in a matter of minutes and integrate it with a Kubernetes cluster.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://bitnami.com/containers&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami&amp;rsquo;s containers&lt;/a&gt; for &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Node.js&lt;/a&gt;, &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-ruby&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Ruby&lt;/a&gt;, &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-java&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Java&lt;/a&gt;  and others makes it easy to containerize your applications in a secure and reliable manner.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Put the two together, and you have everything you need to create a modern, enterprise-grade CI/CD pipeline that leverages the scalability of Kubernetes with the flexibility of GitLab and the development agility of Bitnami containers. This guide walks you through the process.&lt;/p&gt;
&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;This guide shows you how to set up a CI/CD pipeline between GitLab (deployed using the &lt;a href=&#34;https://bitnami.com/stack/gitlab&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami GitLab CE stack&lt;/a&gt;) and a Kubernetes cluster with GitLab&amp;rsquo;s Auto DevOps feature. With this configuration, every change to application code is automatically built as a Docker container (based on a &lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Node.js base container&lt;/a&gt;) and deployed to the Kubernetes cluster for review and test.&lt;/p&gt;
&lt;p&gt;Communication and monitoring between the GitLab deployment and the Kubernetes cluster is achieved through the use of &lt;a href=&#34;https://helm.sh&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Helm&lt;/a&gt;, &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Ingress&lt;/a&gt; and &lt;a href=&#34;https://docs.gitlab.com/runner/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;GitLab Runner&lt;/a&gt;. When GitLab deploys each built container to the cluster, it also makes it available for review at an auto-generated sub-domain of your main domain name.&lt;/p&gt;
&lt;h2 id=&#34;assumptions-and-prerequisites&#34;&gt;Assumptions and prerequisites&lt;/h2&gt;
&lt;p&gt;This guide makes the following assumptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have deployed the Bitnami GitLab CE stack on a cloud server and have the GitLab CE administrator credentials. Learn about &lt;a href=&#34;https://docs.bitnami.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;deploying Bitnami applications&lt;/a&gt; and &lt;a href=&#34;https://docs.bitnami.com/general/faq/get-started/find-credentials/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;obtaining credentials&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have a multi-node Kubernetes cluster running. &lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about deploying a Kubernetes cluster on different cloud platforms&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have the &lt;em&gt;kubectl&lt;/em&gt; command line (kubectl CLI) installed. &lt;a href=&#34;https://docs.bitnami.com/kubernetes/get-started-kubernetes#step-3-install-kubectl-command-line&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about &lt;em&gt;kubectl&lt;/em&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have &lt;a href=&#34;https://git-scm.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Git&lt;/a&gt; installed.&lt;/li&gt;
&lt;li&gt;You have a domain name and the ability to configure a wildcard DNS record for that domain name. &lt;a href=&#34;https://en.wikipedia.org/wiki/Wildcard_DNS_record&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about wildcard DNS records&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You have an SSH key pair which you can use for repository commits. To generate a new SSH key pair, use PuTTYgen (Windows) or the &lt;em&gt;ssh-keygen&lt;/em&gt; command (Linux and Mac OS X). Learn about &lt;a href=&#34;http://winscp.net/eng/docs/ui_puttygen&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;PuTTYgen&lt;/a&gt; and &lt;a href=&#34;http://www.macworld.co.uk/how-to/mac-software/how-generate-ssh-keys-3521606/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;em&gt;ssh-keygen&lt;/em&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-1-configure-dns-and-ssl-for-gitlab&#34;&gt;Step 1: Configure DNS and SSL for GitLab&lt;/h2&gt;
&lt;p&gt;As a first step, you must configure a domain name and SSL certificate for GitLab, such that browsing to the domain directs you to a secure page for your GitLab deployment. If you already have an SSL certificate for your domain, you can continue to use that or, if not, you can follow the approach below and generate a free Let&amp;rsquo;s Encrypt SSL certificate.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Follow the instructions to &lt;a href=&#34;https://docs.bitnami.com/general/faq/configuration/configure-custom-domain/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;configure a custom domain for GitLab&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;While logged in to the server console, &lt;a href=&#34;https://docs.bitnami.com/general/apps/gitlab/administration/generate-configure-certificate-letsencrypt/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;manually generate and install a Let&amp;rsquo;s Encrypt certificate using &lt;em&gt;lego&lt;/em&gt;&lt;/a&gt; as described in our guide.&lt;/li&gt;
&lt;li&gt;Test the configuration by browsing to &lt;em&gt;https://DOMAIN&lt;/em&gt; (replace the DOMAIN placeholder with the correct domain name) and confirming that you see a secure GitLab login page, as shown below:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/gitlab-ssl.png&#34; alt=&#34;GitLab secure login&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;step-2-configure-and-activate-the-gitlab-registry&#34;&gt;Step 2: Configure and activate the GitLab registry&lt;/h2&gt;
&lt;p&gt;The next step is to activate the GitLab registry, as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Log in to the server console using SSH (if you&amp;rsquo;re not already logged in).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Edit the &lt;em&gt;/etc/gitlab/gitlab.rb&lt;/em&gt; file and uncomment and update the &lt;em&gt;registry_external_url&lt;/em&gt; parameter as below, remembering to replace the DOMAIN placeholder with the GitLab domain name:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;registry_external_url &amp;#39;https://DOMAIN:5005&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the same file, uncomment and update the &lt;em&gt;external_url&lt;/em&gt; parameter as below, replacing the DOMAIN placeholder with the GitLab domain name:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;external_url &amp;#39;https://DOMAIN&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Save your changes to the file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Configure the GitLab registry to use the SSL certificates generated in the previous step. Replace the DOMAIN placeholder with the GitLab domain name.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;cd /etc/gitlab/ssl
sudo ln -sf server.crt DOMAIN.crt
sudo ln -sf server.key DOMAIN.key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Execute the commands below to reconfigure and restart GitLab with the changes.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;sudo gitlab-ctl reconfigure
sudo /opt/bitnami/ctlscript.sh restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Open port 5005 in the server firewall so that GitLab can connect to, and push built containers, to its internal registry. &lt;a href=&#34;https://docs.bitnami.com/general/faq/administration/use-firewall/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about opening firewall ports for your cloud platform&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-3-create-a-new-gitlab-project&#34;&gt;Step 3: Create a new GitLab project&lt;/h2&gt;
&lt;p&gt;You can now log in to GitLab and prepare a new project. This project will host the code that you will eventually run through your CI/CD pipeline to build and deploy on Kubernetes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Browse to your GitLab domain and log in using the administrator credentials.&lt;/li&gt;
&lt;li&gt;On the welcome page, select the &amp;ldquo;Create a project&amp;rdquo; option.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/create-project.png&#34; alt=&#34;GitLab project creation&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Enter a name and slug for your project. Set the visibility level to &amp;ldquo;Internal&amp;rdquo;. Click &amp;ldquo;Create project&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/configure-project.png&#34; alt=&#34;GitLab project creation&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Your project is created and you should see the project page, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/new-project.png&#34; alt=&#34;GitLab project page&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Click the &amp;ldquo;Clone&amp;rdquo; button and note the clone URL for the repository, which will be needed in &lt;a href=&#34;#step-6-commit-test-and-repeat&#34;&gt;Step 6&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/project-clone-url.png&#34; alt=&#34;GitLab project clone URL&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Before you can commit any code to the project repository, you must add your SSH key to your profile, as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Click your user profile icon in the top right corner of the navigation bar.&lt;/li&gt;
&lt;li&gt;Select the &amp;ldquo;Settings&amp;rdquo; menu icon.&lt;/li&gt;
&lt;li&gt;On the &amp;ldquo;User Settings&amp;rdquo; page, select the &amp;ldquo;SSH Keys&amp;rdquo; menu item.&lt;/li&gt;
&lt;li&gt;Paste the public key component of your SSH key pair in the &amp;ldquo;Key&amp;rdquo; field. Add an optional label and click the &amp;ldquo;Add Key&amp;rdquo; button to save the changes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/add-ssh-key.png&#34; alt=&#34;GitLab key addition&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;step-4-configure-a-kubernetes-cluster-for-the-project&#34;&gt;Step 4: Configure a Kubernetes cluster for the project&lt;/h2&gt;
&lt;p&gt;GitLab comes with built-in support for Kubernetes, making it easy to build and test your projects using a Kubernetes cluster. &lt;a href=&#34;https://docs.gitlab.com/ee/user/project/clusters/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about Kubernetes support in GitLab&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;First, allow outbound requests from GitLab hooks and services, as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Navigate to the GitLab administration panel by selecting the &amp;ldquo;Admin Area&amp;rdquo; link.&lt;/li&gt;
&lt;li&gt;Navigate to the &amp;ldquo;Settings -&amp;gt; Network&amp;rdquo; page and select the &amp;ldquo;Outbound requests&amp;rdquo; section.&lt;/li&gt;
&lt;li&gt;Tick the checkboxes to allow requests to the local network from hooks and services.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/allow-network-requests.png&#34; alt=&#34;GitLab network requests&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Then, configure your Kubernetes cluster in GitLab by following these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use the &lt;em&gt;kubectl&lt;/em&gt; command-line tool to obtain the following details for your Kubernetes cluster using the &lt;a href=&#34;https://docs.gitlab.com/ee/user/project/clusters/#add-existing-kubernetes-cluster&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;instructions in the GitLab documentation&lt;/a&gt;:
&lt;ul&gt;
&lt;li&gt;Cluster API URL&lt;/li&gt;
&lt;li&gt;Cluster CA certificate&lt;/li&gt;
&lt;li&gt;Cluster service token&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;From the project page in GitLab, select the &amp;ldquo;Operations -&amp;gt; Kubernetes&amp;rdquo; menu item.&lt;/li&gt;
&lt;li&gt;On the resulting page, click the &amp;ldquo;Add Kubernetes cluster&amp;rdquo; button.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/add-cluster.png&#34; alt=&#34;GitLab cluster configuration&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Select the &amp;ldquo;Add existing cluster&amp;rdquo; tab.&lt;/li&gt;
&lt;li&gt;Enter a name for your cluster with the API URL, CA certificate and server token obtained already. Check the boxes for &amp;ldquo;RBAC-enabled&amp;rdquo; cluster and &amp;ldquo;GitLab-managed cluster&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/configure-cluster.png&#34; alt=&#34;GitLab cluster configuration&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Click the &amp;ldquo;Add Kubernetes cluster&amp;rdquo; button to save the changes.&lt;/li&gt;
&lt;li&gt;On the resulting page, find the &amp;ldquo;Applications&amp;rdquo; section and install Helm, followed by Ingress. Note the Ingress endpoint IP address generated after installing Ingress.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/install-helm-ingress.png&#34; alt=&#34;Helm/Ingress installation&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Configure a wildcard DNS record for your domain pointing to the Ingress IP address through your DNS provider&amp;rsquo;s control panel. Learn how to configure wildcard DNS records for popular DNS providers like &lt;a href=&#34;https://www.godaddy.com/help/set-up-wildcard-dns-3301&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;GoDaddy&lt;/a&gt;, &lt;a href=&#34;https://www.namecheap.com/support/knowledgebase/article.aspx/597/2237/how-can-i-set-up-a-catchall-wildcard-subdomain&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;NameCheap&lt;/a&gt; and &lt;a href=&#34;https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html#domain-name-format-asterisk&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;AWS Route53&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Enter the base domain name used by the wildcard DNS record in the &amp;ldquo;Base domain&amp;rdquo; field in your GitLab Kubernetes cluster configuration. For example, if you configured a wildcard DNS record for *&lt;em&gt;.example.com&lt;/em&gt;, use &lt;em&gt;example.com&lt;/em&gt; as the base domain name. This will be the base domain used for all Auto DevOps review deployments. Click &amp;ldquo;Save changes&amp;rdquo; to save the changes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/configure-base-domain.png&#34; alt=&#34;GitLab base domain configuration&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Return to the &amp;ldquo;Applications&amp;rdquo; section and install Cert-Manager. Remember to provide a valid email address so that Cert-Manager can correctly associate your certificates with your account.&lt;/li&gt;
&lt;li&gt;From the same &amp;ldquo;Applications&amp;rdquo; section, install GitLab Runner.&lt;/li&gt;
&lt;li&gt;Confirm that the runner is successfully installed and activated for the project by navigating to the project&amp;rsquo;s &amp;ldquo;Settings -&amp;gt; CI/CD&amp;rdquo; page and checking the status of the runner in the &amp;ldquo;Runners&amp;rdquo; section.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/check-runner-status.png&#34; alt=&#34;GitLab runner status&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;step-5-enable-auto-devops-for-the-project&#34;&gt;Step 5: Enable Auto DevOps for the project&lt;/h2&gt;
&lt;p&gt;Once the Kubernetes integration is complete and a runner is active, enable Auto DevOps for the project. Auto DevOps provides a preconfigured CI/CD pipeline which can be used to quickly get started with building, testing and deploying your project. &lt;a href=&#34;https://docs.gitlab.com/ee/topics/autodevops/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn more about Auto DevOps in GitLab&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To enable Auto DevOps for the project:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Navigate to the project&amp;rsquo;s &amp;ldquo;Settings -&amp;gt; CI/CD&amp;rdquo; page.&lt;/li&gt;
&lt;li&gt;In the &amp;ldquo;Auto DevOps&amp;rdquo; section, check the box for &amp;ldquo;Default to Auto DevOps pipeline&amp;rdquo; and select the &amp;ldquo;Continuous deployment to production&amp;rdquo; strategy.&lt;/li&gt;
&lt;li&gt;Click &amp;ldquo;Save changes&amp;rdquo; to enable the default pipeline.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/enable-auto-devops.png&#34; alt=&#34;GitLab Auto DevOps configuration&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The default Auto DevOps pipeline comes with various stages already configured, depending on which version of GitLab you are running. For example, there are stages to build, run tests, check code quality, scan for dependencies, review code, deploy code and test performance. This default pipeline is fully customizable and stages can be added or removed depending on your requirements, simply by adjusting pipeline variables. &lt;a href=&#34;https://docs.gitlab.com/ee/topics/autodevops/#environment-variables&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Learn about the available variables&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This tutorial will focus on creating a very simple pipeline consisting of only two stages: build and deploy. To turn off the other stages included in the default pipeline, follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Navigate to the project&amp;rsquo;s &amp;ldquo;Settings -&amp;gt; CI/CD&amp;rdquo; page.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the &amp;ldquo;Variables&amp;rdquo; section, add the following three variables and values:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;TEST_DISABLED: true
CODE_QUALITY_DISABLED: true
PERFORMANCE_DISABLED: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click &amp;ldquo;Save variables&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/set-variables.png&#34; alt=&#34;GitLab Auto DevOps configuration&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;step-6-commit-test-and-repeat&#34;&gt;Step 6: Commit, test and repeat&lt;/h2&gt;
&lt;p&gt;At this point, you are ready to commit some code to the project and have GitLab test and deploy it. This tutorial will create a simple &amp;ldquo;Hello, world&amp;rdquo; application in Node.js and then configure a Dockerfile to run it with Bitnami&amp;rsquo;s Node.js development container image.&lt;/p&gt;
&lt;p&gt;Follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Create a working directory for the application on your local host:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;mkdir myproject
cd myproject
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;package.json&lt;/em&gt; file listing the dependencies for the project:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;simple-node-app&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;1.0.0&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Node.js on Docker&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;main&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;server.js&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;scripts&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;node server.js&amp;#34;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;dependencies&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;express&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;^4.13&amp;#34;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;server.js&lt;/em&gt; file for the Express application which returns a &amp;ldquo;Hello world&amp;rdquo; message on access:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;use strict&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;express&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;require&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;express&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Constants
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// App
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;express&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Hello world\n&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;console&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Running on http://localhost:&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;em&gt;Dockerfile&lt;/em&gt; with the following content:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; bitnami/node:9 as builder&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENV&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_ENV&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;production&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Copy app&amp;#39;s source code to the /app directory&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; . /app&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# The application&amp;#39;s directory will be the working directory&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WORKDIR&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; /app&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Install Node.js dependencies defined in &amp;#39;/app/packages.json&amp;#39;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;RUN&lt;/span&gt; npm install&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; bitnami/node:9-prod&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENV&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NODE_ENV&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;production&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; --from&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;builder /app /app&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WORKDIR&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; /app&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENV&lt;/span&gt; PORT &lt;span class=&#34;m&#34;&gt;5000&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;EXPOSE&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; 5000&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Start the application&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;CMD&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;npm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This multi-stage &lt;em&gt;Dockerfile&lt;/em&gt; creates a new image using Bitnami&amp;rsquo;s Node.js container image as base. It copies the application files to the container&amp;rsquo;s &lt;em&gt;/app&lt;/em&gt; directory and then runs &lt;em&gt;npm install&lt;/em&gt; to install Express. It then creates a production-ready container image and configures the application to listen to request on port 5000.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Exposing the application on port 5000 is a requirement of GitLab&amp;rsquo;s &lt;a href=&#34;https://gitlab.com/gitlab-org/charts/auto-deploy-app&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;default Helm chart&lt;/a&gt;, which is used to deploy the application to the cluster. This can be overridden if needed using a custom Helm chart. Read more in our tutorial on &lt;a href=&#34;https://docs.bitnami.com/tutorials/customize-ci-cd-pipeline-gitlab-bitnami-charts&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;using a custom Helm chart with the Auto DevOps pipeline&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Initialize a Git repository and commit and push the application code to GitLab. Replace the NAME and EMAIL-ADDRESS placeholders with your name and email address (if not already configured) and the CLONE-URL placeholder with the repository clone URL obtained in &lt;a href=&#34;#step-3-create-a-new-gitlab-project&#34;&gt;Step 3&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;git config --global user.name &amp;#34;NAME&amp;#34;
git config --global user.name &amp;#34;EMAIL-ADDRESS&amp;#34;
git init    
git remote add origin CLONE-URL
git add .
git commit -m &amp;#34;Initial commit&amp;#34;
git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pushing this commit should automatically trigger the Auto DevOps pipeline in GitLab. To see the pipeline in action, navigate to the project&amp;rsquo;s &amp;ldquo;CI/CD -&amp;gt; Pipelines&amp;rdquo; page and confirm that the pipeline is running, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/running-pipeline.png&#34; alt=&#34;GitLab pipeline&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;In the first stage, GitLab will attempt to build a container image containing the application code using the provided Dockerfile. The container will be pushed to the internal GitLab registry. Here&amp;rsquo;s an example of the output you should see in this first stage:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/pipeline-build.png&#34; alt=&#34;GitLab pipeline build output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Once the container image has been built and pushed, the second stage of the pipeline will attempt to deploy it to Kubernetes for review. If successful, the stage output will display a URL, which you can browse to in order to see the application in action. Here&amp;rsquo;s an example of the output you should see in this second stage:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/pipeline-deploy.png&#34; alt=&#34;GitLab pipeline deployment output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;If you browse to the application URL listed in the output, you should see the output of the Node.js app, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/example-1.png&#34; alt=&#34;Example output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;To test the CI/CD feature, make a change to the application - for example, update the message &amp;ldquo;Hello world&amp;rdquo; in the &lt;em&gt;server.js&lt;/em&gt; file to &amp;ldquo;Aloha world&amp;rdquo; - and push the change to GitLab.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;sed -i &amp;#39;s/Hello world/Aloha world/g&amp;#39; server.js
git add .
git commit -m &amp;#34;Modified message text&amp;#34;
git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The new commit should trigger the pipeline, causing a new build and deployment to take place, and the new application will be deployed on your cluster for review. As before, check pipeline status in GitLab, wait for it to complete and then browse to the application URL listed in the output of the second stage. You should see the revised output, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/guides/ci-cd/gitlab-auto-devops/example-2.png&#34; alt=&#34;Example output&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;At this point, you have successfully created a simple CI/CD pipeline between GitLab and a Kubernetes cluster. You can now continue to enhance it by &lt;a href=&#34;https://docs.gitlab.com/ee/topics/autodevops/#features&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;adding new stages to the Auto DevOps pipeline&lt;/a&gt;, modifying how your code is deployed with a &lt;a href=&#34;https://docs.gitlab.com/ee/topics/autodevops/#custom-helm-chart&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;custom deployment Helm chart&lt;/a&gt;, or &lt;a href=&#34;https://docs.gitlab.com/ee/user/project/pipelines/schedules.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;configuring pipelines to run on a schedule&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;useful-links&#34;&gt;Useful links&lt;/h2&gt;
&lt;p&gt;To learn more about the topics discussed in this guide, use the links below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/general/apps/gitlab/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami GitLab CE stack documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bitnami/bitnami-docker-node#&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami Node.js container&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/general/faq/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami applications FAQ&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bitnami.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Bitnami documentation for Kubernetes deployments on different cloud platforms&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;GitLab documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Wildcard_DNS_record&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Wildcard DNS records&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Key generation with &lt;a href=&#34;http://winscp.net/eng/docs/ui_puttygen&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;PuTTYgen&lt;/a&gt; and &lt;a href=&#34;http://www.macworld.co.uk/how-to/mac-software/how-generate-ssh-keys-3521606/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;em&gt;ssh-keygen&lt;/em&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
