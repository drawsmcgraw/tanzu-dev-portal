<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>VMware Tanzu Developer Center – RabbitMQ</title>
    <link>/tags/rabbitmq/</link>
    <description>Recent content in RabbitMQ on VMware Tanzu Developer Center</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 16 Nov 2020 00:00:00 +0000</lastBuildDate>
    
	  <atom:link href="/tags/rabbitmq/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      
      <title>Blog: Understanding the Differences Between RabbitMQ vs Kafka</title>
      
      <link>/blog/understanding-the-differences-between-rabbitmq-vs-kafka/</link>
      <pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/understanding-the-differences-between-rabbitmq-vs-kafka/</guid>
      <description>

        
        &lt;p&gt;Three years ago, a colleague of mine wrote a post to help readers understand when to use RabbitMQ and when to use Apache Kafka, which many found to be very useful. While the two solutions take very different approaches architecturally and can solve very different problems, many find themselves comparing them for overlapping solutions. In an increasingly distributed environment where more and more services need to communicate with each other, RabbitMQ and Kafka have both come to be popular services that facilitate that communication.&lt;/p&gt;
&lt;p&gt;It has been three years since that post was published, however, which in technology can be lifetime. We thought this would be a great opportunity to revisit how RabbitMQ and Kafka have changed, check if their strengths have shifted, and see how they fit into today’s use case.&lt;/p&gt;
&lt;h2 id=&#34;what-are-rabbitmq-and-apache-kafka&#34;&gt;What Are RabbitMQ and Apache Kafka?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.rabbitmq.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;RabbitMQ&lt;/a&gt; is often summarized as an “open source &lt;a href=&#34;https://www.rabbitmq.com/tutorials/amqp-concepts.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;distributed message broker&lt;/a&gt;.” Written in Erlang, it facilitates the efficient delivery of messages in complex routing scenarios. Initially built around the popular &lt;a href=&#34;https://www.amqp.org/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;AMQP&lt;/a&gt; protocol, it’s also highly compatible with existing technologies, while its capabilities can be expanded through plug-ins enabled on the server. RabbitMQ brokers can be &lt;a href=&#34;https://www.rabbitmq.com/distributed.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;distributed&lt;/a&gt; and configured to be reliable in case of network or server failure.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kafka.apache.org/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Apache Kafka,&lt;/a&gt; on the other hand, is described as a “distributed event streaming platform.” Rather than focusing on flexible routing, it instead facilitates raw throughput. Written in Scala and Java, Kafka builds on the idea of a “distributed append-only log” where messages are written to the end of a log that’s persisted to disk, and clients can choose where they begin reading from that log. Likewise, Kafka clusters can be distributed and clustered across multiple servers for a higher degree of availability.&lt;/p&gt;
&lt;h2 id=&#34;rabbitmq-vs-kafka&#34;&gt;RabbitMQ vs. Kafka&lt;/h2&gt;
&lt;p&gt;While they’re not the same service, many often narrow down their messaging options to these two, but are left wondering which of them is better. I’ve long believed that’s not the correct question to ask. Instead, you want to focus on what each service excels at, analyze their differences, and then decide which of the two best fits your use case. Even outside of the features of either service, you should also take into consideration the skills needed to operate the services and the developer communities around them.&lt;/p&gt;
&lt;h2 id=&#34;requirements-and-use-cases&#34;&gt;Requirements and Use Cases&lt;/h2&gt;
&lt;p&gt;When the initial blog post was written, there was a pretty clear-cut difference in design between RabbitMQ and Kafka, and as such, a difference in use cases. RabbitMQ’s message broker design excelled in use cases that had specific routing needs and per-message guarantees, whereas Kafka’s append-only log allowed developers access to the stream history and more direct stream processing. While the Venn diagram of use cases these two technologies could fulfill was very tight, there were scenarios in which one was a demonstrably better choice than the other.&lt;/p&gt;
&lt;p&gt;Work is currently underway that will alter  that balance, however. While RabbitMQ will continue to offer its traditional queue model, it will also  introduce a new data structure modeling an append-only log, with non-destructive consuming semantics. This new data structure will work much like Kafka’s persistent log, and will be an exciting addition for RabbitMQ users looking to expand their streaming use case. And while this feature will be compatible with the AMQP protocol, it will also introduce a binary-based stream protocol.&lt;/p&gt;
&lt;h2 id=&#34;developer-experience&#34;&gt;Developer Experience&lt;/h2&gt;
&lt;p&gt;The developer experience of the two services has largely remained the same, with the list of clients and libraries continuing to grow thanks to the work of their respective communities. Both &lt;a href=&#34;https://www.rabbitmq.com/devtools.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;RabbitMQ’s&lt;/a&gt; and &lt;a href=&#34;https://cwiki.apache.org/confluence/display/KAFKA/Clients&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kafka’s&lt;/a&gt; client library lists have seen steady growth. As more languages and frameworks have grown in popularity, finding a well-supported and complete library for either service has become easier.&lt;/p&gt;
&lt;p&gt;One thing to note is the growth of &lt;a href=&#34;https://kafka.apache.org/documentation/streams/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kafka Streams&lt;/a&gt;, a client library implementation that makes it easier for developers to process streaming data. It’s used for the common use case of reading data from Kafka, processing it, and writing it to another Kafka queue. Additionally, &lt;a href=&#34;https://ksqldb.io&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;ksqlDB&lt;/a&gt; is well worth checking out for developers looking to build streaming applications while taking advantage of their familiarity with relational databases.&lt;/p&gt;
&lt;p&gt;A similar thing can be accomplished with RabbitMQ with the help of some other pieces, such as &lt;a href=&#34;https://dataflow.spring.io/docs/stream-developer-guides/streams/standalone-stream-rabbitmq/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Spring Cloud Data Flow&lt;/a&gt;. Furthermore, note the upcoming streaming changes coming for RabbitMQ mentioned in the previous section, keeping in mind that this can open new ways of interacting with RabbitMQ for the developer.&lt;/p&gt;
&lt;h2 id=&#34;security-and-operations&#34;&gt;Security and Operations&lt;/h2&gt;
&lt;p&gt;As noted in the initial post, RabbitMQ ships with a useful administration interface to manage users and queues, while Kafka relies on &lt;a href=&#34;https://www.rabbitmq.com/ssl.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;TLS&lt;/a&gt; and &lt;a href=&#34;https://www.rabbitmq.com/access-control.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;JAAS&lt;/a&gt;. Whether you choose RabbitMQ or Kafka will of course depend on your specific requirements and your use case, but most security scenarios can have a proper conclusion with either technology.&lt;/p&gt;
&lt;p&gt;It’s important to note the rise of Kubernetes over the last few years and how it affects the operations of services. Substantial work has been done to allow infrastructure operators to run both RabbitMQ and Kafka on Kubernetes. The &lt;a href=&#34;https://www.rabbitmq.com/blog/2020/11/17/rabbitmq-kubernetes-operator-reaches-1-0&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;RabbitMQ operator&lt;/a&gt; and &lt;a href=&#34;https://bitnami.com/stack/kafka/helm&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Kafka Helm chart&lt;/a&gt; both have very fine control over how these services are configured as well as how to run them on Kubernetes specifically. This makes it extremely easy to get up and running with both of them configured and clustered out of the box.&lt;/p&gt;
&lt;h2 id=&#34;performance&#34;&gt;Performance&lt;/h2&gt;
&lt;p&gt;Performance, as was also noted in the initial post, can be hard to quantify with so many variables coming into play, including how the service is configured, how your code interacts with it, and of course the hardware it&amp;rsquo;s running on. Everything from network to memory and disk speed can dramatically impact the performance of the service. Of course, both RabbitMQ and Kafka optimize for performance, but you should also make sure your use case leverages them to maximize efficiency.&lt;/p&gt;
&lt;p&gt;For RabbitMQ, there are some great how-to resources  about maximizing performance, such as how to &lt;a href=&#34;https://www.rabbitmq.com/blog/2020/06/04/how-to-run-benchmarks/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;benchmark&lt;/a&gt; and &lt;a href=&#34;https://www.rabbitmq.com/blog/2020/06/18/cluster-sizing-and-other-considerations/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;size your cluster&lt;/a&gt;. These guides detail best practices for how to configure your clusters and how your code should interact with them for the best performance possible. Much of this advice revolves around things like managing queue size and connections, and being careful about how your client consumes messages. The &lt;a href=&#34;https://www.rabbitmq.com/clustering.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;RabbitMQ clustering guide&lt;/a&gt;  also includes things to keep in mind when building a cluster.&lt;/p&gt;
&lt;p&gt;Likewise, Confluent has a great &lt;a href=&#34;https://docs.confluent.io/current/kafka/deployment.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Running Kafka in Production&lt;/a&gt; guide that covers many of the same concerns for when you’re building the hardware that will run your Kafka cluster, as well as how you configure the cluster itself. There are a couple of things you’ll need to keep in mind since Kafka runs on top of the JVM, but it does a great job of pointing those out.&lt;/p&gt;
&lt;p&gt;If you’re interested in raw numbers, both the &lt;a href=&#34;https://www.rabbitmq.com/blog/category/performance-2/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;RabbitMQ team&lt;/a&gt; and the &lt;a href=&#34;https://www.confluent.io/blog/kafka-fastest-messaging-system/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Confluent team&lt;/a&gt; have recently put out their respective benchmarks. Both include a lot of details on how the clusters were configured and the workload that was placed on them, so make sure you take that information into consideration when reading the results. Use case and operations should significantly factor into your decision as well.&lt;/p&gt;
&lt;h2 id=&#34;making-the-call&#34;&gt;Making the Call&lt;/h2&gt;
&lt;p&gt;Deciding whether to use RabbitMQ or Kafka was never easy, and with both technologies improving every day, the margins of advantage have only gotten smaller.  The decision you make will depend on your individual scenario. Make use of the knowledge contained both in this post and the &lt;a href=&#34;https://tanzu.vmware.com/content/blog/understanding-when-to-use-rabbitmq-or-apache-kafka&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;original one&lt;/a&gt; and apply it to the familiarity you have with your use case along with any proof of concepts.&lt;/p&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;/css/faq.css&#34;&gt;
&lt;div class=&#34;faqs&#34; id=&#34;faqs&#34;&gt;
    &lt;div class=&#34;flex-container jc-between&#34;&gt;&lt;/div&gt;
        &lt;h2 class=&#34;h2 mb-md&#34;&gt;Frequently Asked Questions&lt;/h2&gt;
        &lt;div class=&#34;faq&#34;&gt;
            
  &lt;div class=&#34;faq-item&#34; id=&#34;faq-item&#34;&gt;
    &lt;div class=&#34;flex jc-between ai-center&#34;&gt;
        &lt;h4 class=&#34;faq-question&#34;&gt;What is the difference between Kafka and RabbitMQ?&lt;/h4&gt;
        &lt;i class=&#34;fa fa-angle-down&#34; id=&#34;arrow&#34;&gt;&lt;/i&gt;
    &lt;/div&gt;
    &lt;div class=&#34;faq-answer&#34;&gt;
        &lt;div&gt;Kafka is a distributed event streaming platform that facilitates raw throughput, focused on a distributed append-only log that can be clustered across multiple servers for a higher degree of availability. This differs from RabbitMQ, an open source distributed message broker that efficiently facilitates the delivery of messages in complex routing scenarios. RabbitMQ capabilities can be expanded through the use of plug-ins enabled on the server. They can also be distributed and configured to be reliable in the case of server or network failure.&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
  &lt;div class=&#34;faq-item&#34; id=&#34;faq-item&#34;&gt;
    &lt;div class=&#34;flex jc-between ai-center&#34;&gt;
        &lt;h4 class=&#34;faq-question&#34;&gt;When should you use Kafka vs RabbitMQ?&lt;/h4&gt;
        &lt;i class=&#34;fa fa-angle-down&#34; id=&#34;arrow&#34;&gt;&lt;/i&gt;
    &lt;/div&gt;
    &lt;div class=&#34;faq-answer&#34;&gt;
        &lt;div&gt;Kafka&amp;rsquo;s append-only log allows developers to access stream history and direct stream processing, while RabbitMQ&amp;rsquo;s message broker design excels in use cases that have specific routing needs and per-message guarantees. However, RabbitMQ is developing a new data structure model to the append-only log that will close the gap in streaming use cases.&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
  &lt;div class=&#34;faq-item&#34; id=&#34;faq-item&#34;&gt;
    &lt;div class=&#34;flex jc-between ai-center&#34;&gt;
        &lt;h4 class=&#34;faq-question&#34;&gt;Can Kafka and RabbitMQ be deployed on Kubernetes?&lt;/h4&gt;
        &lt;i class=&#34;fa fa-angle-down&#34; id=&#34;arrow&#34;&gt;&lt;/i&gt;
    &lt;/div&gt;
    &lt;div class=&#34;faq-answer&#34;&gt;
        &lt;div&gt;Yes, both Kafka and RabbitMQ can be deployed on Kubernetes.&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
  &lt;div class=&#34;faq-item&#34; id=&#34;faq-item&#34;&gt;
    &lt;div class=&#34;flex jc-between ai-center&#34;&gt;
        &lt;h4 class=&#34;faq-question&#34;&gt;Should you use Kafka or RabbitMQ for microservices?&lt;/h4&gt;
        &lt;i class=&#34;fa fa-angle-down&#34; id=&#34;arrow&#34;&gt;&lt;/i&gt;
    &lt;/div&gt;
    &lt;div class=&#34;faq-answer&#34;&gt;
        &lt;div&gt;While Kafka utilizes a straightforward, high performance routing approach ideal for big data use cases, RabbitMQ is ideal for blocking tasks and allows for faster server response time. Both options are suitable depending on your specific use case.&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
  &lt;div class=&#34;faq-item&#34; id=&#34;faq-item&#34;&gt;
    &lt;div class=&#34;flex jc-between ai-center&#34;&gt;
        &lt;h4 class=&#34;faq-question&#34;&gt;Is Kafka higher performance than RabbitMQ?&lt;/h4&gt;
        &lt;i class=&#34;fa fa-angle-down&#34; id=&#34;arrow&#34;&gt;&lt;/i&gt;
    &lt;/div&gt;
    &lt;div class=&#34;faq-answer&#34;&gt;
        &lt;div&gt;Both Kafka and RabbitMQ optimize for performance, which can be very hard to quantify depending on your specific use case. While Kafka has a very high throughput, RabbitMQ excels at low latency message delivery. Of course, service configuration, code interaction, hardware, and network speed will dramatically impact the performance of either service.&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
  &lt;div class=&#34;faq-item&#34; id=&#34;faq-item&#34;&gt;
    &lt;div class=&#34;flex jc-between ai-center&#34;&gt;
        &lt;h4 class=&#34;faq-question&#34;&gt;What are the different use cases for Kafka vs. RabbitMQ?&lt;/h4&gt;
        &lt;i class=&#34;fa fa-angle-down&#34; id=&#34;arrow&#34;&gt;&lt;/i&gt;
    &lt;/div&gt;
    &lt;div class=&#34;faq-answer&#34;&gt;
        &lt;div&gt;Kafka is ideal for big data use cases that require the best throughput, while RabbitMQ is ideal for low latency message delivery, guarantees on a per-message basis, and complex routing.&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

        &lt;/div&gt;
    &lt;/div&gt;
    
&lt;/div&gt;

&lt;script type=&#34;text/javascript&#34;&gt;
    $(&#34;.faq-item&#34;).each( function() {
        $(this).click(function () {
            $(this).find(&#34;#arrow&#34;).toggleClass(&#34;flip&#34;); 
            $(this).find(&#34;.faq-answer&#34;).slideToggle(200); 
        });
    });
&lt;/script&gt;
&lt;h2 id=&#34;learn-more&#34;&gt;Learn More&lt;/h2&gt;
&lt;p&gt;If you’re new to messaging services, a great place to start learning is with our resources for &lt;a href=&#34;/patterns/eventing/&#34;&gt;event-driven architecture&lt;/a&gt;. If you’re a Spring developer, make sure to check out our guides to get started with &lt;a href=&#34;/guides/messaging-and-integration/rabbitmq-gs&#34;&gt;RabbitMQ&lt;/a&gt;, &lt;a href=&#34;/guides/messaging-and-integration/kafka-gs/&#34;&gt;Kafka&lt;/a&gt;, and &lt;a href=&#34;/guides/event-streaming/scs-gs/&#34;&gt;Spring Cloud Stream&lt;/a&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      
      <title>Samples: Getting Started with RabbitMQ</title>
      
      <link>/samples/rabbitmq-gs/</link>
      <pubDate>Wed, 06 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/samples/rabbitmq-gs/</guid>
      <description>

        
        
      </description>
    </item>
    
    <item>
      
      <title>Guides: Getting Started with RabbitMQ</title>
      
      <link>/guides/messaging-and-integration/rabbitmq-gs/</link>
      <pubDate>Wed, 06 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/guides/messaging-and-integration/rabbitmq-gs/</guid>
      <description>

        
        &lt;h2 id=&#34;what-is-rabbitmq&#34;&gt;What Is RabbitMQ?&lt;/h2&gt;
&lt;p&gt;At a high level, &lt;a href=&#34;https://www.rabbitmq.com/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;RabbitMQ&lt;/a&gt; is an open source message broker. A message broker accepts and translates messages from a producer (the message sender) and holds it in a queue so that a consumer (the message receiver) can retrieve it. This allows for multiple producers and consumers to share the same queue without having to directly pass messages between each other. What RabbitMQ excels at is doing this at scale while staying lightweight and easy to deploy.&lt;/p&gt;
&lt;h2 id=&#34;before-you-begin&#34;&gt;Before You Begin&lt;/h2&gt;
&lt;p&gt;Before you begin, there are a few tools you will need:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/get-docker/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Docker&lt;/a&gt;. You’ll run your RabbitMQ server in a container to ease the setup. If you’d prefer to run RabbitMQ natively, checkout the documentation on &lt;a href=&#34;https://www.rabbitmq.com/download.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;RabbitMQ’s website&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Your text editor or IDE of choice.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.oracle.com/java/technologies/javase-downloads.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;JDK 1.8&lt;/a&gt; or newer.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can see the &lt;a href=&#34;https://github.com/BrianMMcClain/rabbitmq-getting-started&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;completed example on GitHub&lt;/a&gt;, including examples in other languages.&lt;/p&gt;
&lt;h2 id=&#34;using-rabbitmq&#34;&gt;Using RabbitMQ&lt;/h2&gt;
&lt;p&gt;To ease the setup of our RabbitMQ node, you’ll run the RabbitMQ container image from Docker Hub. Luckily, a lot of work has gone into this container image and there’s a lot of settings that you could tweak to meet your exact needs. For this example, you’ll just need a simple single-node RabbitMQ server, so you won’t need to change any of the default settings. You can run the container image with the following:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run -it --rm -p 5672:5672 -p 15672:15672 rabbitmq:3-management&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Here, you’ll run the &lt;code&gt;3-management tag&lt;/code&gt; of the RabbitMQ container image. The &lt;code&gt;3-management&lt;/code&gt; tag of this image ships with the &lt;a href=&#34;https://www.rabbitmq.com/management.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;management plug-in&lt;/a&gt;, which will provide an HTTP API and web-based UI for your RabbitMQ server. You’ll tell Docker to run this with an interactive shell with the &lt;code&gt;-it&lt;/code&gt; option, as well as tell it to automatically remove the container when it exits with the &lt;code&gt;-rm&lt;/code&gt; option. You’ll also forward a couple of ports (5672 for the RabbitMQ server and 15672 for the HTTP API and web UI) from your local machine to the container, which means that you can connect to it on &lt;code&gt;localhost&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To access the web UI, go to &lt;a href=&#34;http://localhost:15672&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;http://localhost:15672&lt;/a&gt;. The &lt;code&gt;username&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; are both &lt;code&gt;guest&lt;/code&gt;. Here you can change settings, add and remove users, as well as view diagnostic information from the server.&lt;/p&gt;
&lt;h3 id=&#34;building-the-emitter&#34;&gt;Building the Emitter&lt;/h3&gt;
&lt;p&gt;First, you’ll need some code to emit messages to RabbitMQ. There are &lt;a href=&#34;https://www.rabbitmq.com/devtools.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;client libraries&lt;/a&gt; for many languages and frameworks, but this example has been written in Java. You can find examples for other languages, as well as the full example put together, &lt;a href=&#34;https://github.com/BrianMMcClain/rabbitmq-getting-started&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Before you can begin sending messages to RabbitMQ, you’ll first need to connect to the server.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Connect to the RabbitMQ server
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ConnectionFactory&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factory&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ConnectionFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;factory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setHost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;localhost&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Connection&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;connection&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;newConnection&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here, a &lt;code&gt;ConnectionFactory&lt;/code&gt; is used to create the new connection. Since the server does not require a username or password, only the hostname needs to be set. Also, since all of the container’s required ports are published, you can connect on &lt;code&gt;localhost&lt;/code&gt;. Finally, since the &lt;code&gt;factory.newConnection()&lt;/code&gt; call can throw both an &lt;code&gt;IOException&lt;/code&gt; and a &lt;code&gt;TimeoutException&lt;/code&gt;, you can start the connection in a new &lt;code&gt;try&lt;/code&gt; block.&lt;/p&gt;
&lt;p&gt;Great! You’ve connected to the RabbitMQ server, but now you’ll need to create a &lt;a href=&#34;https://www.rabbitmq.com/channels.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;channel&lt;/a&gt; (a logical connection within your physical connection) to communicate over, as well as a &lt;a href=&#34;https://www.rabbitmq.com/queues.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;queue&lt;/a&gt; to send messages to. Make sure to refer to the RabbitMQ documentation for more information on both channels and queues. This can be done in a few lines of code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Create a channel
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Channel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;channel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;connection&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;createChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Create and connect to the queue. The arguments, in order, are:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// queue - Name of the queue we are connecting on
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// durable - If true, RabbitMQ will write messages to disk
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// exclusive - If true, only this connection may connect to the queue
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// autoDelete - If true, the queue will be deleted when it is no longer in use
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// The final argument takes a Map of additional optional arguments
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;queueDeclare&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;QUEUE_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As noted in the comments of the code, &lt;code&gt;connection.createChannel()&lt;/code&gt; will create the channel for you without any arguments. Creating and connecting to the queue with &lt;code&gt;channel.queueDeclare()&lt;/code&gt;, however, will take a few arguments. Make sure to read the comments explaining each argument. Another thing to note is that if this queue already exists, the code will simply connect to the existing one.&lt;/p&gt;
&lt;p&gt;With this code, you’ve successfully done all of the setup needed to start sending messages!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Begin reading user input
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;gt; &amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;console&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;readLine&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
	
  &lt;span class=&#34;c1&#34;&gt;// Send the message to the queue
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;basicPublish&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QUEUE_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getBytes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Sent &amp;#39;&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#39;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The example will continuously loop, prompting the user to input the message  they wish to send, then send it to RabbitMQ with the &lt;code&gt;channel.basicPublish()&lt;/code&gt; method. From there, all that’s left is to close out the initial &lt;code&gt;try&lt;/code&gt; block by catching any exceptions that may occur.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getMessage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For the sake of simplicity, the example will just catch any exception thrown, but as always it’s best practice to catch the specific exceptions that the various methods throw. Connecting to the server may throw a &lt;code&gt;TimeoutException&lt;/code&gt;, for example, but publishing the message could throw an &lt;code&gt;IOException&lt;/code&gt;. Once it’s all put together, the code looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.github.brianmmcclain.rabbitmqgettingstarted&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.rabbitmq.client.ConnectionFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.rabbitmq.client.Connection&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.rabbitmq.client.Channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;emitter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;

	&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QUEUE_NAME&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
		
		&lt;span class=&#34;c1&#34;&gt;// Connect to the RabbitMQ server
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;n&#34;&gt;ConnectionFactory&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factory&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ConnectionFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;factory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setHost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;localhost&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;

		&lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;Connection&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;connection&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;newConnection&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
				
			&lt;span class=&#34;c1&#34;&gt;// Create a channel
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;n&#34;&gt;Channel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;channel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;connection&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;createChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
			
			&lt;span class=&#34;c1&#34;&gt;// Create and connect to the queue. The arguments, on order, are:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;c1&#34;&gt;// queue - Name of the queue we are connecting on
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;c1&#34;&gt;// durable - If true, RabbitMQ will write messages to disk
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;c1&#34;&gt;// exclusive - If true, only this connection may connect to the queue
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;c1&#34;&gt;// autoDelete - If true, the queue will be deleted when it is no longer in use
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;c1&#34;&gt;// The final argument takes a Map of additional optional arguments
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;n&#34;&gt;channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;queueDeclare&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;QUEUE_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
			
			&lt;span class=&#34;c1&#34;&gt;// Begin reading user input
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;gt; &amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
				&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;console&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;readLine&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
				
				&lt;span class=&#34;c1&#34;&gt;// Send the message to the queue
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;				&lt;span class=&#34;n&#34;&gt;channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;basicPublish&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QUEUE_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getBytes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
				&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Sent &amp;#39;&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#39;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
			&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getMessage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If you’d like to build the emitter yourself, check out the &lt;a href=&#34;https://github.com/BrianMMcClain/rabbitmq-getting-started/tree/master/java/emitter&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;complete example on GitHub&lt;/a&gt; which includes the &lt;code&gt;pom.xml&lt;/code&gt; file with all the required dependencies. You can build the code by running:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./mvnw clean package&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;And run it with:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java -jar target/rabbitmq-getting-started-emitter-0.0.1-SNAPSHOT.jar&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;building-the-consumer&#34;&gt;Building the Consumer&lt;/h3&gt;
&lt;p&gt;Now that you’re emitting messages to RabbitMQ, you’ll need some code to consume those messages. The code to connect to the server is the same as the emitter. You’ll set up a &lt;code&gt;ConnectionFactory&lt;/code&gt; to connect on &lt;code&gt;localhost&lt;/code&gt; as well as create a channel with the &lt;code&gt;createChannel()&lt;/code&gt; method:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Connect to the RabbitMQ server
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ConnectionFactory&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factory&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ConnectionFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;factory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setHost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;localhost&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Connection&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;connection&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;newConnection&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// Create a channel and connect it to the queue
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;Channel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;channel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;connection&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;createChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;

  &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Waiting for messages. To exit press CTRL+C\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You’ll need to do something a bit different for consuming messages, however, as the code doesn’t know when messages are coming in. For this limited example, sitting around waiting for the next message may be fine, but that may not be the case for a more realistic use case., So, you’ll need to create a callback. That way any time your code receives a new message, the callback will be invoked with the details of the message.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Setup the callback to be invoked when a new message is received
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DeliverCallback&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;deliverCallback&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;consumerTag&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delivery&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// Read the message from the message object and print to stdout
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delivery&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getBody&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;gt; &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With the callback defined, you’ll then need to tell the server you’re ready to start consuming messages from the queue. You can do this with the &lt;code&gt;basicConsume()&lt;/code&gt; method by providing it with the queue you wish to consume from as well as the callback to invoke when a message is received:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Begin consuming messages from the queue. The second argument will tell
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
 &lt;span class=&#34;c1&#34;&gt;// RabbitMQ to automatically consider the message acknowledged once received.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;basicConsume&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;QUEUE_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;deliverCallback&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;consumerTag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, as with the emitter, all that remains is to handle any exceptions thrown in the &lt;code&gt;try&lt;/code&gt; block. Take a look at the whole code put together:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.github.brianmmcclain.rabbitmqgettingstarted&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.rabbitmq.client.Channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.rabbitmq.client.Connection&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.rabbitmq.client.ConnectionFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.rabbitmq.client.DeliverCallback&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;consumer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;

	&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QUEUE_NAME&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
		
		&lt;span class=&#34;c1&#34;&gt;// Connect to the RabbitMQ server
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;n&#34;&gt;ConnectionFactory&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factory&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ConnectionFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;factory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setHost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;localhost&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
		
		&lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;Connection&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;connection&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;newConnection&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;

			&lt;span class=&#34;c1&#34;&gt;// Create a channel and connect it to the queue
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;n&#34;&gt;Channel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;channel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;connection&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;createChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Waiting for messages. To exit press CTRL+C\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;

			&lt;span class=&#34;c1&#34;&gt;// Setup the callback to be invoked when a new message is received
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;n&#34;&gt;DeliverCallback&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;deliverCallback&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;consumerTag&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delivery&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;c1&#34;&gt;// Read the message from the message object and print to stdout
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;				&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delivery&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getBody&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
				&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;gt; &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
			&lt;span class=&#34;o&#34;&gt;};&lt;/span&gt;

			&lt;span class=&#34;c1&#34;&gt;// Begin consuming messages from the queue. The second argument will tell
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;c1&#34;&gt;// RabbitMQ to automatically consider the message acknowledged once received.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;n&#34;&gt;channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;basicConsume&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;QUEUE_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;deliverCallback&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;consumerTag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getMessage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Much as you can with the emitter, you can see the entire example for the consumer &lt;a href=&#34;https://github.com/BrianMMcClain/rabbitmq-getting-started/tree/master/java/consumer&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;on GitHub&lt;/a&gt; which includes the &lt;code&gt;pom.xml&lt;/code&gt; file with all the required dependencies. You can build the code by running:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./mvnw clean package&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;And run it with:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java -jar target/rabbitmq-getting-started-emitter-0.0.1-SNAPSHOT.jar&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;running-the-code&#34;&gt;Running the Code&lt;/h2&gt;
&lt;p&gt;Assuming you’ve already started the RabbitMQ container, you can run this example by opening two terminals, running the emitter in one and the consumer in the other.&lt;/p&gt;
&lt;p&gt;Terminal 1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ java -jar target/rabbitmq-getting-started-emitter-0.0.1-SNAPSHOT.jar
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Terminal 2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ java -jar target/rabbitmq-getting-started-consumer-0.0.1-SNAPSHOT.jar
Waiting for messages. To exit press CTRL+C

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, in the first terminal, you may begin typing the message you’d like to send, pressing [Enter] to send it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ java -jar target/rabbitmq-getting-started-emitter-0.0.1-SNAPSHOT.jar
&amp;gt; Hello RabbitMQ!
Sent &#39;Hello RabbitMQ!&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the second terminal, you should see that the message was received:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ java -jar target/rabbitmq-getting-started-consumer-0.0.1-SNAPSHOT.jar
Waiting for messages. To exit press CTRL+C

 &amp;gt; Hello RabbitMQ!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Congratulations! You’ve just sent and received your first message using RabbitMQ!&lt;/p&gt;
&lt;h3 id=&#34;multiple-consumers&#34;&gt;Multiple Consumers&lt;/h3&gt;
&lt;p&gt;There’s still so much that RabbitMQ can offer with regards to how messages can be sent and received, different delivery methods, and different ways to include information around your messages. For example, you may wish for all consumers to receive a message, or for exactly one consumer to receive a message. To learn more make sure to &lt;a href=&#34;https://www.rabbitmq.com/getstarted.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;check out the documentation on the RabbitMQ website&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;One interesting scenario to explore is the case of multiple consumers. You can start multiple consumers and, as you’ll notice,  each message is delivered to only one consumer, alternating which consumer gets which message. Give it a try by opening up a third terminal and running another instance of the consumer. Try sending several messages from the emitter:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ java -jar target/rabbitmq-getting-started-emitter-0.0.1-SNAPSHOT.jar
&amp;gt; 1
Sent &#39;1&#39;
&amp;gt; 2
Sent &#39;2&#39;
&amp;gt; 3
Sent &#39;3&#39;
&amp;gt; 4
Sent &#39;4&#39;
&amp;gt; 5
Sent &#39;5&#39;
&amp;gt; 6
Sent &#39;6&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You’ll notice that one consumer only received half of the messages:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ java -jar target/rabbitmq-getting-started-consumer-0.0.1-SNAPSHOT.jar
Waiting for messages. To exit press CTRL+C

 &amp;gt; 1
 &amp;gt; 3
 &amp;gt; 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;While the other consumer received the other half:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ java -jar target/rabbitmq-getting-started-consumer-0.0.1-SNAPSHOT.jar
Waiting for messages. To exit press CTRL+C

 &amp;gt; 2
 &amp;gt; 4
 &amp;gt; 6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is one pattern that can be leveraged for scenarios where you only need one consumer to process a message. But it will allow you to easily scale up to meet the workload your environment needs just by adding more consumers.&lt;/p&gt;
&lt;h2 id=&#34;keep-learning&#34;&gt;Keep Learning&lt;/h2&gt;
&lt;p&gt;This overview has only scratched the surface of the capabilities of RabbitMQ;  there are many more docs that lay out  &lt;a href=&#34;https://www.rabbitmq.com/getstarted.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;how to route and deliver messages&lt;/a&gt;, as well as how to &lt;a href=&#34;https://www.rabbitmq.com/clustering.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;build and configure bigger, more robust and reliable clusters&lt;/a&gt;. The &lt;a href=&#34;https://www.rabbitmq.com/documentation.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;official RabbitMQ documentation&lt;/a&gt; is very thorough and covers both operation and development using RabbitMQ.&lt;/p&gt;
&lt;p&gt;Additionally, if you’re a Spring developer, make sure to check out &lt;a href=&#34;/guides/event-streaming/scs-gs&#34;&gt;Getting Started With Spring Cloud Stream&lt;/a&gt;, which is a very powerful way of implementing messaging using the message broker of your choice. Or, if you are using Kubernetes, check out &lt;a href=&#34;https://tanzu.vmware.com/content/blog/introducing-rabbitmq-for-kubernetes&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;RabbitMQ for Kubernetes&lt;/a&gt;.&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
